{
    "Diameter": {
        "prefix": [
            "Lib_GT_木の直径"
        ],
        "body": [
            "",
            "from collections import deque",
            "",
            "",
            "def _bfs(n, G, root=0):",
            "    _depth = [None] * n",
            "    q = deque()",
            "    q.append(root)",
            "    _depth[root] = 0",
            "    _parent = [None] * n",
            "    last_node = root",
            "    while q:",
            "        cur = q.popleft()",
            "        dep = _depth[cur]",
            "        for nxt in G[cur]:",
            "            if _depth[nxt] != None: continue",
            "            q.append(nxt)",
            "            newdep = dep + 1",
            "            _depth[nxt] = newdep",
            "            _parent[nxt] = cur",
            "            last_node = nxt",
            "    return last_node, _depth[last_node], _depth, _parent",
            "",
            "",
            "def tree_diameter(n, G):",
            "    u, *_ = _bfs(n, G, 0)",
            "    v, diam, depth, parent = _bfs(n, G, u)",
            "    return u, v, diam, depth, parent",
            "",
            "",
            "def tree_heights(n, G):",
            "    u, *_ = _bfs(n, G, 0)",
            "    v, _, depthu, _ = _bfs(n, G, u)",
            "    _, __, depthv, __ = _bfs(n, G, v)",
            "    return [max(x, y) for x, y in zip(depthu, depthv)]",
            "",
            "",
            "def tree_centre(n, G):",
            "    \"\"\"木の中心",
            "    \"\"\"",
            "    u, v, diam, depth, parent = tree_diameter(n, G)",
            "    hd = diam // 2",
            "    centre = v",
            "    while diam - depth[centre] < hd:",
            "        centre = parent[centre]",
            "    if diam%2==0:",
            "        return u, v, diam, (centre, centre)",
            "    else:",
            "        return u, v, diam, (parent[centre], centre)",
            "",
            "",
            "def count_diameter(n, G):",
            "    \"\"\"cntは中心からの各部分木の(ノード数, 最遠葉)",
            "",
            "    countは直径の本数",
            "    \"\"\"",
            "    def dfs(x, p, d, r):",
            "        nodecount = 1",
            "        farestleaf = d == r",
            "        for nx in G[x]:",
            "            if nx == p: continue",
            "            u, v = dfs(nx, x, d+1, r)",
            "            nodecount += u",
            "            farestleaf += v",
            "        return nodecount, farestleaf",
            "    _, _, diam, (cu, cv) = tree_centre(n, G)",
            "",
            "    r = diam // 2",
            "    cnt = []",
            "    if cu == cv:",
            "        for nx in G[cu]:",
            "            cnt.append(dfs(nx, cu, 1, r))",
            "    else:",
            "        cnt.append(dfs(cu, cv, 0, r))",
            "        cnt.append(dfs(cv, cu, 0, r))",
            "",
            "    sig, sig2 = 0, 0",
            "    for _, ci in cnt:",
            "        sig += ci",
            "        sig2 += ci * ci",
            "    count = sig * sig - sig2",
            "    count //= 2",
            "    return (cu, cv), count",
            "",
            "",
            "##############################",
            "",
            "n = int(input())",
            "G = [[] for _ in range(n)]",
            "for _ in range(n-1):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G[a].append(b)",
            "    G[b].append(a)",
            "",
            "print(tree_diameter(n, G))",
            "print('-------------------')",
            "print(tree_heights(n, G))",
            "print('-------------------')",
            "print(tree_centre(n, G))",
            "print('-------------------')",
            "print(count_diameter(n, G))",
            "",
            ""
        ],
        "description": [
            "木の直径"
        ]
    },
    "Lib_G_グラフ橋関節_lowlink": {
        "prefix": [
            "Lib_G_グラフ橋関節_lowlink"
        ],
        "body": [
            "#関節 https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/3/GRL_3_A",
            "#橋 https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/3/GRL_3_B",
            "",
            "class LowLink():",
            "    def __init__(self, G):",
            "        self.n = len(G)",
            "        self.ord = [None]*self.n    # DFS 行きがけ順",
            "        self.low = [None]*self.n    # lowlink",
            "        self.son = [[] for _ in range(self.n)]  # son[i] := 頂点iの子を格納したlist",
            "        self.back_edge = [[] for _ in range(self.n)] # back_edge[i] := 頂点iから出る後退辺の終点を格納したlist",
            "        self.tps = []                           # 頂点のトポロジカルソート",
            "        self.bridges = []",
            "",
            "    def build(self, root=0):",
            "        # DFSでord, son, tpsを求め、lowを初期化",
            "        time = 0 # DFSでの行きがけ順",
            "        stack = [(None, root)] # 直前にいた頂点, 今いる頂点",
            "        while stack:",
            "            pre, now = stack.pop()",
            "            if self.ord[now] is not None: # 後退辺を通ってきた場合",
            "                if self.ord[pre] < self.ord[now]: continue # 後退辺を根側から進んでいた場合は無視",
            "                self.low[pre] = min(self.low[pre], self.ord[now]) # low[pre]をord[now]でchmin",
            "                self.back_edge[pre].append(now)",
            "                continue",
            "            if pre is not None: self.son[pre].append(now)   # 親子関係を記録",
            "            self.tps.append(now)",
            "            self.ord[now] = time",
            "            self.low[now] = self.ord[now] # low[now]をord[now]で初期化",
            "            time += 1",
            "            for next in G[now]:",
            "                if next == pre: continue",
            "                stack.append((now, next))",
            "        for u in reversed(self.tps):# トポソ逆順にlowを求める",
            "            for v in self.son[u]:",
            "                self.low[u] = min(self.low[u], self.low[v])",
            "            for v in self.son[u]:",
            "                if self.low[v] > self.ord[u]:",
            "                    self.bridges.append((min(u, v), max(u, v)))",
            "",
            "    def two_edge_connected_component(self):",
            "        # 二重辺連結成分分解",
            "        tecc = []                   # tecc[i] := 連結成分iの頂点グループ",
            "        tecc_idx = [None]*self.n    # tecc_idx[i] := 頂点iが属する連結成分ID",
            "        tecc_tree = []              # 連結成分を頂点、橋を辺としたグラフ(木)の隣接リスト",
            "",
            "        sub_roots = [(None, 0)]     # 橋を見つけるごとに、その先は部分木として別にDFSしなおす。",
            "        idx = 0     # 今いる頂点の連結成分の番号",
            "        while sub_roots:",
            "            stack = [sub_roots.pop()] # 部分木の根からDFS",
            "            tecc.append([]) # 今いる頂点の連結成分を格納するlistを追加",
            "            tecc_tree.append([]) # 今いる頂点の連結成分の隣接先を格納するlistを追加",
            "            while stack:",
            "                pre, now = stack.pop()",
            "                tecc[idx].append(now)   # 今いる頂点を連結成分idxに追加",
            "                tecc_idx[now] = idx     # 今いる頂点の連結成分の番号idxを記録",
            "                if pre is not None and idx != tecc_idx[pre]: # 直前に橋を通ってきていたら",
            "                    tecc_tree[idx].append(tecc_idx[pre]) # その橋で繋がれた2つの連結成分を辺で結ぶ",
            "                    tecc_tree[tecc_idx[pre]].append(idx)",
            "                for next in self.son[now]:",
            "                    if self.low[next] > self.ord[now]: # 橋なら",
            "                        sub_roots.append((now, next)) # その先は別の連結成分",
            "                    else:",
            "                        stack.append((now, next)) # その先は同じ連結成分なのでDFSを続ける",
            "            idx += 1",
            "        return tecc, tecc_idx, tecc_tree",
            "",
            "    def biconnected_component(self):",
            "        # 二重頂点連結成分分解",
            "        bce = [] # bce[i] := 連結成分iに属する辺を格納したlist",
            "        bcv = [] # bcv[i] := 連結成分iに属する頂点を格納したlist",
            "        is_ap = [False]*self.n # is_ap[i] := 頂点iは関節点であるか(True/False)",
            "        sub_roots = [(None, 0)] #「ある子に対する関節点」を見つけるごとに、その子以降は部分木として別にDFSしなおす。",
            "        idx = 0 # 今いる頂点の連結成分の番号",
            "        while sub_roots:",
            "            stack = [sub_roots.pop()] # 部分木の根からDFS",
            "            bce.append([]) # 今いる頂点の連結成分に含まれる辺を格納するlistを追加",
            "            bcv.append([]) # 今いる頂点の連結成分に含まれる頂点を格納するlistを追加",
            "            if stack[0][0] is not None: # 直前に通った頂点(関節点)が存在するなら",
            "                bcv[idx].append(stack[0][0]) # それを連結成分idxに追加",
            "            while stack:",
            "                pre, now = stack.pop()",
            "                if pre is not None: # 直前に通った辺が存在するなら",
            "                    bce[idx].append((pre, now)) # 通ってきた辺を連結成分idxに追加",
            "                bcv[idx].append(now) # 今いる頂点を連結成分idxに追加",
            "                if now == 0: # 今いる頂点nowが根で",
            "                    if len(self.son[now]) >= 2: # 関節点であるなら",
            "                        for next in self.son[now]:",
            "                            is_ap[now] = True # 関節点であことを記録",
            "                            sub_roots.append((now, next)) # その先は別の連結成分",
            "                        bce.pop() # 「根の関節点のみ」の連結成分は存在しないが追加してしまっているので、例外的に削除する",
            "                        bcv.pop()",
            "                        idx -= 1",
            "                    else: # 関節点でないなら",
            "                        for next in self.son[now]:",
            "                            stack.append((now, next)) # その先は同じ連結成分なのでDFSを続ける",
            "                else: # 根でなく",
            "                    for next in self.son[now]:",
            "                        if self.low[next] >= self.ord[now]: # 子nextに対して関節点なら",
            "                            is_ap[now] = True # 関節点であることを記録",
            "                            sub_roots.append((now, next)) # その先は別の連結成分",
            "                        else: # 関節点でないなら",
            "                            stack.append((now, next)) # その先は同じ連結成分なのでDFSを続ける",
            "                if now == 0 and len(self.son[now]) <= 1:",
            "                    for back in self.back_edge[now]: # 今いる頂点から出る後退辺は同じ連結成分なので",
            "                        bce[idx].append((now, back)) # 連結成分idxに追加",
            "            idx += 1",
            "        return bce, bcv, is_ap",
            "",
            "    # block-cut treeを構築",
            "    def block_cut_tree(self):",
            "        bce, bcv, is_ap = self.biconnected_component() # 二重頂点連結成分分解",
            "        num_ap = sum(is_ap) # 関節点の個数",
            "        bc = [[] for _ in range(num_ap+len(bcv))]",
            "        # bc[i] := block-cut tree上の頂点iに対応する頂点を格納したlist",
            "        # [0:num_ap)は関節点に対応する頂点で、その関節点のみがlistに含まれる",
            "        # [num_ap:len(bc))は連結成分に対応する頂点で、その連結成分から関節点を除いたものがlistに含まれる",
            "        # block-cut tree上の頂点iが関節点に対応している ⇔ i < num_ap",
            "        bc_idx = [None]*self.n",
            "        # bc_idx[i] := (元グラフの)頂点iが属するblock-cut tree上の頂点の番号(bc, bc_treeのindexに対応)",
            "        # 関節点でない頂点iについて、対応するbce, bcvのindexが知りたい場合、bc_idx[i]-num_apで取得可能。",
            "        bc_tree = [[] for _ in range(num_ap+len(bcv))] # bc_tree[i] := block-cut tree上の頂点iの隣接頂点を格納したlist",
            "        idx = 0 # 今見ているblock-cut tree上の頂点番号",
            "        for v in range(self.n): # (元グラフの)各頂点vについて",
            "            if is_ap[v]: # 関節点なら",
            "                bc[idx].append(v) # block-cut tree上の頂点idxにvを対応させる",
            "                bc_idx[v] = idx",
            "                idx += 1",
            "        for bcv_i in bcv: # 各連結成分の",
            "            for v in bcv_i: # 各頂点vについて",
            "                if is_ap[v]: # 関節点なら",
            "                    bc_tree[idx].append(bc_idx[v]) # block-cut tree上の頂点idxと関節点vに対応した頂点を辺で結ぶ",
            "                    bc_tree[bc_idx[v]].append(idx)",
            "                else: # そうでないなら",
            "                    bc[idx].append(v) # block-cut tree上の頂点idxに対応した頂点集合に頂点vを追加",
            "                    bc_idx[v] = idx",
            "            idx += 1",
            "        return bc, bc_idx, bc_tree, num_ap, bce, bcv, is_ap",
            "",
            "#####################################################",
            "",
            "n, m = map(int, input().split())",
            "G = [[] for _ in range(n)]",
            "for _ in range(m):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G[a].append(b)",
            "    G[b].append(a)",
            "x = LowLink(G)",
            "x.build()",
            "for i, xi in enumerate(x.biconnected_component()[-1]):",
            "    if xi: print(i)",
            "",
            "# https://kntychance.hatenablog.jp/entry/2022/09/16/161858",
            "# n = 10",
            "# m = 12",
            "# edge = [(0,1), (1,2), (2,3), (2,4), (2,5), (1,5), (1,6), (1,8), (6,7), (6,8), (0,9), (8,9)]",
            "# G = [[] for _ in range(n)]",
            "# for _ in range(m):",
            "#     # a, b = map(int, input().split())",
            "#     # a -= 1; b -= 1",
            "#     G[a].append(b)",
            "#     G[b].append(a)",
            "# for gi in G:",
            "#     gi.sort(reverse=True)",
            "",
            "# x = LowLink(G)",
            "# x.build()",
            "# print(x.ord)",
            "# print(x.son)",
            "# print(x.low)",
            "#print(x.bridges)",
            "#print(x.two_edge_connected_component())",
            "# print(x.biconnected_component())",
            ""
        ],
        "description": [
            "グラフの橋・関節をO(n)で検出"
        ]
    },
    "半分全列挙": {
        "prefix": [
            "Lib_A_半分全列挙"
        ],
        "body": [
            "# https://atcoder.jp/contests/abc184/tasks/abc184_f",
            "# 半分全列挙",
            "# n <= 40 だと半分で全列挙したものをそれぞれ計算してマージ処理する",
            "",
            "n, t = map(int, input().split())",
            "vs = list(map(int, input().split()))",
            "",
            "def get_list(vl):",
            "    ret = [0]",
            "    svl = sorted(vl)",
            "    for vi in svl:",
            "        for j in range(len(ret)):",
            "            x = vi + ret[j]",
            "            if x > t: continue",
            "            ret.append(x)",
            "    return sorted(ret)",
            "",
            "lower = get_list(vs[:n//2])",
            "upper = get_list(vs[n//2:])",
            "",
            "ret = 0",
            "up = len(upper) - 1",
            "for f in lower:",
            "    while up >= 0 and (upper[up]+f) > t:",
            "        up -= 1",
            "    ret = max(ret, upper[up]+f)",
            "",
            "print(ret)",
            ""
        ],
        "description": [
            "半分全列挙"
        ]
    },
    "ループ#": {
        "prefix": [
            "Lib_Loop_ループ"
        ],
        "body": [
            "class Loop():",
            "    \"\"\"ループを検索して計算量圧縮",
            "",
            "        Parameters",
            "        ----------",
            "        n : int",
            "            鳩の巣の数",
            "        x : int",
            "            初期値",
            "        f : function",
            "            次の値を決める関数",
            "",
            "        Notes",
            "        ----------",
            "        0->1->...->s_t-1 -> st->...-> s_t+x─┐",
            "                             └─────────┘",
            "        https://atcoder.jp/contests/typical90/tasks/typical90_bf",
            "",
            "    \"\"\"",
            "    def __init__(self, n, x, f, g):",
            "        self.hole = n",
            "        self.ini_p = x",
            "        self.nextp = f",
            "        self.value = g",
            "        self.__build()",
            "",
            "",
            "    def __build(self):",
            "        x = self.ini_p",
            "        seen = defaultdict(int)",
            "        seqs = []",
            "        for i in range(self.hole + 10):",
            "            seen[x] = i",
            "            seqs.append(x)",
            "            x = self.nextp(x)",
            "            if x in seen: break",
            "        p = seen[x]",
            "        self.ini_seq = self.sequence([self.value(pos) for pos in seqs[:p]])",
            "        self.lp_seq = self.sequence([self.value(pos) for pos in seqs[p:]])",
            "",
            "",
            "    def get_kth(self, k:int)->int:",
            "        \"\"\"k番目の値を取得",
            "        0-index",
            "        \"\"\"",
            "        if k < self.ini_seq.len:",
            "            return self.ini_seq.seq[k]",
            "        else:",
            "            k -= self.ini_seq.len",
            "            _, k = divmod(k, self.lp_seq.len)",
            "            return self.lp_seq.seq[k]",
            "",
            "",
            "    def sum_kth(self, k:int)->int:",
            "        \"\"\"k番目までの値の累積和を取得",
            "        0-index",
            "        \"\"\"",
            "        if k < self.ini_seq.len:",
            "            return self.ini_seq.acc[k]",
            "        else:",
            "            k -= self.ini_seq.len",
            "            t, k = divmod(k, self.lp_seq.len)",
            "            ret = self.ini_seq.acclast",
            "            ret += self.lp_seq.acclast * t",
            "            ret += self.lp_seq.acc[k]",
            "            return ret",
            "",
            "",
            "    class sequence:",
            "        def __init__(self, seq):",
            "            self.seq = seq          # 配列",
            "            self.len = len(seq)     # 配列の個数",
            "            self.acc = list(accumulate(seq))    # 配列の累積和",
            "            if self.len == 0:",
            "                self.acclast = 0    # 配列の累積和",
            "            else:",
            "                self.acclast = self.acc[-1]    # 配列の累積和",
            "",
            "",
            "n, k = map(int, input().split())",
            "",
            "if n == 0:",
            "    print(0)",
            "    exit()",
            "",
            "def f(x):",
            "    ...",
            "",
            "def g(x):",
            "    ...",
            "",
            "",
            "lp = Loop(n, 0, f, g)",
            "print(lp.get_kth(k))",
            ""
        ],
        "description": [
            "ループ#"
        ]
    },
    "強連結成分分解": {
        "prefix": [
            "Lib_GD_強連結成分分解_SCC"
        ],
        "body": [
            "class SCCGraph:",
            "    def __init__(self, N):",
            "        self.N = N",
            "        self.edges = []",
            "        self.ef, self.er = [[] for _ in range(N)], [[] for _ in range(N)]",
            "",
            "    def add_edge(self, v, w):",
            "        self.edges.append((v, w))",
            "        self.ef[v].append(w)",
            "        self.er[w].append(v)",
            "",
            "    def scc_group(self):",
            "        N = self.N",
            "        group = [None] * N",
            "        visited = [False] * N",
            "        order = []",
            "        for x in range(N):",
            "            if visited[x]: continue",
            "            stack = [x]",
            "            visited[x] = True",
            "            while stack:",
            "                y = stack.pop()",
            "                movable = False",
            "                for ny in self.ef[y]:",
            "                    if visited[ny]: continue",
            "                    movable = True",
            "                    visited[ny] = True",
            "                    stack.append(y)",
            "                    stack.append(ny)",
            "                    break",
            "                if not movable: order.append(y)",
            "        visited = [False] * N",
            "        count = 0",
            "        for x in order[::-1]:",
            "            if visited[x]: continue",
            "            stack = [x]",
            "            group[x] = count",
            "            while stack:",
            "                y = stack.pop()",
            "                visited[y] = 1",
            "                for ny in self.er[y]:",
            "                    if visited[ny]: continue",
            "                    group[ny] = count",
            "                    stack.append(ny)",
            "            count += 1",
            "        return count, group",
            "",
            "    def scc(self):",
            "        count, group = self.scc_group()",
            "        groups = [[] for _ in range(count)]",
            "        for i, x in enumerate(group):",
            "            groups[x].append(i)",
            "        return groups",
            "",
            "####################################",
            "",
            "n, m = map(int, input().split())",
            "scc = SCCGraph(n)",
            "",
            "for i in range(m):",
            "    _a, _b = map(int, input().split())",
            "#    _a -= 1; _b -= 1",
            "    scc.add_edge(_a, _b)",
            "",
            "_, gr = scc.scc_group()",
            "for _ in range(int(input())):",
            "    u, v = map(int, input().split())",
            "    print(int(gr[u] == gr[v]))",
            "",
            "# print(scc.scc_group())",
            "#(3,_[0,_1,_1,_1,_2])",
            "# print(scc.scc())",
            "#[[0],_[1,_2,_3],_[4]]",
            "",
            "# 強連結成分分解(SCC): グラフgに対するSCCを行う",
            "# https://hkawabata.github.io/technical-note/note/Algorithm/graph/scc.html",
            "# 有向グラフで、互いに行き来できる連結成分を分類する",
            "# 元の有向グラフが DAG でなくとも、そのグラフの SCC は DAG を形成する",
            "# 作り方",
            "# 適当に選んだ頂点から深さ優先（帰りがけ探索）し、1から番号を増やしながらラベリング：",
            "# エッジをすべて逆向きにしたグラフを用意：",
            "# 頂点のうち、ラベル番号が最大のものを選んでグラフ探索 → 通った頂点はすべて1つの SCC に属する：",
            "# 未探索の頂点のうち、ラベル番号が最大のものを選んでグラフ探索 → 通った頂点はすべて1つの SCC に属する：",
            "",
            "# https://atcoder.jp/contests/practice2/tasks/practice2_g",
            ""
        ],
        "description": [
            "強連結成分分解(SCC): グラフgに対するSCCを行う"
        ]
    },
    "intinput": {
        "prefix": [
            "intinput"
        ],
        "body": [
            "int(input())"
        ],
        "description": [
            "int型でのinput"
        ]
    },
    "inputsplit": {
        "prefix": [
            "inputsplit"
        ],
        "body": [
            "input().split()"
        ],
        "description": [
            "inputをsplit"
        ]
    },
    "mapint": {
        "prefix": [
            "mapintinput"
        ],
        "body": [
            "map(int, input().split())"
        ],
        "description": [
            "int型で複数数値のinput"
        ]
    },
    "mapint1": {
        "prefix": [
            "mapintinput1"
        ],
        "body": [
            "map(lambda x: int(x)-1, input().split())"
        ],
        "description": [
            "int型で複数数値の0-index input"
        ]
    },
    "listmapint": {
        "prefix": [
            "listmapintinput"
        ],
        "body": [
            "list(map(int, input().split()))"
        ],
        "description": [
            "int型でlistのinput"
        ]
    },
    "tuplemapint": {
        "prefix": [
            "tuplemapintinput"
        ],
        "body": [
            "tuple(map(int, input().split()))"
        ],
        "description": [
            "int型でtupleのinput"
        ]
    },
    "matrixintinput": {
        "prefix": [
            "[listmapint"
        ],
        "body": [
            "[list(map(int, input().split())) for _ in range($n)"
        ],
        "description": [
            "int型でmatrixのinput"
        ]
    },
    "matrixinput": {
        "prefix": [
            "[tupleinput()"
        ],
        "body": [
            "[tuple(map(int, input().split())) for _ in range($n)"
        ],
        "description": [
            "文字列でmatrixのinput"
        ]
    },
    "LIS最長増加部分列": {
        "prefix": [
            "Lib_LIS最長増加部分列"
        ],
        "body": [
            "#####################################",
            "# 最長増加部分列 dp[k]",
            "# 今まで見た来たものの中で、単調増加(非減少)な部分列であって、",
            "# 長さ k であるようなもののうち、その最後の要素の最小値",
            "# 新しいアイテムuだったとき",
            "# dp[k] < u となる一番右の列(k)を特定しその次のdp[k+1]を小さければ更新する",
            "# rem: kに対して単調増加",
            "from bisect import bisect, bisect_left",
            "",
            "class LIS:",
            "    \"\"\"",
            "    fg: 0:単調非減少, 1:単調増加",
            "    \"\"\"",
            "    def __init__(self, x:list, fg=1):",
            "        n = len(x)",
            "        res = [0] * n",
            "        dp = []",
            "        for i, xi in enumerate(x):",
            "            if fg == 0: # 非減少",
            "                pos = bisect(dp, xi)",
            "            elif fg == 1: # 単調増加",
            "                pos = bisect_left(dp, xi)",
            "            res[i] = pos + 1",
            "            if len(dp) <= pos:",
            "                dp.append(xi)",
            "            else:",
            "                dp[pos] = xi",
            "        self.length = len(dp)",
            "        restore = []",
            "        nw = self.length",
            "        for i in range(n)[::-1]:",
            "            if nw == res[i]:",
            "                restore.append(x[i])",
            "                nw -= 1",
            "        restore.reverse()",
            "        self.restore = restore",
            "        self.lis = dp",
            "        self.res = res",
            "",
            "",
            "",
            "####################################",
            "",
            "#n = int(input())",
            "#a = list(map(int, input().split()))",
            "n = 5",
            "a = [3, 1, 4, 2, 5, 9, 3]",
            "lis = LIS(a)",
            "print(LIS(a).length)",
            "",
            "# n = 5",
            "# a = [3, 1, 4, 2, 5, 9, 3]",
            "# length = 4",
            "# restore = [1, 2, 5, 9]",
            "# lis = [1, 2, 3, 9]",
            "# res = [1, 1, 2, 2, 3, 4, 3]",
            ""
        ],
        "description": [
            "Lib_LIS最長増加部分列"
        ]
    },
    "Graph二部グラフ": {
        "prefix": [
            "Lib_G_二部グラフ_bipartite"
        ],
        "body": [
            "",
            "import sys",
            "sys.setrecursionlimit(10**9)",
            "",
            "######################################",
            "# 二部グラフ(bipartite graph)",
            "# 頂点集合を2つに分割して各部分の頂点は互いに隣接しないようにできるグラフ",
            "# ノード2色を塗って、辺の両端は異なるようにできるか",
            "######################################",
            "######################################",
            "# 再帰版",
            "######################################",
            "# 深さ優先探索",
            "def is_bipartite(g, v, c):",
            "    global color",
            "    color[v] = c    # 色を塗る",
            "    for nv in g[v]: # 次のノードの探索",
            "        # すでに隣接の色が確定していて同じ色となっている場合終了",
            "        if color[nv] == c: return False",
            "        # 未確定の倍は反転させた色を塗って探索した結果を受け取る",
            "        if color[nv] == 0 and not is_bipartite(g, nv, -c): return False",
            "    return True",
            "",
            "",
            "######################################",
            "# 非再帰版",
            "######################################",
            "def is_bipartite(g, v, c):",
            "    global color",
            "    # 深さ優先探索",
            "    q = [(0, c)]",
            "    while q:",
            "        v, c = q.pop()",
            "        color[v] = c    # 色を塗る",
            "        for nv in g[v]: # 次のノードの探索",
            "            # すでに隣接の色が確定していて同じ色となっている場合終了",
            "            if color[nv] == c: return False",
            "            # 未確定の倍は反転させた色でキューに入れる",
            "            if color[nv] == 0:",
            "                q.append((nv, -c))",
            "    return True",
            "",
            "#######################################",
            "",
            "",
            "",
            "n, m = map(int, input().split())",
            "G = [[] for _ in range(n)]",
            "color = [0] * n     # 0:未確定 1:黒 -1:白",
            "",
            "# 隣接リストの作成",
            "for i in range(m):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G[a].append(b)",
            "    G[b].append(a)",
            "",
            "",
            "print(is_bipartite(G, 0, 1))",
            ""
        ],
        "description": [
            "Graph二部グラフ"
        ]
    },
    "差分最小値探索": {
        "prefix": [
            "Lib_差分最小値探索"
        ],
        "body": [
            "def near(a:list, b:list) -> tuple:",
            "    \"\"\"二つのソートされたリストの要素の差の最小値を探索",
            "",
            "    Returns",
            "    -------",
            "    tuple",
            "        最小となる位置の組み合わせと値",
            "        (i, j, a[i]-b[j])",
            "    \"\"\"",
            "    INF = float('inf')",
            "    if len(a) == 0 or len(b) == 0:",
            "        return (None, None, INF)",
            "    i, j = 0, 0",
            "    retd = INF",
            "    reta = -1",
            "    retb = -1",
            "    while i < len(a) and j < len(b):",
            "        dist = abs(a[i] - b[j])",
            "        if retd > dist:",
            "            retd = dist",
            "            reta= i",
            "            retb = j",
            "        if a[i] > b[j]:",
            "            j += 1",
            "        elif a[i] < b[j]:",
            "            i += 1",
            "        else:",
            "            break",
            "    return (reta, retb, retd)"
        ],
        "description": [
            "差分最小値探索"
        ]
    },
    "各桁の寄与度": {
        "prefix": [
            "Lib_O_各桁の寄与度"
        ],
        "body": [
            "def sum_digit(s, d=10, mod=-1):",
            "    n = len(s)",
            "    ret = 0",
            "",
            "    pow_2 = [1]",
            "    pow_d = [1]",
            "    div = pow(d-2, mod - 2, mod)",
            "    for _ in range(n):",
            "        if mod == -1:",
            "            pow_2.append(pow_2[-1] * 2)",
            "            pow_d.append(pow_d[-1] * d)",
            "        else:",
            "            pow_2.append(pow_2[-1] * 2 % mod)",
            "            pow_d.append(pow_d[-1] * d % mod)",
            "",
            "    def _contribute(k):",
            "        r = pow_2[n-1-k] * ((d-1)* pow_d[k] - pow_2[k])",
            "        if mod == -1:",
            "            r //= d-2",
            "        else:",
            "            r *= div",
            "        return r",
            "",
            "",
            "    for i, si in enumerate(s[::-1]):",
            "        ret += _contribute(i) * int(si) % mod",
            "    return ret % mod",
            "",
            "mod = 998244353",
            "s = input()",
            "print(sum_digit(s, 10, mod))",
            ""
        ],
        "description": [
            "各桁の寄与度",
            "356"
        ]
    },
    "高速フーリエ変換(convolution, FFT)": {
        "prefix": [
            "Lib_C_FFT"
        ],
        "body": [
            "# https://atcoder.jp/contests/practice2/tasks/practice2_f",
            "# https://atcoder.jp/contests/atc001/tasks/fft_c",
            "",
            "mod =",
            "",
            "g = 3   #primitive root",
            "ginv = pow(g, mod-2, mod)",
            "",
            "W = [pow(g, (mod-1)>>i, mod) for i in range(24)]",
            "Winv = [pow(ginv, (mod-1)>>i, mod) for i in range(24)]",
            "",
            "def fft(k, f):",
            "    for l in range(1, k+1)[::-1]:",
            "        d = 1 << l - 1",
            "        U = [1]",
            "        for i in range(d):",
            "            U.append(U[-1]*W[l]%mod)",
            "        for i in range(1<<k - l):",
            "            for j in range(d):",
            "                s = i*2*d + j",
            "                f[s], f[s+d] = (f[s] + f[s+d])%mod, U[j]*(f[s] - f[s+d])%mod",
            "",
            "def ifft(k, f):",
            "    for l in range(1,k+1):",
            "        d = 1 << l - 1",
            "        for i in range(1<<k - l):",
            "            u = 1",
            "            for j in range(i*2*d, (i*2+1)*d):",
            "                f[j+d] *= u",
            "                f[j],f[j+d] = (f[j]+f[j+d])%mod, (f[j]-f[j+d])%mod",
            "                u = u * Winv[l] % mod",
            "",
            "def convolve(a, b):",
            "    la, lb = len(a), len(b)",
            "    le = la + lb - 1",
            "    k = le.bit_length()",
            "    n = 1 << k",
            "    ninv = pow(n,mod-2,mod)",
            "    a += [0]*(n-la)",
            "    b += [0]*(n-lb)",
            "    fft(k,a)",
            "    fft(k,b)",
            "    a = [ai * bi % mod for ai, bi in zip(a, b)]",
            "    ifft(k,a)",
            "    return [ai * ninv % mod for ai in a[:le]]",
            "",
            "",
            "n,m = map(int,input().split())",
            "A = list(map(int,input().split()))",
            "B = list(map(int,input().split()))",
            "",
            "print(*convolve(A,B))",
            ""
        ],
        "description": []
    },
    "ユニオンファインド重み付き": {
        "prefix": [
            "Lib_G_unionfind_weighted"
        ],
        "body": [
            "class UnionFindWeighted:",
            "    def __init__(self, n):                      # 初期化",
            "        self.n = n                              # 要素数",
            "        self.parents = [i for i in range(n)]    # 親",
            "        self.ranks = [0] * n                    # 木の深さ",
            "        self.sizes = [1] * n                    # グループの要素数",
            "        self.weights = [0] * n                  # 親との重み",
            "        self.isvalid = [True] * n               # ポテンシャルがプラスの閉路あり",
            "",
            "    #親を出力",
            "    def find(self, x):",
            "        if self.parents[x] == x:",
            "            return x",
            "        else:",
            "            p = self.find(self.parents[x])",
            "            self.weights[x] += self.weights[self.parents[x]]",
            "            self.parents[x] = p",
            "            return p",
            "",
            "    # ユニオン",
            "    def unite(self, x, y, w):",
            "        rx = self.find(x)",
            "        ry = self.find(y)",
            "        if rx == ry:",
            "            if self.diff(x, y) != w:",
            "                self.isvalid[rx] = False",
            "                return \"invalid\"",
            "            else:",
            "                return \"pass\"",
            "        # a[x]->a[y]  の差はw  # a[y] = a[x] + w",
            "        wx = self.weight(x)",
            "        wy = self.weight(y)",
            "        if rx == ry: return",
            "        if self.ranks[rx] > self.ranks[ry]:",
            "            rx , ry = ry, rx    #ryを親にする",
            "            wx , wy = wy, wx",
            "            w *= -1",
            "        self.parents[rx] = ry",
            "        self.sizes[ry] += self.sizes[rx]",
            "        self.weights[rx] = wy - wx - w",
            "        if self.ranks[rx]==self.ranks[ry]:",
            "            self.ranks[rx] += 1",
            "        self.isvalid[ry] &= self.isvalid[rx]",
            "        return \"unite\"",
            "",
            "    #xとyが同じグループかどうか",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "",
            "    #xと同じグループの要素",
            "    def members(self, x):",
            "        root = self.find(x)",
            "        return {i for i in range(self.n) if self.find(i) == root}",
            "",
            "    #グループの要素数",
            "    def size(self, x):",
            "        root = self.find(x)",
            "        return self.sizes[root]",
            "",
            "    #親の要素一覧",
            "    def roots(self):",
            "        return {i for i, x in enumerate(self.parents) if i == x}",
            "",
            "    #グループの個数",
            "    def group_count(self):",
            "        return len(self.roots())",
            "",
            "    #グループのメンバー一覧",
            "    def all_group_members(self):",
            "        return {r: self.members(r) for r in self.roots()}",
            "",
            "    #重みの差",
            "    def weight(self, x):",
            "        _ = self.find(x)",
            "        return self.weights[x]",
            "",
            "    #重み",
            "    def diff(self, x, y):",
            "        rx = self.find(x)",
            "        ry = self.find(y)",
            "        if rx != ry: return float('inf')",
            "        return self.weight(y) - self.weight(x)",
            "",
            "    def __str__(self):",
            "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "",
            "################",
            "",
            "n, m = map(int, input().split())",
            "uf = UnionFindWeighted(n)",
            "for _ in range(m):",
            "    a, b, w = map(int,input().split())",
            "    a -= 1; b -= 1",
            "    uf.unite(a, b, w)",
            ""
        ],
        "description": [
            "ユニオンファインド重み付き"
        ]
    },
    "行列演算": {
        "prefix": [
            "Lib_M_行列演算_matrix"
        ],
        "body": [
            "# ma: nxm",
            "# mb: mxk",
            "# returns nxk - matrix",
            "",
            "def prod(ma, mb, mod=1):",
            "    n_a = len(ma)",
            "    m_a = len(ma[0])",
            "    n_b = len(mb)",
            "    m_b = len(mb[0])",
            "    if n_a*m_a*n_b*m_b == 0: return 0",
            "    if m_a != n_b: return 0",
            "",
            "    ret = []",
            "    for i in range(n_a):",
            "        rw = []",
            "        for j in range(m_b):",
            "            c = 0",
            "            for k in range(m_a):",
            "                c += ma[i][k]*mb[k][j]",
            "                c %= mod",
            "            rw.append(c)",
            "        ret.append(rw)",
            "    return ret",
            "",
            "n, m, k = map(int, input().split())",
            "ma = [list(map(int, input().split())) for _ in range(n)]",
            "mb = [list(map(int, input().split())) for _ in range(m)]",
            "",
            "for r in prod(ma, mb):",
            "    print(*r)",
            "",
            "def powmat(ma, k, mod = 10**9+7):",
            "    n = len(ma)",
            "    ret = [[0]*n for _ in range(n)]",
            "    for i in range(n):",
            "        ret[i][i] = 1",
            "    for _ in range(k):",
            "        if k & 1:",
            "            ret = prod(ret, ma, mod)",
            "        ma = prod(ma, ma, mod)",
            "        k >>= 1",
            "        if k == 0: break",
            "    return ret",
            ""
        ],
        "description": []
    },
    "escripiton#": {
        "prefix": [],
        "body": [],
        "description": []
    },
    "転置行列": {
        "prefix": [
            "transpose_matrix"
        ],
        "body": [
            "def trans(A):",
            "    return [list(x) for x in zip(*A)]"
        ],
        "description": [
            "転置行列"
        ]
    },
    "行列90度回転": {
        "prefix": [
            "Lib_M_rotate_matrix"
        ],
        "body": [
            "def rotate(A, reverse = False):",
            "    if reverse:",
            "        return [list(x) for x in zip(*A)][::-1]",
            "    else:",
            "        return [list(x) for x in zip(*A[::-1])]"
        ],
        "description": [
            "行列90度回転"
        ]
    },
    "DFS非再帰": {
        "prefix": [
            "Lib_G_DFS_非再帰"
        ],
        "body": [
            "",
            "# 深さ優先探索",
            "# 隣接リスト",
            "# 行きかけ、帰りがけ処理",
            "",
            "",
            "def dfs(G:list, st:int, goal=None):",
            "    # 深さ優先探索（行きがけTrue、帰りがけFalse）",
            "    n = len(G)",
            "    stack = []",
            "    seen = [False] * n",
            "    level = [-1] * n    # 階層",
            "    parent = [-1] * n   # 親node",
            "    dp = [-1] * n       # dp 適宜設定",
            "    # スタートの設定",
            "    stack.append((False, st))",
            "    stack.append((True, st))",
            "    seen[st] = True",
            "    level[st] = 0",
            "",
            "    while stack:",
            "        fg, cur = stack.pop()",
            "        if fg:",
            "        #行き掛け",
            "            seen[cur] = True",
            "            for nxt in G[cur]:",
            "                if seen[nxt]: continue",
            "                # 行きがけ処理",
            "                parent[nxt] = cur",
            "                level[nxt] = cur + 1",
            "                stack.append((False, nxt))",
            "                stack.append((True, nxt))",
            "        ############",
            "        else:",
            "        #帰り掛け",
            "            isok = True",
            "            # dp[cur] = 1                     # ex.部分木のノード数",
            "            for child in G[cur]:",
            "                if parent[cur] == child: continue",
            "                if dp[child] == 1:",
            "                    isok = False",
            "                # dp[cur] += dp[child]          # ex.部分木のノード数",
            "            dp[cur] = int(isok)",
            "            if cur == goal: return dp",
            "        ############",
            "    return dp",
            "",
            "##########################################",
            "n = int(input())",
            "G = [[] for _ in range(n)]",
            "for _ in range(n-1):",
            "    a, b = map(int, input().split())",
            "    # a -= 1; b -= 1",
            "    G[a].append(b)",
            "    G[b].append(a)",
            "",
            "dp = dfs(G, 0)",
            "print(sum(dp))",
            ""
        ],
        "description": [
            "DFS非再帰"
        ]
    },
    "ダブリング": {
        "prefix": [
            "Lib_A_ダブリング_doubbling"
        ],
        "body": [
            "",
            "# https://atcoder.jp/contests/abc167/tasks/abc167_d",
            "",
            "maxdeg = 100",
            "n, k = map(int, input().split())",
            "A = list(map(lambda x: int(x)-1, input().split()))",
            "",
            "def f(i):",
            "    # 1回の遷移",
            "    return A[i]",
            "",
            "dp = [[0] * n for _ in range(maxdeg)]",
            "for i in range(n):",
            "    dp[0][i] = f(i)",
            "",
            "for t in range(1, maxdeg):",
            "    for i in range(n):",
            "        dp[t][i] = dp[t-1][dp[t-1][i]]",
            "",
            "def fk(i, k):",
            "    for d in range(maxdeg):",
            "        if k >> d & 1: i = dp[d][i]",
            "    return i",
            "",
            "print(fk(0, k)+1)",
            ""
        ],
        "description": []
    },
    "iscription#": {
        "prefix": [],
        "body": [],
        "description": []
    },
    "長方形探索": {
        "prefix": [
            "Lib_A_長方形探索_最大正方形_最大長方形"
        ],
        "body": [
            "#####################################",
            "# 最大正方形",
            "def max_square(h, w, G, block):",
            "    dp = [[0] * w for _ in range(h)]",
            "    mx = 0",
            "    for i in range(h):",
            "        if G[i][0] != block: dp[i][0] = 1; mx = 1",
            "    for j in range(w):",
            "        if G[0][j] != block: dp[0][j] = 1; mx = 1",
            "    for i in range(1, h):",
            "        for j in range(1, w):",
            "            if G[i][j] == block: continue",
            "            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1",
            "            mx = max(mx, dp[i][j])",
            "    return mx",
            "",
            "h, w = map(int, input().split())",
            "G = [list(map(int, input().split())) for _ in range(h)]",
            "print(max_square(h, w, G, 1)**2)",
            "",
            "",
            "#####################################",
            "# 最大長方形面積",
            "from collections import deque",
            "def max_rect(h, w, G, block):",
            "    height = [[0] * (w+1) for _ in range(h)]",
            "    for i in range(h):",
            "        for j in range(w):",
            "            if G[i][j] == block: continue",
            "            if i >= 1:",
            "                height[i][j] = height[i-1][j] + 1",
            "            else:",
            "                height[i][j] = 1",
            "",
            "    mx = 0",
            "    for i, hist in enumerate(height):",
            "        stack = deque([])",
            "        for j, h in enumerate(hist):",
            "            if not stack:",
            "                stack.append((j, h))",
            "            else:",
            "                if stack[-1][1] < h:",
            "                    stack.append((j, h))",
            "                elif stack[-1][1] > h:",
            "                    while stack and stack[-1][1] > h:",
            "                        prev =stack.pop()",
            "                        w2 = j - prev[0]",
            "                        h2 = prev[1]",
            "                        mx = max(mx, h2*w2)",
            "                    stack.append((prev[0], h))",
            "    return mx",
            "",
            "h, w = map(int, input().split())",
            "G = [list(map(int, input().split())) for _ in range(h)]",
            "print(max_rect(h, w, G, 1))",
            "",
            "#####################################",
            "# 左で自分より小さいものがあるindexを高速で計算",
            "def left_min_position(A, min_value=0):",
            "    ret = []",
            "    stack = []",
            "    stack.append([min_value, -1])",
            "    for i, ai in enumerate(A):",
            "        while stack[-1][0] >= ai:   #",
            "            stack.pop()",
            "        ret.append(stack[-1][1])",
            "        stack.append([ai, i])",
            "    return ret",
            "",
            "def right_min_position(A, min_value=0):",
            "# 左で自分より小さいものがあるindexを高速で計算",
            "    n = len(A)",
            "    return [n - pi - 1 for pi in reversed(left_min_position(A[::-1]))]",
            "",
            "",
            "n = int(input())",
            "A = list(map(int, input().split()))",
            "l = left_min_position(A)",
            "r = right_min_position(A)",
            "",
            "mx = 0",
            "for li, ri, ai in zip(l, r, A):",
            "    mx = max(mx, ai*(ri-li-1))",
            "print(mx)",
            ""
        ],
        "description": [
            "長方形探索"
        ]
    },
    "ダイクストラ法": {
        "prefix": [
            "Lib_SP_最短経路探索_dijkstra"
        ],
        "body": [
            "# ダイクストラ法",
            "# 重み付きグラフ関係により最短経路のリストを作る",
            "# 有向グラフで優先度付きキューで探索",
            "# https://atcoder.jp/contests/abc035/tasks/abc035_d",
            "# O((E+V)logV)",
            "from heapq import heapify, heappop, heappush",
            "class dijkstra:",
            "    def __init__(self, n, G):",
            "        self.INF = 10**9",
            "        self.n = n                  # ノード数",
            "        self.G = G                  # 有向グラフ",
            "        self.start = None           # 始点",
            "        self.G_used = [None] * n    # 最短経路木の親",
            "        self.dist = [self.INF] * n  # 始点からの距離",
            "        self.count = [0] * n        # 始点からの最短到達パス数",
            "",
            "    def build(self, start):",
            "        self.start = start",
            "        self.G_used = [None] * self.n",
            "        self.dist = [self.INF] * self.n",
            "        self.count = [0] * self.n",
            "        next_q = []",
            "        if type(start) is int:",
            "            start = [start]",
            "        for st in start:",
            "            self.dist[st] = 0",
            "            self.count[st] = 1",
            "            next_q.append((0, st))",
            "        heapify(next_q)",
            "        while next_q:",
            "            d, x = heappop(next_q)",
            "            if self.dist[x] < d: continue",
            "            for nx, d_nx_x in self.G[x]:",
            "                # 変則的な距離の場合はここを調整 ##",
            "                nd = self.dist[x] + d_nx_x",
            "                ############################",
            "                if self.dist[nx] < nd: continue",
            "                if self.dist[nx] == nd:",
            "                    self.count[nx] += self.count[x]",
            "                    continue",
            "                self.dist[nx] = nd",
            "                self.G_used[nx] = x",
            "                self.count[nx] = self.count[x]",
            "                heappush(next_q, (nd, nx))",
            "",
            "",
            "    def get_dist(self, goal):",
            "        # 各ノードへの最短距離",
            "        return self.dist[goal]",
            "",
            "",
            "    def get_count(self, goal):",
            "        # 各ノードへの最短距離のパス数",
            "        return self.count[goal]",
            "",
            "",
            "    def get_path(self, goal):",
            "        # 各ノードへの最短パス",
            "        path = []",
            "        node = goal",
            "        while node != None:",
            "            path.append(node)",
            "            node = self.G_used[node]",
            "        return path[::-1]",
            "",
            "##########################################",
            "",
            "n, m, t = map(int, input().split())",
            "G = [[] for _ in range(n)]",
            "G_R = [[] for _ in range(n)]    #行きと帰りを分けた（有向グラフ）場合",
            "#リストの作成",
            "for _ in range(m):",
            "    a, b, c = map(int, input().split())",
            "    a, b = a-1, b-1",
            "    G[a].append((b,c))",
            "    G[b].append((a,c))",
            "    G_R[b].append((a,c))        #行きと帰りを分けた（有向グラフ）場合",
            "",
            "dij = dijkstra(n, G)  #クラスのインスタンス化",
            "dijR = dijkstra(n, G_R)",
            "dij.build(0)",
            "dijR.build(0)",
            "",
            "print(dij.get_dist(n-1))",
            ""
        ],
        "description": [
            "ダイクストラ法",
            "辺の重みが小さいものから、決めていく",
            ""
        ]
    },
    "二次元点クエリ": {
        "prefix": [
            "compress_zaatsu",
            "Lib_A_二次元点クエリ"
        ],
        "body": [
            "from bisect import bisect_left, bisect_right",
            "",
            "class RangeSearchQuery:",
            "    \"\"\"",
            "    二次元点のリストで葉にを指定してその要素番号を出力する",
            "    \"\"\"",
            "    def __init__(self, points):",
            "        self.n = len(points)",
            "        self.p_id = {v: i for i, v in enumerate(points)}  #座圧",
            "        data = dict()",
            "        for x, y in points:",
            "            if x not in data: data[x] = []",
            "            data[x].append(y)",
            "        self.d_x = sorted(list(data.keys()))",
            "        for dv in data.values(): dv.sort()",
            "        self.data = data",
            "",
            "    def query(self, sx, tx, sy, ty):",
            "        ans = []",
            "        left = bisect_left(self.d_x, sx)",
            "        right = bisect_right(self.d_x, tx)",
            "        for kx in self.d_x[left:right]:",
            "            y_left = bisect_left(self.data[kx], sy)",
            "            y_right = bisect_right(self.data[kx], ty)",
            "            for ky in self.data[kx][y_left: y_right]:",
            "                ans.append(self.p_id[(kx, ky)])",
            "        return ans",
            "",
            "n = int(input())",
            "A = [tuple(map(int, input().split())) for _ in range(n)]",
            "RSQ = RangeSearchQuery(A)",
            "",
            "q = int(input())",
            "for _ in range(q):",
            "    que = tuple(map(int, input().split()))",
            "    ans = RSQ.query(*que)",
            "    for ans_i in sorted(ans):",
            "        print(ans_i)",
            "    print()",
            "",
            ""
        ],
        "description": [
            "二次元点クエリ"
        ]
    },
    "Lib_AL_図形_三角形_角度": {
        "prefix": [
            "Lib_AL_図形_三角形_角度"
        ],
        "body": [
            "",
            "########################",
            "import math",
            "",
            "# 度→radian",
            "math.radians(180)",
            "# radian→度",
            "math.degrees(3.1415)",
            "########################",
            "# 三角形",
            "########################",
            "# 余弦定理",
            "# cosR = (a**2 + b**2 - c**2) / 2ab",
            "# c**2 = a**2 + b**2 - 2*a*b*cosR",
            "# 対辺",
            "def C(a, b, R):",
            "    \"\"\"",
            "    a, b: 二辺の長さ",
            "    R: 角度",
            "    Returns",
            "    対辺の長さ",
            "    \"\"\"",
            "    R = math.radians(R)  # Rが度数の場合",
            "    return (a ** 2 + b** 2 - 2 * a * b * math.cos(R))**0.5",
            "",
            "def S(a, b, R):",
            "    \"\"\"",
            "    a, b: 二辺の長さ",
            "    R: 角度",
            "    Returns",
            "    面積",
            "    \"\"\"",
            "    R = math.radians(R)  # Rが度数の場合",
            "    return abs(0.5 * a * b * math.sin(R))",
            ""
        ],
        "description": [
            "図形のライブラリ"
        ]
    },
    "オイラーツアー eulartour 非再帰版": {
        "prefix": [
            "Lib_GT_オイラーツアー_非再帰版_eulartour"
        ],
        "body": [
            "# オイラーツアー eulartour 非再帰版",
            "# 木をDFSしたときの順番で頂点を記録する手法",
            "# pre-order : 頂点に到着したら記録",
            "# post-order : 頂点から離れるときに記録",
            "# - 根付き木のある頂点からの部分木に対するクエリを処理",
            "# - ある頂点がある頂点の部分木に含まれるかを高速に判定する",
            "# - 上手くオイラーツアーを作るとパスのコストの総和が取れる",
            "# n = 5",
            "# 0",
            "# |",
            "# 1",
            "# |",
            "# 2",
            "# |  \\",
            "# 4  3",
            "#",
            "# etnodes = [0,1,2,4,2,3,2,1,0]",
            "# etdepth = [0,1,2,3,2,3,2,1,0]",
            "# etdetL = [0,1,2,5,3]",
            "# etdetR = [9,8,7,6,4]",
            "",
            "",
            "class EulerTour():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.edges = [[] for _ in range(n)]",
            "        self.root = None    # 根",
            "        self.etnodes = []    # i番目の頂点番号",
            "        self.etedges = []    # i番目の辺の番号",
            "        self.etL = [0] * n  # in",
            "        self.etR = [0] * n  # out",
            "        self.depthbynodes = [0] * n",
            "        self.etdepth = []       # i番目の辺の",
            "",
            "",
            "    def add_edge(self, u, v):",
            "        self.edges[u].append(v)",
            "        self.edges[v].append(u)",
            "",
            "",
            "    def set_euler_tour(self, root):",
            "        self.root = root        # 根を設定して",
            "        pa = [0] * self.n",
            "        stack = [~root, root]",
            "        ct = -1",
            "        de = -1",
            "        while stack:",
            "            v = stack.pop()",
            "            ct += 1",
            "            self.etedges.append(v)",
            "            if v >= 0:",
            "                de += 1",
            "                self.etnodes.append(v)",
            "                self.etdepth.append(de)",
            "                self.depthbynodes[v] = de",
            "                self.etL[v] = ct",
            "                p = pa[v]",
            "                for w in self.edges[v][::-1]:",
            "                    if w == p: continue",
            "                    pa[w] = v",
            "                    stack.append(~w)",
            "                    stack.append(w)",
            "            else:",
            "                de -= 1",
            "                self.etdepth.append(de)",
            "                self.etnodes.append(pa[~v])",
            "                self.etR[~v] = ct",
            "",
            "#########################################",
            "def int1(x): return int(x)-1",
            "n = int(input())",
            "G = [[] for _ in range(n)]",
            "for _ in range(n-1):",
            "    a, b = map(int1, input().split())",
            "    G[a].append(b)",
            "    G[b].append(a)",
            "",
            "T = EulerTour(n, G)",
            "",
            "T.set_euler_tour(0)",
            "print(T.etnodes)",
            "print(T.etedges)",
            "print(T.etdepth)",
            "",
            "print(T.etL)",
            "print(T.etR)",
            "print(T.depthbynodes)",
            ""
        ],
        "description": [
            "オイラーツアー eulartour 非再帰版"
        ]
    },
    "Wavelet Matrix": {
        "prefix": [
            "Lib_D_WaveletMatrix"
        ],
        "body": [
            "",
            "class WaveletMatrix:",
            "    \"\"\"",
            "    https://judge.yosupo.jp/problem/range_kth_smallest",
            "    https://scrapbox.io/koki/Wavelet_Matrix",
            "    長さnの数列 a",
            "    access(k): k番目の要素の値",
            "    select(v, k): k番目のvのインデックス",
            "    rank(l, r, v): 区間 [l,r) に含まれる v の個数",
            "    freq(l, r, s, t): 区間 [l,r) に含まれる要素のうち,値が[s, t) である要素の個数",
            "    quantile(l, r, k):区間[l,r)に含まれる要素のうち,値がk番目(0-ind>k+1番目)の値",
            "    kth_smallest(l, r, k): 区間[l,r) に含まれる要素のうち k 番目(0-indexed) に小さいものを返す.",
            "    kth_largest(l, r, k): 区間 [l,r) に含まれる要素のうち k 番目 (0-indexed) に大きいものを返す.",
            "    prev_value(l, r, value): 区間[l, r) に含まれる要素のうち valueより小さいもの",
            "    next_value(l, r, value): 区間[l, r) に含まれる要素のうち value以上の値(valueのこともあり得る)",
            "    \"\"\"",
            "    class BitVector:",
            "        def __init__(self, a:list):",
            "            self.n = len(a)",
            "            ra = [0]",
            "            for ai in a:",
            "                ra.append(ra[-1] + ai)",
            "            self.ra = ra    # 累積和",
            "        def rank0(self, r:int) -> int:",
            "            return r - self.rank1(r)",
            "        def rank1(self, r:int) -> int:",
            "            return self.ra[r]",
            "",
            "        def _bisect(l, r, isok):",
            "            while r - l > 1:",
            "                m = (l + r) >> 1",
            "                if isok(m): l = m",
            "                else: r = m",
            "            return l",
            "",
            "        def select0(self, k):",
            "            l, r = 0, self.n + 1",
            "            if not k < self.rank0(r-1): return -1",
            "            return self._bisect(l, r, lambda m: m-self.ra[m] <= k)",
            "",
            "        def select1(self, k):",
            "            l, r = 0, self.n + 1",
            "            if not k < self.ra[r-1]: return -1",
            "            return self._bisect(l, r, lambda m: self.ra[m] <= k)",
            "",
            "    def __init__(self, a, s=30):",
            "        self.n = len(a)",
            "        self.s = s # bit length",
            "        self.a = a",
            "        b = a[:]",
            "        self.x = []",
            "        for i in range(self.s)[::-1]:",
            "            l, r, t = [], [], []",
            "            for bi in b:",
            "                if bi >> i & 1:",
            "                    t.append(1); r.append(bi)",
            "                else:",
            "                    t.append(0); l.append(bi)",
            "            vb = self.BitVector(t)",
            "            self.x.append((vb.rank0(self.n), vb))",
            "            b = l + r",
            "        self.x = self.x[::-1]",
            "",
            "    def access(self, k):",
            "        \"\"\"",
            "        a[k]の値を取得:Number of value A[k]",
            "        \"\"\"",
            "        return self.a[k]",
            "",
            "    def rank(self, l, r, value):",
            "        \"\"\"",
            "        A[l,r)のうちvalueの個数:Number of value's in A[l,r)",
            "        \"\"\"",
            "        if l >= r: return 0",
            "        for i in range(self.s)[::-1]:",
            "            z, vb = self.x[i]",
            "            if value >> i & 1:",
            "                l, r = z + vb.rank1(l), z + vb.rank1(r)",
            "            else:",
            "                l, r = vb.rank0(l), vb.rank0(r)",
            "        return r - l",
            "",
            "    def select(self, value, k):",
            "        \"\"\"",
            "        valueのk番目(0index>k+1個目)のインデックス: Index of k'th value in a (zero indexed)",
            "        valueがk以下の場合は-1を返す",
            "        \"\"\"",
            "        if self.rank(0, self.n, value) <= k: return -1",
            "        ind = 0",
            "        for i in range(self.s)[::-1]:",
            "            z, vb = self.x[i]",
            "            if value >> i & 1:",
            "                ind = z + vb.rank1(ind)",
            "            else:",
            "                ind = vb.rank0(ind)",
            "        ind += k",
            "        for i in range(self.s):",
            "            z, vb = self.x[i]",
            "            if ind < z:",
            "                ind = vb.select0(ind)",
            "            else:",
            "                ind = vb.select1(ind - z)",
            "        return ind",
            "",
            "    def freq(self, l, r, s, t):",
            "        \"\"\"",
            "        A[l,r)にある要素のうち、値が[s, t)の範囲にあるものの個数",
            "        Number of elements in A[l,r) whose value is in [s, t)",
            "        \"\"\"",
            "        if s >= t: return 0",
            "        return self.freq_to(l, r, t) - self.freq_to(l, r, t)",
            "",
            "    def freq_to(self, l, r, value):",
            "        \"\"\"",
            "        A[l,r)にある要素のうち、値が[0, value)の範囲にあるものの個数",
            "        Number of elements in A[l,r) whose value is in [0, u)",
            "        \"\"\"",
            "        if not value: return 0",
            "        if l >= r: return 0",
            "        ret = 0",
            "        for i in range(self.s)[::-1]:",
            "            z, vb = self.x[i]",
            "            if value >> i & 1:",
            "                ret += vb.rank0(r) - vb.rank0(l)",
            "                l, r = z + vb.rank1(l), z + vb.rank1(r)",
            "            else:",
            "                l, r = vb.rank0(l), vb.rank0(r)",
            "        return ret",
            "",
            "    def quantile(self, l, r, k):",
            "        \"\"\"",
            "        A[l,r)にある要素のうち、値がk番目(0-ind>k+1番目)の値",
            "        k'th smallest in [l, r)",
            "        \"\"\"",
            "        if k >= r - l: return -1",
            "        ret = 0",
            "        for i in range(self.s)[::-1]:",
            "            z, vb = self.x[i]",
            "            zeros = vb.rank0(r) - vb.rank0(l)",
            "            if zeros > k:",
            "                l, r = vb.rank0(l), vb.rank0(r)",
            "            else:",
            "                k -= zeros",
            "                ret |= 1 << i",
            "                l, r = z + vb.rank1(l), z + vb.rank1(r)",
            "        return ret",
            "",
            "    def kth_smallest(self, l, r, k):",
            "        return self.quantile(l, r, k)",
            "",
            "    def kth_largest(self, l, r, k):",
            "        return self.quantile(l, r, self.n-1-k)",
            "",
            "    def prev_value(self, l, r, value):",
            "        cnt = self.freq_to(l, r, value)",
            "        if cnt == 0: return -1",
            "        return self.kth_smallest(l, r, cnt - 1)",
            "",
            "    def next_value(self, l, r, value):",
            "        cnt = self.freq_to(l, r, value)",
            "        if cnt == r-l: return -1",
            "        return self.kth_smallest(l, r, cnt)",
            "",
            "",
            "#######################################",
            "from bisect import bisect_left",
            "class Compress:",
            "    \"\"\"一次元座標圧縮",
            "",
            "    Parameters",
            "    ----------",
            "    points : list",
            "    値のリスト [100,300,50,900,200]",
            "",
            "    Returns",
            "    -------",
            "    pos : {50: 0, 100: 1, 200: 2, 300: 3, 900: 4}",
            "    vals : {0: 50, 1: 100, 2: 200, 3: 300, 4: 900}",
            "    list : [1, 3, 0, 4, 2]",
            "    \"\"\"",
            "    def __init__(self, points, spacing=False, reverse=False):",
            "        pos, vals, sx = {}, {}, set(points)",
            "        if spacing: #スペースを作る場合",
            "            for p in points: sx.add(p+1)",
            "            sx.add(-1)",
            "            sx.add(10**10)",
            "",
            "        for i, xi in enumerate(sorted(set(sx), reverse=reverse)):",
            "            pos[xi], vals[i] = i, xi",
            "        self.pos, self.vals = pos, vals",
            "        self.original_list, self.list = points, [pos[xi] for xi in points]",
            "        self.valuesequence = sorted(self.pos.keys())",
            "",
            "    def __contains__(self, original_value):",
            "        return original_value in self.pos.keys()",
            "",
            "    def index(self, original_value):",
            "        # 元value -> 新index",
            "        # if original_value in self.pos: return self.pos[original_value]",
            "        # return None",
            "        return bisect_left(self.valuesequence, original_value)",
            "",
            "    def value(self, index):",
            "        # 新index -> 元value",
            "        if index in self.vals: return self.vals(index)",
            "        return None",
            "",
            "##########################################################################3",
            "",
            "class WaveletMatrixCompressed(WaveletMatrix):",
            "    def __init__(self, a, s=30):",
            "        self.cmp = Compress(a)",
            "        super().__init__(self.cmp.list, s)",
            "",
            "    def access(self, k):",
            "        cmppos = super().access(k)",
            "        return self.cmp.vals[cmppos]",
            "",
            "    def rank(self, l, r, value):",
            "        cmpidx = self.cmp.index(value)",
            "        return super().rank(l, r, cmpidx)",
            "",
            "    def select(self, value, k):",
            "        cmpidx = self.cmp.index(value)",
            "        return super().select(cmpidx, k)",
            "",
            "    def freq(self, l, r, s, t):",
            "        cmpsidx = self.cmp.index(s)",
            "        cmptidx = self.cmp.index(t)",
            "        if s >= t: return 0",
            "        return self.freq_to(l, r, t) - self.freq_to(l, r, t)",
            "",
            "    def freq_to(self, l, r, value):",
            "        cmpidx = self.cmp.index(value)",
            "        if not cmpidx: return 0",
            "        if l >= r: return 0",
            "        ret = 0",
            "        for i in range(self.s)[::-1]:",
            "            z, vb = self.x[i]",
            "            if cmpidx >> i & 1:",
            "                ret += vb.rank0(r) - vb.rank0(l)",
            "                l, r = z + vb.rank1(l), z + vb.rank1(r)",
            "            else:",
            "                l, r = vb.rank0(l), vb.rank0(r)",
            "        return ret",
            "",
            "    def quantile(self, l, r, k):",
            "        if k >= r - l: return -1",
            "        ret = 0",
            "        for i in range(self.s)[::-1]:",
            "            z, vb = self.x[i]",
            "            zeros = vb.rank0(r) - vb.rank0(l)",
            "            if zeros > k:",
            "                l, r = vb.rank0(l), vb.rank0(r)",
            "            else:",
            "                k -= zeros",
            "                ret |= 1 << i",
            "                l, r = z + vb.rank1(l), z + vb.rank1(r)",
            "        return self.cmp.vals[ret]",
            "",
            "    def kth_smallest(self, l, r, k):",
            "        return self.quantile(l, r, k)",
            "",
            "    def kth_largest(self, l, r, k):",
            "        return self.quantile(l, r, self.n-1-k)",
            "",
            "    def prev_value(self, l, r, value):",
            "        cnt = self.freq_to(l, r, value)",
            "        if cnt == 0: return -1",
            "        return self.kth_smallest(l, r, cnt - 1)",
            "",
            "    def next_value(self, l, r, value):",
            "        cnt = self.freq_to(l, r, value)",
            "        if cnt == r-l: return -1",
            "        return self.kth_smallest(l, r, cnt)",
            "",
            "",
            "import sys",
            "input = lambda: sys.stdin.readline().rstrip()",
            "",
            "# n, q = map(int, input().split())",
            "# a = list(map(int, input().split()))",
            "# wm = WaveletMatrix(a)",
            "# wm = WaveletMatrixCompressed(a)",
            "# for _ in range(q):",
            "#     l, r, k = map(int, input().split())",
            "#     print(wm.quantile(l, r, k))",
            "",
            "n = int(input())",
            "a = list(map(int, input().split()))",
            "q = int(input())",
            "wm = WaveletMatrixCompressed(a)",
            "for _ in range(q):",
            "    ret = 10**10",
            "    l, r, d = map(int, input().split())",
            "    r += 1",
            "    v = wm.prev_value(l, r, d)",
            "    if v != -1:",
            "        ret = min(ret, d-v)",
            "    v = wm.next_value(l, r, d)",
            "    if v != -1:",
            "        ret = min(ret, v-d)",
            "    print(ret)",
            ""
        ],
        "description": [
            "WaveletMatrix: 数列のある範囲での値の頻度やインデックスを求める"
        ]
    },
    "translate": {
        "prefix": [
            "translate",
            "replace"
        ],
        "body": [
            "s = '54IZSB'",
            "ts = s.translate(str.maketrans(\"BSI\",\"123\"))",
            "print(ts)",
            "# 543Z21"
        ],
        "description": [
            "複数の文字列を変換"
        ]
    },
    "d進数": {
        "prefix": [
            "n進数",
            "d進数"
        ],
        "body": [
            "##############################",
            "# nをd進数表記",
            "# d進数表記を10進数表記に",
            "##############################",
            "",
            "n = 32",
            "",
            "print(format(n, 'b'))  # ２進数",
            "print(format(n, 'o'))  # ８進数",
            "print(format(n, 'x'))  # 16進数",
            "",
            "print(bin(n))  # ２進数",
            "print(oct(n))  # ８進数",
            "print(hex(n))  # 16進数",
            "",
            "# 任意のd進数",
            "def base_repr(n:int, d:int) -> str:",
            "    ret = ''",
            "    while n != 0:",
            "        n, r = divmod(n, d)",
            "        ret += str(r)",
            "    return ret[::-1]",
            "",
            "print(base_repr(n, 2))",
            "print(base_repr(n, 30))",
            "",
            "",
            "##############################",
            "# d進数表記を10進数表記に",
            "##############################",
            "s = '12'",
            "d = 9",
            "print(int(s, base=d))",
            "",
            "# 関数版",
            "def myint(s:str, d:int) -> int:",
            "    ret = 0",
            "    dig = 1",
            "    for xi in s[::-1]:",
            "        ret += int(xi)*dig",
            "        dig *= d",
            "    return ret",
            "",
            "print(myint(s, 9))",
            ""
        ],
        "description": [
            "nをd進数表記"
        ]
    },
    "digital digit": {
        "prefix": [
            "digital digit"
        ],
        "body": [
            "led_statuses = [\"1110111\", \"0100100\", \"1011101\", \"1101101\", \"0101110\",",
            "    \"1101011\", \"1111011\", \"0100111\", \"1111111\", \"1101111\"]",
            "led_digit = [int(status, base=2) for status in led_statuses]"
        ],
        "description": [
            " -",
            "| |",
            " -",
            "| |",
            " -",
            ""
        ]
    },
    "Sorted Multi Set": {
        "prefix": [
            "Lib_D_sorted_multi_set"
        ],
        "body": [
            "# https://github.com/tatyam-prime/SortedSet/blob/main/SortedMultiset.py",
            "import math",
            "from bisect import bisect_left, bisect_right, insort",
            "from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
            "T = TypeVar('T')",
            "",
            "class SortedMultiset(Generic[T]):",
            "    BUCKET_RATIO = 50",
            "    REBUILD_RATIO = 170",
            "",
            "    def _build(self, a=None) -> None:",
            "        \"Evenly divide `a` into buckets.\"",
            "        if a is None: a = list(self)",
            "        size = self.size = len(a)",
            "        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
            "        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
            "",
            "    def __init__(self, a: Iterable[T] = []) -> None:",
            "        \"Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)\"",
            "        a = list(a)",
            "        if not all(a[i] <= a[i + 1] for i in range(len(a) - 1)):",
            "            a = sorted(a)",
            "        self._build(a)",
            "",
            "    def __iter__(self) -> Iterator[T]:",
            "        for i in self.a:",
            "            for j in i: yield j",
            "",
            "    def __reversed__(self) -> Iterator[T]:",
            "        for i in reversed(self.a):",
            "            for j in reversed(i): yield j",
            "",
            "    def __len__(self) -> int:",
            "        return self.size",
            "",
            "    def __repr__(self) -> str:",
            "        return \"SortedMultiset\" + str(self.a)",
            "",
            "    def __str__(self) -> str:",
            "        s = str(list(self))",
            "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
            "",
            "    def _find_bucket(self, x: T) -> List[T]:",
            "        \"Find the bucket which should contain x. self must not be empty.\"",
            "        for a in self.a:",
            "            if x <= a[-1]: return a",
            "        return a",
            "",
            "    def __contains__(self, x: T) -> bool:",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        return i != len(a) and a[i] == x",
            "",
            "    def count(self, x: T) -> int:",
            "        \"Count the number of x.\"",
            "        return self.index_right(x) - self.index(x)",
            "",
            "    def add(self, x: T) -> None:",
            "        \"Add an element. / O(√N)\"",
            "        if self.size == 0:",
            "            self.a = [[x]]",
            "            self.size = 1",
            "            return",
            "        a = self._find_bucket(x)",
            "        insort(a, x)",
            "        self.size += 1",
            "        if len(a) > len(self.a) * self.REBUILD_RATIO:",
            "            self._build()",
            "",
            "    def discard(self, x: T) -> bool:",
            "        \"Remove an element and return True if removed. / O(√N)\"",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i == len(a) or a[i] != x: return False",
            "        a.pop(i)",
            "        self.size -= 1",
            "        if len(a) == 0: self._build()",
            "        return True",
            "",
            "    def lt(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element < x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] < x:",
            "                return a[bisect_left(a, x) - 1]",
            "",
            "    def le(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element <= x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] <= x:",
            "                return a[bisect_right(a, x) - 1]",
            "",
            "    def gt(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element > x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return a[bisect_right(a, x)]",
            "",
            "    def ge(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element >= x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return a[bisect_left(a, x)]",
            "",
            "    def __getitem__(self, x: int) -> T:",
            "        \"Return the x-th element, or IndexError if it doesn't exist.\"",
            "        \"sm[-1]も可能\"",
            "        if x < 0: x += self.size",
            "        if x < 0: raise IndexError",
            "        for a in self.a:",
            "            if x < len(a): return a[x]",
            "            x -= len(a)",
            "        raise IndexError",
            "",
            "    def index(self, x: T) -> int:",
            "        \"Count the number of elements < x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return ans + bisect_left(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "    def index_right(self, x: T) -> int:",
            "        \"Count the number of elements <= x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return ans + bisect_right(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "###############################################",
            "",
            "sm = SortedMultiset()",
            "",
            "q = int(input())",
            "",
            "for _ in range(q):",
            "    query = tuple(map(int, input().split()))",
            "",
            "    if query[0] == 2:",
            "        x, k = query[1:]",
            "        id = sm.index_right(x) - k",
            "        if id < 0:",
            "            print(-1)",
            "        else:",
            "            print(sm[id])",
            "    elif query[0] == 3:",
            "        x, k = query[1:]",
            "        id = sm.index(x) + k - 1",
            "        if id >= len(sm):",
            "            print(-1)",
            "        else:",
            "            print(sm[id])",
            "    else:",
            "        sm.add(query[1])",
            "",
            ""
        ],
        "description": []
    },
    "Lib_G_枝刈り取る": {
        "prefix": [
            "Lib_G_cycle"
        ],
        "body": [
            "",
            "def cycle(n, G):",
            "    degree = [0] * n",
            "    for gi in G:",
            "        for i in gi:",
            "            degree[i] += 1",
            "",
            "    leaves = [i for i in range(n) if degree[i] == 1]",
            "    oncycle = set(range(n))",
            "    while leaves:",
            "        x = leaves.pop()",
            "        oncycle.remove(x)",
            "        for y in G[x]:",
            "            degree[y] -= 1",
            "            if degree[y] == 1:",
            "                leaves.append(y)",
            "    return oncycle",
            "",
            "",
            "n, m = map(int, input().split())",
            "G = [[] for _ in range(n)]",
            "for _ in range(m):",
            "    a, b = map(int, input().split())",
            "    G[a].append(b)",
            "    G[b].append(a)",
            "",
            "print(cycle(n, G))",
            ""
        ],
        "description": [
            "グラフの葉から枝を刈り取って、ループ部分のみ抽出する"
        ]
    },
    "座標圧縮": {
        "prefix": [
            "Lib_A_座標圧縮_compress_zaatsu"
        ],
        "body": [
            "from bisect import bisect_left",
            "class Compress:",
            "    \"\"\"一次元座標圧縮",
            "",
            "    Parameters",
            "    ----------",
            "    points : list",
            "    値のリスト [100,300,50,900,200]",
            "",
            "    Returns",
            "    -------",
            "    pos : {50: 0, 100: 1, 200: 2, 300: 3, 900: 4}",
            "    vals : {0: 50, 1: 100, 2: 200, 3: 300, 4: 900}",
            "    list : [1, 3, 0, 4, 2]",
            "    \"\"\"",
            "    def __init__(self, points, spacing=False, reverse=False):",
            "        pos, vals, sx = {}, {}, set(points)",
            "        if spacing: #スペースを作る場合",
            "            for p in points: sx.add(p+1)",
            "            sx.add(-1)",
            "            sx.add(10**10)",
            "",
            "        for i, xi in enumerate(sorted(set(sx), reverse=reverse)):",
            "            pos[xi], vals[i] = i, xi",
            "        self.pos, self.vals = pos, vals",
            "        self.original_list, self.list = points, [pos[xi] for xi in points]",
            "        self.valuesequence = sorted(self.pos.keys())",
            "",
            "    def __contains__(self, original_value):",
            "        return original_value in self.pos.keys()",
            "",
            "    def index(self, original_value):",
            "        # 元value -> 新index",
            "        # if original_value in self.pos: return self.pos[original_value]",
            "        # return None",
            "        return bisect_left(self.valuesequence, original_value)",
            "",
            "    def value(self, index):",
            "        # 新index -> 元value",
            "        if index in self.vals: return self.vals(index)",
            "        return None",
            "",
            "# c = Compress([100,300,50,900,200], spacing=True)",
            "",
            "##########################################################################3",
            "",
            "class Compress2d:",
            "    \"\"\"二次元座標圧縮",
            "    \"\"\"",
            "    def __init__(self, points, spacing=False):",
            "        sx = [point[0] for point in points]",
            "        sy = [point[1] for point in points]",
            "        self.xc = Compress(sx, spacing=spacing)",
            "        self.yc = Compress(sy, spacing=spacing)",
            "        self.original_list = points",
            "        self.list = list(zip(self.xc.list, self.yc.list))",
            "        self.n = len(self.xc.valuesequence)",
            "        self.m = len(self.yc.valuesequence)",
            "        if len(points[0]) == 3:",
            "            self.pointvalues = {self.index((x, y)): v for x, y, v in points}",
            "        else:",
            "            self.pointvalues = {self.index((x, y)): 0 for x, y in points}",
            "",
            "    def index(self, original_point):",
            "        x, y = original_point",
            "        return self.xc.index(x), self.yc.index(y)",
            "",
            "    def value(self, i, j):",
            "        return tuple(self.xc.value(i), self.yc.value(j))",
            "",
            "    def xvalue(self, i):",
            "        return self.xc.value(i)",
            "",
            "    def yvalue(self, i):",
            "        return self.yc.value(i)",
            "",
            "# c = Compress2d([(1,1),(2,4),(5,3)], spacing=True)",
            "# print(c.xc.valuesequence)",
            "# print(c.yc.valuesequence)",
            "# print(c.list)"
        ],
        "description": [
            "座標圧縮"
        ]
    },
    "レーベンシュタイン距離": {
        "prefix": [
            "Lib_A_レーベンシュタイン距離_Levenshtein_distance#"
        ],
        "body": [
            "#####################################",
            "# レーベンシュタイン距離",
            "# 文字列の近似度",
            "# 文字削除・挿入・変更により文字列を一致させる",
            "# 最小の手順回数",
            "#####################################",
            "# https://algo-method.com/tasks/315",
            "# https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/1/DPL_1_E",
            "",
            "class Levenshtein:",
            "    def __init__(self, S, T) -> None:",
            "        self.Type = type(S)",
            "        if self.Type == str:",
            "            S = list(S)",
            "            T = list(T)",
            "        self.S = S",
            "        self.T = T",
            "        self.ls = len(S)",
            "        self.lt = len(T)",
            "        self.dp = [[10**10]*(self.lt+1) for _ in range(self.ls+1)]",
            "        dp = self.dp",
            "        for i in range(self.ls):",
            "            dp[i][0] = i",
            "        for j in range(self.lt):",
            "            dp[0][j] = j",
            "        for i in range(self.ls):",
            "            for j in range(self.lt):",
            "                if S[i] == T[j]:",
            "                    dp[i+1][j+1] = min(dp[i][j]  , dp[i+1][j]+1, dp[i][j+1]+1)",
            "                else:",
            "                    dp[i+1][j+1] = min(dp[i][j]+1, dp[i+1][j]+1, dp[i][j+1]+1)",
            "        self.length = self.dp[self.ls][self.lt]",
            "",
            "",
            "    def restore(self):",
            "        # 復元",
            "        ret = []",
            "        i, j = self.ls, self.lt",
            "        dp = self.dp",
            "        while i and j:",
            "            # (i-1, j) -> (i, j) と更新されていた場合",
            "            if dp[i][j] == dp[i-1][j]:",
            "                i-=1   # DP の遷移を遡る",
            "            # (i, j-1) -> (i, j) と更新されていた場合",
            "            elif dp[i][j] == dp[i][j-1]:",
            "                j-=1   # DP の遷移を遡る",
            "            # (i-1, j-1) -> (i, j) と更新されていた場合",
            "            else:",
            "                ret.append(self.S[i-1])",
            "                # このとき s[i-1] == t[j-1] なので、t[j-1] + res でも OK",
            "                i-=1",
            "                j-=1   # DP の遷移を遡る",
            "        ret = ret[::-1]",
            "        if self.Type == str: ret = ''.join(ret)",
            "        return ret",
            "",
            "",
            "#####################",
            "",
            "s = input()",
            "t = input()",
            "",
            "ldiff = Levenshtein(s, t)",
            "print(ldiff.length)",
            ""
        ],
        "description": [
            "Lib_レーベンシュタイン距離"
        ]
    },
    "LCS最長共通部分列": {
        "prefix": [
            "Lib_LCS最長共通部分列#"
        ],
        "body": [
            "#####################################",
            "# LCS(longest common sequence)",
            "# 部分列で最長の共通のもの",
            "#####################################",
            "# https://atcoder.jp/contests/dp/tasks/dp_f",
            "",
            "# dp[i+1][j+1]:= s の i 文字目までと t の j 文字目まででの LCS の長さ",
            "class LCS:",
            "    def __init__(self, S, T) -> None:",
            "        self.Type = type(S)",
            "        if self.Type == str:",
            "            S = list(S)",
            "            T = list(T)",
            "        self.S = S",
            "        self.T = T",
            "        self.ls = n = len(S)",
            "        self.lt = m = len(T)",
            "        self.dp = [[0]*(m+1) for _ in range(n+1)]",
            "        dp = self.dp",
            "        for i, si in enumerate(S):",
            "            for j, tj in enumerate(T):",
            "                if si == tj:",
            "                    dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + 1)",
            "                else:",
            "                    dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1])",
            "",
            "    def __len__(self):",
            "        # LCSの長さ",
            "        return self.dp[self.ls][self.lt]",
            "",
            "    def __str__(self):",
            "        # 復元",
            "        ret = []",
            "        i, j = self.ls, self.lt",
            "        dp = self.dp",
            "        while i and j:",
            "            # (i-1, j) -> (i, j) と更新されていた場合",
            "            if dp[i][j] == dp[i-1][j]:",
            "                i -= 1   # DP の遷移を遡る",
            "            # (i, j-1) -> (i, j) と更新されていた場合",
            "            elif dp[i][j] == dp[i][j-1]:",
            "                j -= 1   # DP の遷移を遡る",
            "            # (i-1, j-1) -> (i, j) と更新されていた場合",
            "            else:",
            "                ret.append(self.S[i-1])",
            "                # このとき s[i-1] == t[j-1] なので、t[j-1] + res でも OK",
            "                i -= 1; j -= 1   # DP の遷移を遡る",
            "        ret = ret[::-1]",
            "        if self.Type == str: ret = ''.join(ret)",
            "        return ''.join(ret)",
            "",
            "",
            "#####################",
            "#s = list(input())",
            "#t = list(input())",
            "s = '948640'",
            "t = '540820'",
            "lcs = LCS(s, t)",
            "print(len(lcs))",
            "print(lcs)",
            ""
        ],
        "description": [
            "Lib_LCS最長共通部分列"
        ]
    },
    "Sorted Set": {
        "prefix": [
            "Lib_D_sorted_set"
        ],
        "body": [
            "# https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py",
            "import math",
            "from bisect import bisect_left, bisect_right",
            "from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
            "T = TypeVar('T')",
            "",
            "class SortedSet(Generic[T]):",
            "    BUCKET_RATIO = 50",
            "    REBUILD_RATIO = 170",
            "",
            "    def _build(self, a=None) -> None:",
            "        \"Evenly divide `a` into buckets.\"",
            "        if a is None: a = list(self)",
            "        size = self.size = len(a)",
            "        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
            "        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
            "",
            "    def __init__(self, a: Iterable[T] = []) -> None:",
            "        \"Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)\"",
            "        a = list(a)",
            "        if not all(a[i] < a[i + 1] for i in range(len(a) - 1)):",
            "            a = sorted(set(a))",
            "        self._build(a)",
            "",
            "    def __iter__(self) -> Iterator[T]:",
            "        for i in self.a:",
            "            for j in i: yield j",
            "",
            "    def __reversed__(self) -> Iterator[T]:",
            "        for i in reversed(self.a):",
            "            for j in reversed(i): yield j",
            "",
            "    def __len__(self) -> int:",
            "        return self.size",
            "",
            "    def __repr__(self) -> str:",
            "        return \"SortedSet\" + str(self.a)",
            "",
            "    def __str__(self) -> str:",
            "        s = str(list(self))",
            "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
            "",
            "    def _find_bucket(self, x: T) -> List[T]:",
            "        \"Find the bucket which should contain x. self must not be empty.\"",
            "        for a in self.a:",
            "            if x <= a[-1]: return a",
            "        return a",
            "",
            "    def __contains__(self, x: T) -> bool:",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        return i != len(a) and a[i] == x",
            "",
            "    def add(self, x: T) -> bool:",
            "        \"Add an element and return True if added. / O(√N)\"",
            "        if self.size == 0:",
            "            self.a = [[x]]",
            "            self.size = 1",
            "            return True",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i != len(a) and a[i] == x: return False",
            "        a.insert(i, x)",
            "        self.size += 1",
            "        if len(a) > len(self.a) * self.REBUILD_RATIO:",
            "            self._build()",
            "        return True",
            "",
            "    def discard(self, x: T) -> bool:",
            "        \"Remove an element and return True if removed. / O(√N)\"",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i == len(a) or a[i] != x: return False",
            "        a.pop(i)",
            "        self.size -= 1",
            "        if len(a) == 0: self._build()",
            "        return True",
            "",
            "    def lt(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element < x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] < x:",
            "                return a[bisect_left(a, x) - 1]",
            "",
            "    def le(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element <= x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] <= x:",
            "                return a[bisect_right(a, x) - 1]",
            "",
            "    def gt(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element > x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return a[bisect_right(a, x)]",
            "",
            "    def ge(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element >= x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return a[bisect_left(a, x)]",
            "",
            "    def __getitem__(self, x: int) -> T:",
            "        \"Return the x-th element, or IndexError if it doesn't exist.\"",
            "        \"sm[-1]も可能\"",
            "        if x < 0: x += self.size",
            "        if x < 0: raise IndexError",
            "        for a in self.a:",
            "            if x < len(a): return a[x]",
            "            x -= len(a)",
            "        raise IndexError",
            "",
            "    def _index(self, x: T) -> int:",
            "        \"Count the number of elements < x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return ans + bisect_left(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "    def _index_right(self, x: T) -> int:",
            "        \"Count the number of elements <= x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return ans + bisect_right(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "####################################",
            "    def remove(self, x):",
            "        if x in self:",
            "            self.discard(x)",
            "",
            "    def index(self, x):",
            "        if x in self:",
            "            return self._index(x)",
            "        else:",
            "            return None",
            "",
            "    def strictly_left(self, x):",
            "        return self.lt(x)",
            "",
            "    def strictly_left_pos(self, x):",
            "        v = self.lt(x)",
            "        if v: return self.index(v)",
            "        return None",
            "",
            "    def strictly_right(self, x):",
            "        return self.gt(x)",
            "",
            "    def strictly_right_pos(self, x):",
            "        v = self.gt(x)",
            "        if v: return self.index(v)",
            "        return None",
            "",
            "########################################",
            "",
            "#n, k = map(int, input().split())",
            "#p = list(map(int, input().split()))",
            "",
            "ss = SortedSet()",
            "",
            "#for i in range(n):",
            "#    ss.add(p[i])",
            "#    if len(ss) < k: continue",
            "#    print(ss[-k])",
            "",
            "ss.add(2)",
            "ss.add(3)",
            "ss.add(5)",
            "print(ss.strictly_right_pos(3))",
            "print(2 in ss)",
            "ss.remove(2)",
            "print(2 in ss)"
        ],
        "description": []
    },
    "区間和の最大値": {
        "prefix": [
            "Lib_区間和の最大値"
        ],
        "body": [
            "",
            "class Imos:",
            "    def __init__(self, a:list):",
            "        self.origin = a",
            "        self.accum = [0]",
            "        for ai in a:",
            "            self.accum.append(self.accum[-1] + ai)",
            "        self.n = self.accum",
            "        self.INF = float('inf')",
            "",
            "    def _get_max(self, accum:list):",
            "        \"\"\"",
            "        区間和(ar-al)の最大値",
            "        max(ar-min(al))",
            "        \"\"\"",
            "        ret_min = - self.INF",
            "        min_al = self.INF",
            "        for ar in accum:",
            "            min_al = min(ar, min_al)",
            "            ret_min= max(ar - min_al, ret_min)",
            "        return ret_min",
            "",
            "    @property",
            "    def get_max(self):",
            "        return self._get_max(self.accum)",
            "",
            "    @property",
            "    def get_min(self):",
            "        return - self._get_max([-ai for ai in self.accum])",
            "",
            "",
            "n = int(input())",
            "a = list(map(int, input().split()))",
            "for i, ai in enumerate(a):",
            "    if ai==0:",
            "        a[i] = -1",
            "",
            "im = Imos(a)",
            "print(im.get_max - im.get_min + 1)",
            "",
            ""
        ],
        "description": [
            "区間和を累積和の差分としてその最大値を求めるar-al"
        ]
    },
    "セグメント木１点更新区間集約": {
        "prefix": [
            "Lib_Q_Seg_一点更新区間集約"
        ],
        "body": [
            "class SegmentTree:  # 初期化処理",
            "    \"\"\"Segment Tree",
            "    一点更新・区間集約",
            "    Parameters",
            "    ----------",
            "    init : list",
            "        初期リスト",
            "    f : SegmentTreeにのせるモノイド",
            "        作用素",
            "    ie : fに対する単位元",
            "    Notes",
            "    -----",
            "    1-indexed",
            "    https://atcoder.jp/contests/practice2/tasks/practice2_j",
            "    モノイドとは、集合と二項演算の組で、結合法則と単位元の存在するもの",
            "    ex. +, max, min",
            "    [ 1] a0 ・ a1  ・ a2 ・ a3 ・ a4 ・ a5 ・ a6 ・ a7  ->[0]",
            "    [ 2] a0 ・ a1  ・ a2 ・ a3       [ 3] a4 ・ a5 ・ a6・ a7",
            "    [ 4] a0 ・ a1    [ 5] a2 ・ a3   [ 6] a4 ・ a5   [ 7] a6 ・ a7",
            "    [ 8] a0 [ 9] a1  [10] a2 [11] a3 [12] a4 [13] a5 [14] a6 [15] a7",
            "                          [0001]",
            "              [0010]                  [0011]",
            "        [0100]      [0101]      [0110]      [0111]",
            "     [1000][1001][1010][1011][1100][1101][1110][1111]",
            "    size = 8  元の配列数の２べき乗値",
            "    親のインデックス         i//2 or i>>=1 bitで一個右シフト",
            "    左側の子のインデックス    2*i",
            "    右側の子のインデックス    2*i+1",
            "    aiの値が代入されているインデックス    i+size",
            "    \"\"\"",
            "    def __init__(self, init, f, ie):",
            "        self._f = f",
            "        self._ie = ie",
            "        if type(init) == int:",
            "            init = [ie] * init",
            "        self._n = len(init)",
            "        self._log = (self._n - 1).bit_length()  # seg木の深さ",
            "        self._size = 1 << self._log     # seg木のサイズ",
            "        # seg木の初期化",
            "        self._dat = [ie] * self._size + init + [ie] * (self._size - len(init))",
            "        for i in range(self._size-1, 0, -1):",
            "            self._update(i)",
            "",
            "",
            "    def _update(self, i):",
            "        # 下の層2つの演算結果の代入(完全二分木における子同士の演算)",
            "        self._dat[i] = self._f(self._dat[i*2], self._dat[i*2+1])",
            "",
            "",
            "    def __getitem__(self, i):",
            "        \"\"\"index = i の値を求める",
            "        \"\"\"",
            "        return self._dat[i + self._size]",
            "",
            "",
            "    def __str__(self):",
            "        \"\"\"元のリストの値を表示",
            "        \"\"\"",
            "        return ' '.join(map(str, (self[i] for i in range(self._n))))",
            "",
            "",
            "    def update(self, i, x):",
            "        \"\"\"one point update",
            "        a[i] を xに更新",
            "        \"\"\"",
            "        #",
            "        i += self._size",
            "        self._dat[i] = x",
            "        while i > 0:    # 層をのぼりながら値を更新 indexが0になれば終了",
            "            i >>= 1     # 1つ上の層のインデックス(完全二分木における親)",
            "            # 下の層2つの演算結果の代入(完全二分木における子同士の演算)",
            "            self._update(i)",
            "",
            "",
            "    def add(self, i, x):",
            "        \"\"\"one point update",
            "        a[i] に xを加算",
            "        \"\"\"",
            "        #",
            "        i += self._size",
            "        self._dat[i] += x",
            "        while i > 0:    # 層をのぼりながら値を更新 indexが0になれば終了",
            "            i >>= 1     # 1つ上の層のインデックス(完全二分木における親)",
            "            # 下の層2つの演算結果の代入(完全二分木における子同士の演算)",
            "            self._update(i)",
            "",
            "",
            "    def query(self, l, r):",
            "        \"\"\"半開区間[l, r)にf(a[l], a[l+1])演算",
            "        \"\"\"",
            "        # モノイドでは可換律は保証されていないので演算の方向に注意",
            "        l += self._size  # 1番下の層におけるインデックス",
            "        r += self._size  # 1番下の層におけるインデックス",
            "        # 左側の答えと右側の答えを初期化",
            "        lret, rret = self._ie, self._ie",
            "        while l < r:    # lとrが重なるまで上記の判定を用いて演算を実行",
            "            # 左が子同士の右側(lが奇数)(lの末桁=1)ならば、dat[l]を演算",
            "            if l & 1:",
            "                lret = self._f(lret, self._dat[l])",
            "                l += 1",
            "            # 右が子同士の右側(rが奇数)(rの末桁=1)ならば、dat[r-1]を演算",
            "            if r & 1:",
            "                r -= 1",
            "                rret = self._f(self._dat[r], rret)",
            "            l >>= 1",
            "            r >>= 1",
            "        return self._f(lret, rret)",
            "",
            "",
            "    def max_right(self, l, isOk):",
            "        \"\"\"",
            "        ex:",
            "        maxの場合 a[l]  a[r-1] が isOKとなる最大の値",
            "        (1): 関数 bool isOk(x) を定義し、segtreeの上で二分探索をする。",
            "        (2): 木の値を引数にとりboolを返す関数オブジェクトを渡して使用します。",
            "        r = l もしくは f(op(a[l], a[l + 1], ..., a[r - 1])) = true",
            "        r = n もしくは f(op(a[l], a[l + 1], ..., a[r])) = false",
            "        fが単調だとすれば、f(op(a[l], a[l + 1], ..., a[r - 1])) = true となる最大のr",
            "        \"\"\"",
            "        if l >= self._n: return self._n",
            "        l += self._size",
            "        sm = self._ie",
            "        while True:",
            "            while l % 2 == 0: l >>= 1",
            "            if not isOk(self._f(sm, self._dat[l])):",
            "                while l < self._size:",
            "                    l <<= 1",
            "                    if isOk(self._f(sm, self._dat[l])):",
            "                        sm = self._f(sm, self._dat[l])",
            "                        l += 1",
            "                return l - self._size",
            "            sm = self._f(sm, self._dat[l])",
            "            l += 1",
            "            if l & -l == l: break",
            "        return self._n",
            "",
            "",
            "    def min_left(self, r, isOk):",
            "        \"\"\"",
            "        l = r もしくは f(op(a[l], a[l + 1], ..., a[r - 1])) = true",
            "        l = 0 もしくは f(op(a[l-1], a[l], ..., a[r-1])) = false",
            "        fが単調だとすれば、f(op(a[l], a[l + 1], ..., a[r - 1])) = true となる最小のl",
            "        \"\"\"",
            "        if r <= 0: return 0",
            "        r += self._size",
            "        sm = self._ie",
            "        while True:",
            "            while r > 1 and r % 2 == 1: r >>= 1",
            "            if not isOk(self._f(self._dat[r], sm)):",
            "                while r < self._size:",
            "                    r = r << 1 | 1",
            "                    if isOk(self._f(self._dat[r], sm)):",
            "                        sm = self._f(self._dat[r], sm)",
            "                        r -= 1",
            "                return r + 1 - self._size",
            "            sm = self._f(self._dat[r], sm)",
            "            if r & -r == r: break",
            "        return 0",
            "",
            "",
            "####################################",
            "class RMaxQSegmentTree(SegmentTree):",
            "    def __init__(self, init):",
            "        super().__init__(init, max, -float('inf'))",
            "",
            "class RMinimumQSegmentTree(SegmentTree):",
            "    def __init__(self, init):",
            "        super().__init__(init, min, float('inf'))",
            "",
            "class RSumQSegmentTree(SegmentTree):",
            "    def __init__(self, init):",
            "        super().__init__(init, lambda x, y: x + y, 0)",
            "",
            "class RProdQSegmentTree(SegmentTree):",
            "    def __init__(self, init):",
            "        super().__init__(init, lambda x, y: x * y, 1)",
            "",
            "class RXorQSegmentTree(SegmentTree):",
            "    def __init__(self, init):",
            "        super().__init__(init, lambda x, y: x ^ y, 0)",
            "",
            "# GCD query",
            "from math import gcd",
            "ie = 0",
            "def op(x, y):",
            "    if x == ie: return y",
            "    if y == ie: return x",
            "    return gcd(x, y)",
            "",
            "sgt = SegmentTree(a, op, ie)",
            "",
            "####################################",
            "",
            "",
            "# n, q = map(int, input().split())",
            "# a = list(map(int, input().split()))",
            "",
            "a = [1,2,3,2,1,3,3,5,2,1]",
            "# sgt = SegmentTree(a, op, ie)",
            "x, v = 3, 55123",
            "l, r = 2, 5",
            "sgt.update(x, v)",
            "print(sgt.query(l, r))",
            "# max_right   lを固定してlambdaを満たす最大のr",
            "# min_left    rを固定してlambdaを満たす最小のl",
            "for l in range(10):",
            "    r = sgt.max_right(l, lambda q: q > 2)",
            "    print(l, r, sgt.query(l, r))",
            "",
            "#print(sgt)",
            ""
        ],
        "description": [
            "セグメント木１点更新区間集約"
        ]
    },
    "Lib_AL_図形_n角形/円": {
        "prefix": [
            "Lib_AL_図形_n角形/円"
        ],
        "body": [
            "",
            "import math",
            "EPS = 1e-08",
            "MAX = 2e09",
            "PI = math.pi",
            "",
            "######################################################################",
            "class Point:",
            "    def __init__(self, x=0, y=0):",
            "        self.x = x",
            "        self.y = y",
            "",
            "    def __add__(self, other):",
            "        return Point(self.x + other.x, self.y + other.y)",
            "",
            "    def __sub__(self, other):",
            "        return Point(self.x - other.x, self.y - other.y)",
            "",
            "    def __mul__(self, const):",
            "        return Point(self.x * const, self.y * const)",
            "",
            "    def __truediv__(self, const):",
            "        return Point(self.x / const, self.y / const)",
            "",
            "    @property",
            "    def norm2(self):",
            "        return self.x **2 + self.y **2",
            "",
            "    @property",
            "    def abs(self):",
            "        return self.norm2 ** 0.5",
            "",
            "    @property",
            "    def radian(self):",
            "        return math.atan2(self.y, self.x)",
            "",
            "    @property",
            "    def quadrant(self):",
            "        if self.x == 0 and self.y == 0: return 0",
            "        if self.x > 0 and self.y >= 0: return 1",
            "        if self.x <= 0 and self.y > 0: return 2",
            "        if self.x < 0 and self.y <=0: return 3",
            "        return 4",
            "",
            "    def dot(self, other):",
            "        return self.x * other.x + self.y * other.y",
            "",
            "    def det(self, other):",
            "        return self.x * other.y - self.y * other.x",
            "",
            "    def dot3(self, other1, other2):",
            "        return (other1 - self).dot(other2 - self)",
            "",
            "    def det3(self, other1, other2):",
            "        return (other1 - self).det(other2 - self)",
            "",
            "    def dist2(self, other):",
            "        d = self - other",
            "        return (d.x)**2 + (d.y)**2",
            "",
            "    def dist(self, other):",
            "        return self.dist2(other) ** 0.5",
            "",
            "    def __lt__(self, other):",
            "        seq = self.quadrant",
            "        otq = other.quadrant",
            "        det = self.det(other)",
            "        if seq != otq:",
            "            return seq < otq",
            "        if det == 0:",
            "            return self.norm2 < other.norm2",
            "        else:",
            "            return det > 0",
            "",
            "    def rotate_radian(self, rad):",
            "        cos, sin = math.cos(rad), math.sin(rad)",
            "        return Point(self.x * cos - self.y * sin, self.x * sin + self.y * cos)",
            "",
            "    def rotate_degree(self, rad):",
            "        rad = math.radians(rad)  # radが度数の場合",
            "        return self.rotate_radian(rad)",
            "",
            "    @property",
            "    def orthogonal(self):",
            "        return Point(- self.y, self.x)",
            "",
            "    def counter_clockwise(self, other1, other2):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_C",
            "        COUNTER_CLOCKWISE = 1   #左に曲がる場合(1)",
            "        CLOCKWISE = -1          #右に曲がる場合(2)",
            "        ONLINE_BACK = 2         #c<-a->b 反対に戻る(3)",
            "        ONLINE_FRONT = -2       #a->b->c 同じ方向に伸びる(4)",
            "        ON_SEGMENT = 0          #a->c->b 戻るがaとbの間(5)",
            "    ###################################################################",
            "        a, b, c = self, other1, other2",
            "        ba, ca = b - a, c - a",
            "        det = b.det(c)",
            "        if det > EPS: return COUNTER_CLOCKWISE",
            "        if det < -EPS: return CLOCKWISE",
            "        if ba.dot(ca) < -EPS: return ONLINE_BACK",
            "        if (a - b).dot(c - b) < -EPS: return ONLINE_FRONT",
            "        return ON_SEGMENT",
            "",
            "    @property",
            "    def value(self):",
            "        return self.x, self.y",
            "",
            "",
            "######################################################################",
            "class Line:",
            "    def __init__(self, p0: Point, p1: Point):",
            "        self.p0, self.p1 = p0, p1",
            "        self.vector = p1 - p0",
            "",
            "    @property",
            "    def mid_point(self):",
            "    # 中点",
            "        return self.p0 + self.vector * 0.5",
            "",
            "    @property",
            "    def midperpendicular(self):",
            "    # 垂直二等分線",
            "    # 中点から中点＋直交ベクトルまでの線分とする",
            "        return Line(self.mid_point, self.mid_point + self.vector.orthogonal)",
            "",
            "    def is_parallel(self, other):",
            "    #https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_A",
            "    # ２直線の平行判定",
            "        return abs(self.vector.det(other.vector)) < EPS",
            "",
            "    def is_orthogonal(self, other):",
            "    #https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_A",
            "    # ２直線の直交判定",
            "        return abs(self.vector.dot(other.vector)) < EPS",
            "",
            "    def project(self, p: Point):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_A",
            "    # 垂線の足",
            "        dv = self.p0.dot3(self.p1, p)",
            "        dd = self.p0.dist2(self.p1)",
            "        return self.p0 + self.vector * (dv/dd)",
            "",
            "    def dist_from_point(self, p: Point):",
            "        # 垂線の長さ",
            "        return p.dist2(self.project(p)) ** 0.5",
            "",
            "    def reflect(self, p: Point):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/1/CGL_1_B",
            "    # 反射",
            "        return p + (self.project(p) - p) * 2",
            "",
            "    def is_intersect(self, other):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_B",
            "    # 線分同士の交点判定",
            "        p0, p1 = self.p0, self.p1",
            "        q0, q1 = other.p0, other.p1",
            "        C0, C1 = p0.det3(p1, q0), p0.det3(p1, q1)",
            "        D0, D1 = q0.det3(q1, p0), q0.det3(q1, p1)",
            "        if abs(C0) < EPS and abs(C1) < EPS:",
            "            E0, E1 = p0.dot3(p1, q0), p0.dot3(p1, q1)",
            "            if not E1 - E0 > 0:",
            "                E0, E1 = E1, E0",
            "            return p0.dist2(p1) - E0 > -EPS and E1 > -EPS",
            "        return C0 * C1 < EPS and D0* D1 < EPS",
            "",
            "    def cross_point(self, other):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_C",
            "    # 直線の交点",
            "        if self.is_parallel(other): return None",
            "        d = self.vector.det(other.vector)",
            "        sn = (other.p0 - self.p0).det(other.vector)",
            "        return self.p0 + self.vector * (sn/d)",
            "",
            "    def dist_to_line(self, other):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/2/CGL_2_D",
            "    # 線分と線分の距離",
            "        if self.is_intersect(other):",
            "            return 0",
            "        ret = float('inf')",
            "        h = other.project(self.p0)",
            "        if other.p0.counter_clockwise(other.p1, h) == 0:",
            "            ret = min(ret, self.p0.dist(h))",
            "        h = other.project(self.p1)",
            "        if other.p0.counter_clockwise(other.p1, h) == 0:",
            "            ret = min(ret, self.p1.dist(h))",
            "        h = self.project(other.p0)",
            "        if self.p0.counter_clockwise(self.p1, h) == 0:",
            "            ret = min(ret, other.p0.dist(h))",
            "        h = self.project(other.p1)",
            "        if self.p0.counter_clockwise(self.p1, h) == 0:",
            "            ret = min(ret, other.p1.dist(h))",
            "        ret = min(ret, self.p0.dist(other.p0), self.p0.dist(other.p1))",
            "        ret = min(ret, self.p1.dist(other.p0), self.p1.dist(other.p1))",
            "        return ret",
            "",
            "    def half_line(self, reverse=False):",
            "    # 半直線",
            "        d = self.vector.abs",
            "        if reverse:",
            "            return Line(self.p0, self.p0 + self.vector * MAX / d)",
            "        return Line(self.p0 - self.vector * MAX / d, self.p1)",
            "",
            "    def line(self):",
            "    # 直線",
            "        d = self.vector.abs",
            "        return Line(self.p0 - self.vector * MAX / d, self.p0 + self.vector * MAX / d)",
            "",
            "    @property",
            "    def value(self):",
            "        return self.p0.value, self.p1.value, self.vector",
            "",
            "    def contains(self, p: Point):",
            "        return self.p0.counter_clockwise(self.p1, p) == 0",
            "",
            "",
            "######################################################################",
            "class Polygon:",
            "    def __init__(self, pts: list):",
            "        # pts = [Point(x, y) for x, y in listoftuple]",
            "        self.N = len(pts)",
            "        self.points = pts",
            "        self.pts = [p.value for p in pts]",
            "",
            "    @property",
            "    def value(self):",
            "        return self.pts",
            "",
            "    @property",
            "    def area(self):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_A",
            "    # 多角形の面積",
            "    # O(N)",
            "        P = self.points",
            "        return abs(sum(P[i].det(P[i-1]) for i in range(self.N))) / 2",
            "",
            "    @property",
            "    def is_convex(self):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_B",
            "    # 凸性判定",
            "    # O(N)",
            "        P = self.points",
            "        return not any((P[i-2].counter_clockwise(P[i-1], P[i]) == -1 for i in range(self.N)))",
            "",
            "    def contains(self, p:Point):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/3/CGL_3_C",
            "    # 多角形-点の包含 凸多角形とは限らない",
            "    # O(N)",
            "        \"\"\"",
            "        returns",
            "        0: not",
            "        1: on 線上",
            "        2: contain 包含",
            "        \"\"\"",
            "        ON_EDGE = 1",
            "        INCLUDE = 2",
            "        NOT_INCLUDE = 0",
            "        included = False",
            "        for i in range(self.N):",
            "            p0, p1 = self.points[i-1] - p, self.points[i] - p",
            "            if abs(p0.det(p1)) < EPS and p0.dot(p1) < EPS: return ON_EDGE",
            "            if p0.y > p1.y: p0, p1 = p1, p0",
            "            if p0.y < EPS < p1.y and p0.det(p1) > EPS: included = not included",
            "        if included: return INCLUDE",
            "        return NOT_INCLUDE",
            "",
            "    @property",
            "    def convex_hull(self):",
            "        # https://onlinejudge.u-aizu.ac.jp/problems/CGL_4_A",
            "        # ps = [(x, y), ...]",
            "        # 凸包(点集合 P の全ての点を含む最小の凸多角形)を出力する",
            "        # O(N)",
            "        _pts = sorted(self.pts)",
            "        qs = []",
            "        N = len(_pts)",
            "        for x, y in _pts:",
            "            p = Point(x, y)",
            "            while len(qs) > 1 and qs[-1].det3(qs[-2], p) > EPS:",
            "                qs.pop()",
            "            qs.append(p)",
            "        t = len(qs)",
            "        for i in range(N-1)[::-1]:",
            "            x, y = _pts[i]",
            "            p = Point(x, y)",
            "            while len(qs) > t and qs[-1].det3(qs[-2], p) > EPS:",
            "                qs.pop()",
            "            qs.append(p)",
            "        return Polygon(qs[:-1])",
            "",
            "    @property",
            "    def diameter(self):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_B",
            "        # 凸多角形の直径",
            "        # O(N)",
            "        ch = self.convex_hull",
            "        if ch.N == 2:",
            "            return ch.points[0].dist(ch.points[1])",
            "        i = j = 0",
            "        for k in range(ch.N):",
            "            if ch.points[k].value < ch.points[i].value: i = k",
            "            if ch.points[j].value < ch.points[k].value: j = k",
            "        ret = 0",
            "        si = i; sj = j",
            "        while i != sj or j != si:",
            "            ret = max(ret, ch.points[i].dist(ch.points[j]))",
            "            if (ch.points[i]-ch.points[i-ch.N+1]).det(ch.points[j]-ch.points[j-ch.N+1])  < -EPS:",
            "                i = (i+1) % ch.N",
            "            else:",
            "                j = (j+1) % ch.N",
            "        return ret",
            "",
            "    def convex_cut(self, l: Line):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/4/CGL_4_C",
            "        # 凸多角形を直線で切った時の右側の多角形",
            "        q = []",
            "        for i in range(self.N):",
            "            p0, p1 = self.points[i-1], self.points[i]",
            "            cv0, cv1 = l.p0.det3(l.p1, p0), l.p0.det3(l.p1, p1)",
            "            if cv0 * cv1 < EPS:",
            "                v = l.cross_point(Line(p0, p1))",
            "                if v is not None: q.append(v)",
            "            if cv1 > -EPS: q.append(p1)",
            "        return Polygon(q)",
            "",
            "    def contains(self, p: Point):",
            "        # https://atcoder.jp/contests/abc296/tasks/abc296_g",
            "        # ある点が凸多角形に入っているか",
            "        ON_EDGE = 1",
            "        INCLUDE = 2",
            "        NOT_INCLUDE = 0",
            "        ######################",
            "        left = 1; right = self.N",
            "        q0 = self.points[0]",
            "        while right - left > 1:",
            "            mid = (left + right) // 2",
            "            if q0.det3(p, self.points[mid]) < EPS: left = mid",
            "            else: right = mid",
            "        if left == self.N-1:",
            "            left -= 1",
            "        qi = self.points[left]; qj = self.points[left + 1]",
            "        v0 = q0.det3(qi, qj)",
            "        v1, v2 = q0.det3(p, qj), q0.det3(qi, p)",
            "        if v0 < -EPS:",
            "            v1 = -v1; v2 = -v2",
            "        if 0 <= v1 and 0 <= v2 and v1 + v2 <= v0:",
            "            if left == 1 and abs(v2) < EPS: return ON_EDGE",
            "            if left + 1 == self.N - 1 and abs(v1) < EPS: return ON_EDGE",
            "            if abs(v1 + v2 - v0) < EPS: return ON_EDGE",
            "            return INCLUDE",
            "        return NOT_INCLUDE",
            "",
            "######################################################################",
            "class Circle:",
            "    def __init__(self, p: Point, r: float):",
            "        self.center = p",
            "        self.radius = r",
            "",
            "    @property",
            "    def value(self):",
            "        return self.center, self.radius",
            "",
            "    @property",
            "    def area(self):",
            "        return PI * self.radius * self.radius",
            "",
            "    def area_sector(self, rad):",
            "        return self.radius * self.radius * rad / 2",
            "",
            "    def contain_point(self, p:Point):",
            "        return (p - self.center).abs - self.radius < -EPS",
            "",
            "    def is_intersect(self, other):",
            "    # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_A",
            "    # 円の交差判定",
            "    # 接線の数を出力",
            "        OUTER = 4           # 離れている",
            "        CIRCUMSCRIBED = 3   # 外接",
            "        CROSSED = 2           # 交わる",
            "        INSCRIBED = 1       # 内接",
            "        CONTAINED = 0         # 包含",
            "",
            "        R = max(self.radius, other.radius)",
            "        r = min(self.radius, other.radius)",
            "        d = self.center.dist(other.center)",
            "        # d > R+r :O o | d < R-r: ◎ | else 交差",
            "        if d - R - r > EPS: return OUTER",
            "        elif d - R - r > -EPS : return CIRCUMSCRIBED",
            "        if R - r - d > EPS: return CONTAINED",
            "        elif R - r -d > -EPS: return INSCRIBED",
            "        return CROSSED",
            "",
            "    def cross_point_line(self, l: Line, restrict=False):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_D",
            "        # 直線との交点",
            "        # restrict == True なら線分として判定",
            "        p0c = l.p0 - self.center",
            "        a = l.vector.abs ** 2",
            "        b = l.vector.dot(p0c)",
            "        c = p0c.abs ** 2 - self.radius ** 2",
            "        D = b**2 - a * c",
            "        if D < -EPS: return (None, None)",
            "        if D < EPS: D = 0",
            "        s1 = (- b + D**0.5) / a",
            "        p1 = l.p0 + l.vector * s1",
            "        s2 = (- b - D**0.5) / a",
            "        p2 = l.p0 + l.vector * s2",
            "        if restrict:",
            "            if not (0 <= s1 <= 1): p1 = None",
            "            if not (0 <= s2 <= 1): p2 = None",
            "        return (p1, p2)",
            "",
            "    def cross_point_circle(self, other):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_E",
            "        # 円同士の交点",
            "        isintersect = self.is_intersect(other)",
            "        if isintersect == 0 or isintersect == 4: return (None, None)",
            "        d = other.center - self.center",
            "        rr0 = d.abs ** 2",
            "        rr1 = self.radius ** 2",
            "        rr2 = other.radius ** 2",
            "        cv = rr0 + rr1 - rr2",
            "        sv = (4*rr0*rr1 - cv**2)**0.5",
            "        p1 = (d * cv + d.orthogonal * sv) / (2 * rr0)",
            "        p1 = self.center + p1",
            "        p2 = (d * cv - d.orthogonal * sv) / (2 * rr0)",
            "        p2 = self.center + p2",
            "        return (p1, p2)",
            "",
            "    def sector_area(self, p1: Point, p2: Point):",
            "        # 円弧の面積",
            "        rad = abs((p1-self.center).radian - (p2-self.center).radian)",
            "        mrad = min(rad, 2*PI - rad)",
            "        Mrad = max(rad, 2*PI - rad)",
            "        return self.area_sector(mrad), self.area_sector(Mrad)",
            "",
            "    def cross_area_line(self, l:Line):",
            "        # 円を直線で切った部分の面積",
            "        tri = Triangle([self.center, l.p0, l.p1]).area",
            "        sector = self.sector_area(l.p0, l.p1)",
            "        return (sector[0] - tri, sector[1] + tri)",
            "",
            "    def cross_area_circle(self, other):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_I",
            "        # ２つ円の共通部分の面積",
            "        isintersect = self.is_intersect(other)",
            "        if isintersect >= 3: return 0",
            "        if isintersect < 2: return min(self.area, other.area)",
            "        dd = (self.center - other.center).norm2",
            "        p1 = self.radius ** 2 - other.radius ** 2 + dd",
            "        p2 = other.radius ** 2 - self.radius ** 2 + dd",
            "        S1 = self.radius * self.radius * math.atan2((4 * dd * self.radius ** 2 - p1 ** 2) ** 0.5, p1)",
            "        S2 = other.radius * other.radius * math.atan2((4 * dd * other.radius ** 2 - p2 ** 2) ** 0.5, p2)",
            "        S0 = (4 * dd * self.radius * self.radius - p1 ** 2) ** 0.5 / 2",
            "        return S1 + S2 - S0",
            "",
            "    def tangent_point(self, p:Point):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_F",
            "        # 円と点の接点",
            "        if self.contain_point(p): return None",
            "        r = ((self.center - p).abs ** 2 - self.radius ** 2) ** 0.5",
            "        dummycircle = Circle(p, r)",
            "        return self.cross_point_circle(dummycircle)",
            "",
            "    def tangent_line(self, p:Point):",
            "        # 円と点の接線",
            "        return Line(p, self.tangent_point)",
            "",
            "    def common_tanget_outer(self, other):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_G",
            "        # 円と円の共通接線の外接点",
            "        retext = []",
            "        d = other.center - self.center",
            "        rr0 = d.abs ** 2",
            "        cv  = self.radius - other.radius",
            "        sv = rr0 - cv ** 2",
            "        if sv > -EPS:",
            "        ## 外接線",
            "            if abs(sv) < EPS:",
            "                retext.append(self.center + d * (self.radius * cv / rr0))",
            "            else:",
            "                sv **= 0.5",
            "                retext.append(self.center + (d * cv + d.orthogonal * sv) * self.radius / rr0)",
            "                retext.append(self.center + (d * cv - d.orthogonal * sv) * self.radius / rr0)",
            "        return retext",
            "",
            "    def common_tanget_inner(self, other):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_G",
            "        # 円と円の共通接線の内接点",
            "        retext = []",
            "        d = other.center - self.center",
            "        rr0 = d.abs ** 2",
            "        cv  = self.radius + other.radius",
            "        sv = rr0 - cv ** 2",
            "        if sv > -EPS:",
            "        ## 内接線",
            "            if abs(sv) < EPS:",
            "                retext.append(self.center + d * (self.radius * cv / rr0))",
            "            else:",
            "                sv **= 0.5",
            "                retext.append(self.center + (d * cv + d.orthogonal * sv) * self.radius / rr0)",
            "                retext.append(self.center + (d * cv - d.orthogonal * sv) * self.radius / rr0)",
            "        return retext",
            "",
            "",
            "######################################################################",
            "class Triangle(Polygon):",
            "    def __init__(self, pts):",
            "        assert len(pts) == 3, \"Not 3 points\"",
            "        super().__init__(pts)",
            "",
            "    @property",
            "    def circle_in(self):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_B",
            "        # 内接円",
            "        dp1 = self.points[1] - self.points[0]",
            "        dp2 = self.points[2] - self.points[0]",
            "        dd = [(self.points[2] - self.points[1]).abs, dp2.abs, dp1.abs]",
            "        dsum = sum(dd)",
            "        r = abs(dp1.det(dp2)) / dsum",
            "        c = Point(0, 0)",
            "        for ci, ddi in zip(self.points, dd):",
            "            c = c + ci * ddi",
            "        c = c / dsum",
            "        return Circle(c, r)",
            "",
            "    @property",
            "    def circle_circumscribed(self):",
            "        # https://onlinejudge.u-aizu.ac.jp/courses/library/4/CGL/7/CGL_7_C",
            "        # 外接円",
            "        dp1 = (self.points[0] - self.points[1]) * 2 # a, b",
            "        dp2 = (self.points[0] - self.points[2]) * 2 # c, d",
            "        p = self.points[0].abs ** 2 - self.points[1].abs ** 2",
            "        q = self.points[0].abs ** 2 - self.points[2].abs ** 2",
            "        det = dp1.det(dp2)",
            "        x = dp2.y * p - dp1.y * q",
            "        y = dp1.x * q - dp2.x * p",
            "        if det < -EPS:",
            "            x *= -1; y *= -1; det *= -1",
            "        x /= det; y /= det",
            "        c = Point(x, y)",
            "        r = c.dist(self.points[0])",
            "        return Circle(c, r)",
            "",
            "######################################################################",
            "def closestPair(points):",
            "    \"\"\"",
            "    最近点対 (分割統治法)",
            "    \"\"\"",
            "    def _closest_Pair(points):",
            "        n=len(points)",
            "        if n <= 1:",
            "            return MAX",
            "        m = n//2",
            "        x = points[m].x",
            "        d = min(_closest_Pair(points[:m]), _closest_Pair(points[m:]))",
            "        points.sort(key=lambda p:p.y)",
            "        L=[]",
            "        for i in range(n):",
            "            if abs(points[i].x - x) < d:",
            "                for j in range(len(L)):",
            "                    if points[i].y-L[-j-1].y >= d:",
            "                        break",
            "                    d = min(d, points[i].dist(L[-j-1]))",
            "                L.append(points[i])",
            "        return d",
            "    points.sort(key=lambda p: p.x)",
            "    return _closest_Pair(points)",
            "",
            "",
            "######################################################################",
            "",
            "# x, y = map(int, input().split())",
            "# p = Point(x, y)",
            "# x, y, u, v = map(int, input().split())",
            "# l = Line(Point(x, y), Point(u, v))",
            "# poly = Polygon([Point(tuple(map(int, input().split()))) for _ in range(m)])",
            "# x, y, r = map(int, input().split())",
            "# cir = Circle(Point(x, y), r)",
            "# tri = Polygon([tuple(map(int, input().split())) for _ in range(3)])",
            "",
            "P = []",
            "for _ in range(int(input())):",
            "    x,y=map(float,input().split())",
            "    P.append(Point(x,y))",
            "print('{:.10f}'.format(closestPair(P)))",
            "",
            "######################################################################",
            "",
            ""
        ],
        "description": [
            "図形のライブラリ"
        ]
    },
    "包除原理": {
        "prefix": [
            "Lib_M_包除原理_houjo"
        ],
        "body": [
            "",
            "# 包除原理",
            "# n(A or B or C) = n(A) + n(B) + n(C)",
            "#                  -n(A&B) -n(B&C) -n(C&A)",
            "#                  +n(A&B&C)",
            "",
            "n, d = map(int, input().split())",
            "a = list(map(int, input().split()))",
            "",
            "def cnt(b):",
            "    cntzero = d - bin(b).count('1')",
            "    return 1 << cntzero",
            "",
            "ret = 0",
            "# bit全探索",
            "for i in range(1, 1<<n):",
            "    num = 0",
            "    c = 0",
            "    for j in range(n):",
            "        if i>>j & 1:",
            "        # iで考える集合jが存在する場合",
            "            num |= a[j]",
            "            c += 1",
            "    #x = n(****)",
            "    x = cnt(num)",
            "    #次数によりプラスとマイナスを変える",
            "    if c%2 == 1:",
            "        ret += x",
            "    else:",
            "        ret -= x",
            "",
            "ret = (1 << d) - ret",
            "",
            "print(ret)",
            ""
        ],
        "description": [
            "包除原理"
        ]
    },
    "output0": {
        "prefix": [
            "print(0ret)"
        ],
        "body": [
            "print(ret)"
        ],
        "description": [
            "print(ret)"
        ]
    },
    "output2": {
        "prefix": [
            "print(2INF)"
        ],
        "body": [
            "print(-1 if ret == INF else ret)"
        ],
        "description": [
            "print(INF)"
        ]
    },
    "output3": {
        "prefix": [
            "print(3joinret)"
        ],
        "body": [
            "print('\\n'.join(ret))"
        ],
        "description": [
            "print(joinret)"
        ]
    },
    "output4": {
        "prefix": [
            "print(4join(map(str(ret)"
        ],
        "body": [
            "print('\\n'.join(map(str, ret)))"
        ],
        "description": [
            "print(join(map(str(ret)"
        ]
    },
    "output5": {
        "prefix": [
            "print(5interactive)"
        ],
        "body": [
            "def req(ret):",
            "    print(ret, flush=True)",
            ""
        ],
        "description": [
            "interactive"
        ]
    },
    "output6": {
        "prefix": [
            "print(6roundeds)"
        ],
        "body": [
            "def fstr(x): return f'{x:.10f}'",
            ""
        ],
        "description": [
            "rounded"
        ]
    },
    "Graph二部マッチング": {
        "prefix": [
            "Lib_G_二部マッチング_bipartitematching"
        ],
        "body": [
            "",
            "from collections import deque",
            "",
            "##二部マッチング",
            "",
            "class BipartileMatching:",
            "    ##L2R:Lから見たRのマッチングを記録",
            "    ##R2L:Rから見たLのマッチングを記録",
            "    ##backpath:L側に逆辺が張られている場合の辿る先",
            "    ##root:逆辺を考慮したLの始点を記録",
            "",
            "    def __init__(self, L, R):",
            "        self.L = L",
            "        self.R = R",
            "        self.G = [[] for _ in range(L)]",
            "        self.L2R = None",
            "        self.R2L = None",
            "",
            "    def add_edge(self, u, v):",
            "        self.G[u].append(v)",
            "",
            "    @property",
            "    def matching(self):",
            "        L = self.L",
            "        R = self.R",
            "        L2R = [-1] * L",
            "        R2L = [-1] * R",
            "        backpath = [-1] * L",
            "        root = [-1] * L",
            "        res, f = 0, True",
            "        while f:",
            "            f = False",
            "            q=deque()",
            "            for i in range(L):",
            "                ##まだマッチング対象が見つかっていなければ",
            "                ##iを始点としてキューに追加",
            "                if L2R[i] == -1:",
            "                    root[i] = i",
            "                    q.append(i)",
            "",
            "            while q:",
            "                s = q.popleft()",
            "                ##逆辺を辿った先のrootが-1になっていればcontinue",
            "                if ~L2R[root[s]]: continue",
            "",
            "                ##始点から接続されている辺を全探索する",
            "                for t in self.G[s]:",
            "                    if R2L[t] == -1:",
            "                        ##逆辺が存在する場合は辿っていく",
            "                        while t != -1:",
            "                            R2L[t] = s",
            "                            L2R[s], t = t , L2R[s]",
            "                            s = backpath[s]",
            "                        f = True",
            "                        res += 1",
            "                        break",
            "",
            "                    ##仮のtに対するマッチング候補の情報を更新しキューに追加する",
            "                    temps = R2L[t]",
            "                    if ~backpath[temps]: continue",
            "                    backpath[temps] = s",
            "                    root[temps] = root[s]",
            "                    q.append(temps)",
            "",
            "            ##更新があれば逆辺・始点情報を初期化する",
            "            if f:",
            "                backpath = [-1] * L",
            "                root = [-1] * L",
            "        self.L2R = L2R",
            "        self.R2L = R2L",
            "        return res",
            "",
            "#################################",
            "n, m, e = map(int, input().split())",
            "BM = BipartileMatching(n, m)",
            "for i in range(e):",
            "    x, y = map(int, input().split())",
            "    BM.add_edge(x, y)",
            "print(BM.matching)",
            ""
        ],
        "description": [
            "Graph二部マッチング"
        ]
    },
    "ユニオンファインド部分永続": {
        "prefix": [
            "Lib_G_unionfindPP"
        ],
        "body": [
            "class UnionFindPP:",
            "    def __init__(self,N):",
            "        INF = 10**9",
            "        self.now = 0",
            "        self.N = 0",
            "        self.parent = [-1 for i in range(N)]",
            "        self.time = [INF for i in range(N)]",
            "        self.num = [[(0,1)] for i in range(N)]",
            "",
            "    def find(self,t,x):",
            "        '''",
            "        version:tにおけるxの根を見つける",
            "        t (any) : version",
            "        x (int) : 要素",
            "        return : int : 根",
            "        '''",
            "        while self.time[x] <= t:",
            "            x = self.parent[x]",
            "        return x",
            "",
            "    def unite(self,x,y):",
            "        '''",
            "        x,yをつなげる",
            "        x (int) : 要素",
            "        y (int) : 要素",
            "        '''",
            "        self.now += 1",
            "        x = self.find(self.now,x)",
            "        y = self.find(self.now,y)",
            "",
            "        if x == y:",
            "            return",
            "",
            "        if self.parent[x] > self.parent[y]:",
            "            x,y = y,x",
            "",
            "        self.parent[x] += self.parent[y]",
            "        self.parent[y] = x",
            "        self.time[y] = self.now",
            "        self.num[x].append((self.now,-self.parent[x]))",
            "",
            "    def same(self,t,x,y):",
            "        '''",
            "        version:tにおけるx,yが同じかどうかO(logN)",
            "        t (any) : version",
            "        x (int) : 要素",
            "        y (int) : 要素",
            "        return : bool : 同じかどうか",
            "        '''",
            "        return self.find(t,x) == self.find(t,y)",
            "",
            "    def size(self,t,x):",
            "        '''",
            "        version:tにおける要素xが含まれる集合の大きさ",
            "        t (any) : version",
            "        x (int) : 要素",
            "        return : int :集合の大きさ",
            "        '''",
            "        x = self.find(t,x)",
            "        numx = self.num[x]",
            "        ok = 0",
            "        ng = len(numx)",
            "        while (ng-ok > 1):",
            "            mid = (ok+ng)>>1",
            "            if numx[mid][0] <= t:",
            "                ok = mid",
            "            else:",
            "                ng = mid",
            "",
            "        return numx[ok][1]",
            "",
            "    def time_join(self, x, y):",
            "        '''",
            "        x (int) : 要素",
            "        y (int) : 要素",
            "        return : int :同一のグループとなった時",
            "        '''",
            "        upper = self.now",
            "        if not self.same(upper, x, y): return -1",
            "        lower = 0",
            "        while upper - lower > 1:",
            "            mid = (upper+lower)//2",
            "            if self.same(mid, x, y):",
            "                upper = mid",
            "            else:",
            "                lower = mid",
            "        return upper",
            "",
            "",
            "n, m = map(int, input().split())",
            "uf = UnionFindPP(n)",
            "",
            "for _ in range(m):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    uf.unite(a, b)",
            "",
            "q = int(input())",
            "for _ in range(q):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    print(uf.time_join(a, b))",
            "# https://atcoder.jp/contests/code-thanks-festival-2017/tasks/code_thanks_festival_2017_h",
            ""
        ],
        "description": [
            "ユニオンファインド部分永続"
        ]
    },
    "素数判定・出力": {
        "prefix": [
            "Lib_N_prime_素数"
        ],
        "body": [
            "",
            "##############################",
            "# 素数判定 O(n**0.5)",
            "##############################",
            "def is_prime(n:int) -> bool:",
            "    if n in {0, 1}: return False",
            "    if n == 2: return True",
            "    if n % 2 == 0: return False",
            "    for i in range(3, int(n**0.5)+1, 2):",
            "        if n % i == 0: return False",
            "    return True",
            "",
            "#####################",
            "print(10, is_prime(10))",
            "print(31, is_prime(31))",
            "#####################",
            "",
            "",
            "##############################",
            "# 素数出力 O(n**0.5)",
            "# n <= 10**5",
            "##############################",
            "def get_primes(n:int) -> list:",
            "# n以下の素数列挙",
            "    n += 1",
            "    IsPrime = [True] * n",
            "    IsPrime[0], IsPrime[1] = False, False",
            "    for p in range(n):",
            "        if not IsPrime[p]: continue",
            "        for j in range(p*2, n, p):",
            "            IsPrime[j] = False",
            "    ret = [p for p in range(n) if IsPrime[p]]",
            "    return ret",
            "",
            "",
            "##############################",
            "# n以下の素数の数 O(n**0.5)",
            "# n ～ 10**10 for python3",
            "# n ～ 10**12 for pypy3",
            "##############################",
            "def count_primes(n:int):",
            "    if n < 2:",
            "        return 0",
            "    v = int(n ** 0.5) + 1",
            "    smalls = [i // 2 for i in range(1, v + 1)]",
            "    smalls[1] = 0",
            "    s = v // 2",
            "    roughs = [2 * i + 1 for i in range(s)]",
            "    larges = [(n // (2 * i + 1) + 1) // 2 for i in range(s)]",
            "    skip = [False] * v",
            "",
            "    pc = 0",
            "    for p in range(3, v):",
            "        if smalls[p] <= smalls[p - 1]:",
            "            continue",
            "",
            "        q = p * p",
            "        pc += 1",
            "        if q * q > n:",
            "            break",
            "        skip[p] = True",
            "        for i in range(q, v, 2 * p):",
            "            skip[i] = True",
            "",
            "        ns = 0",
            "        for k in range(s):",
            "            i = roughs[k]",
            "            if skip[i]:",
            "                continue",
            "            d = i * p",
            "            larges[ns] = larges[k] - \\",
            "                (larges[smalls[d] - pc] if d < v else smalls[n // d]) + pc",
            "            roughs[ns] = i",
            "            ns += 1",
            "        s = ns",
            "        for j in range((v - 1) // p, p - 1, -1):",
            "            c = smalls[j] - pc",
            "            e = min((j + 1) * p, v)",
            "            for i in range(j * p, e):",
            "                smalls[i] -= c",
            "",
            "    for k in range(1, s):",
            "        m = n // roughs[k]",
            "        s = larges[k] - (pc + k - 1)",
            "        for l in range(1, k):",
            "            p = roughs[l]",
            "            if p * p > m:",
            "                break",
            "            s -= smalls[m // p] - (pc + l - 1)",
            "        larges[0] -= s",
            "",
            "    return larges[0]",
            "",
            "",
            "##############################",
            "# n!が素数pで何回割れるか O(logn)",
            "# legendre(n, p)",
            "##############################",
            "def legendre(n, p):",
            "    ret = 0",
            "    while n > 0:",
            "        ret += n // p",
            "        n //= p",
            "    return ret",
            ""
        ],
        "description": []
    },
    "尺取り": {
        "prefix": [
            "Lib_A_尺取り"
        ],
        "body": [
            "######################################################################",
            "# The Smallest Window I",
            "# 長さNの数列a1,a2,a3,...,aNと整数Sが与えられます。",
            "# 要素の総和がS以上となる連続する部分列のうち、",
            "# 最も短いものの長さ（smallest window length）を求めてください。",
            "# ただし、そのような部分列が存在しない場合は 0 と報告してください。",
            "# https://onlinejudge.u-aizu.ac.jp/problems/DSL_3_A",
            "######################################################################",
            "",
            "N, S = map(int, input().split())",
            "A = list(map(int, input().split()))",
            "INF = 2*N",
            "ret = INF",
            "",
            "l, r, now = 0, 0, 0",
            "while True:",
            "    while r < N and now < S:",
            "        now += A[r]",
            "        r += 1",
            "    if now >=S:",
            "        ret = min(ret, r - l)",
            "        now -= A[l]",
            "        l += 1",
            "    else:",
            "        break",
            "",
            "if ret == INF:",
            "    print(0)",
            "else:",
            "    print(ret)",
            "",
            "######################################################################",
            "# The Smallest Window II",
            "# 長さNの数列a1,a2,a3,...,aNと整数Kが与えられます。",
            "# 1からKまでの整数1, 2, ...,Kをすべて含む連続する部分列のうち、",
            "# 最も短いものの長さ（smallest window length）を求めてください。",
            "# ただし、そのような部分列が存在しない場合は 0 と報告してください。",
            "# https://onlinejudge.u-aizu.ac.jp/problems/DSL_3_B",
            "######################################################################",
            "",
            "N, K = map(int, input().split())",
            "A = list(map(int, input().split()))",
            "now_each_counter = [0] * (K+1)",
            "now_total_counter = 0",
            "l, r = 0, 0",
            "INF = 2*N",
            "ret = INF",
            "while l < N:",
            "    while r < N and now_total_counter < K:",
            "        ar = A[r]",
            "        if ar <= K:",
            "            now_each_counter[ar] += 1",
            "            if now_each_counter[ar] == 1:",
            "                now_total_counter += 1",
            "        r += 1",
            "    if now_total_counter == K:",
            "        ret = min(ret, r-l)",
            "    al = A[l]",
            "    if al <= K:",
            "        now_each_counter[al] -= 1",
            "        if now_each_counter[al] == 0:",
            "            now_total_counter -= 1",
            "    l += 1",
            "if ret == INF:",
            "    print(0)",
            "else:",
            "    print(ret)",
            "",
            "######################################################################",
            "# The Number of Windows",
            "# 長さNの数列a1,a2,a3,...,aNが与えられます。",
            "# また, 次のような質問がQ個与えられます。",
            "# i個目の質問では,整数x,iが与えられます。",
            "# 各質問について1<=l<=r<=Nかつsum(al,al+1,...,ar-1,ar) <= xiを満たす整数",
            "# (l,r)の組の個数を求めてください。",
            "# https://onlinejudge.u-aizu.ac.jp/problems/DSL_3_C",
            "######################################################################",
            "N, Q = map(int, input().split())",
            "A = list(map(int, input().split()))",
            "X = list(map(int, input().split()))",
            "",
            "def solv(x):",
            "    l, r, ret = 0, 0, 0",
            "    now = 0",
            "    while l < N:",
            "        while r < N and now <= x:",
            "            now += A[r]",
            "            r += 1",
            "        if now > x:",
            "            r -= 1",
            "            now -= A[r]",
            "        ret += r - l",
            "        now -= A[l]",
            "        l += 1",
            "    return ret",
            "",
            "for xi in X:",
            "    print(solv(xi))",
            "",
            "######################################################################",
            "# Sliding Minimum Element",
            "# 長さNの数列a1,a2,a3,...,aNと整数Lが与えられます。",
            "# 長さLの連続する部分列すべてについて、",
            "# 各部分列の中の最小の要素を先頭から順番に報告してください。",
            "# 例えば、数列が{1,7,7,4,8,1,6} で、L が 3 の場合、",
            "# 長さLの部分列は{1,7,7},{7,7,4},{7,4,8},{4,8,1},{8,1,6}となりますが、",
            "# それぞれの部分列の最小値となる 1, 4, 4, 1, 1 を先頭の方から順番に出力してください。",
            "# https://onlinejudge.u-aizu.ac.jp/problems/DSL_3_D",
            "######################################################################",
            "from heapq import heapify, heappop, heappush",
            "N, L = map(int, input().split())",
            "A = list(map(int, input().split()))",
            "ret = []",
            "que = []",
            "heapify(que)",
            "for i, ai in enumerate(A):",
            "    heappush(que, (ai, i))",
            "    if i < L-1: continue",
            "    while que[0][1] <= i - L:",
            "        heappop(que)",
            "    ret.append(que[0][0])",
            "print(*ret)",
            ""
        ],
        "description": [
            "Lib_尺取り"
        ]
    },
    "Graph最小費用流": {
        "prefix": [
            "Lib_GD_最小費用流_mincostflow"
        ],
        "body": [
            "",
            "",
            "# 最小費用流問題",
            "# 各辺に容量とコストが設定されたフローネットワークにおいて、",
            "# 始点s から終点t まで流量F のフローを流すための最小コストを求める",
            "# Minimum Cost Flow : O(FElogV)",
            "# ダイクストラ",
            "# https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_6_B",
            "from heapq import heappush, heappop",
            "class MinCostFlow:",
            "    def __init__(self, n:int) -> None:",
            "        self.n = n",
            "        self.ln = n.bit_length()",
            "        self.g = [[] for i in range(n)]",
            "        self.INF = float('inf')",
            "",
            "",
            "    def add_edge(self, fm: int, to: int, cap: int, cost: int):",
            "        # cap: 容量, to/fm:行き先, rev:相方の辺, cost:",
            "        forward = [cap, to, cost, len(self.g[to])]",
            "        backward = [0, fm, -cost, len(self.g[fm])]",
            "        self.g[fm].append(forward)",
            "        self.g[to].append(backward)",
            "",
            "",
            "    def min_cost_flow(self, s: int, t: int, f: int):",
            "        flow = 0",
            "        prev_v = [-1] * self.n",
            "        prev_e = [-1] * self.n",
            "        while f > 0:",
            "            h = [0] * self.n",
            "            dist = [self.INF]*self.n",
            "            dist[s] = 0",
            "            next_q = []",
            "            heappush(next_q, s)",
            "            while next_q:",
            "                x = heappop(next_q)",
            "                d, v = x >> self.ln, x % (1 << self.ln)",
            "                if dist[v] < d: continue",
            "                for i, (_cap, nv, c, r) in enumerate(self.g[v]):",
            "                    if _cap > 0 and dist[nv] > dist[v] + c + h[v] - h[nv]:",
            "                        dist[nv] = dist[v] + c + h[v] - h[nv]",
            "                        prev_v[nv] = v",
            "                        prev_e[nv] = i",
            "                        heappush(next_q, (dist[nv] << self.ln) + nv)",
            "            if dist[t] == self.INF:",
            "                return -1",
            "",
            "            d, v = f, t",
            "            while v != s:",
            "                d = min(d, self.g[prev_v[v]][prev_e[v]][0])",
            "                v = prev_v[v]",
            "",
            "            f -= d",
            "            flow += d * dist[t]",
            "            v = t",
            "",
            "            while v != s:",
            "                self.g[prev_v[v]][prev_e[v]][0] -= d",
            "                rev = self.g[prev_v[v]][prev_e[v]][3]",
            "                self.g[v][rev][0] += d",
            "                v = prev_v[v]",
            "",
            "        return flow",
            "",
            "",
            "#############",
            "n, m, f = map(int, input().split())",
            "mf = MinCostFlow(n)",
            "for _ in range(m):",
            "    u, v, c, d = map(int, input().split())",
            "    mf.add_edge(u, v, c, d)",
            "",
            "print(mf.min_cost_flow(0, n-1, f))",
            ""
        ],
        "description": [
            "Graph最小費用流"
        ]
    },
    "reverse=True": {
        "prefix": [
            "reverse=True"
        ],
        "body": [
            "reverse=True"
        ],
        "description": [
            "ソートでのリバース"
        ]
    },
    "sort(key=itemgetter": {
        "prefix": [
            "sort(key=l"
        ],
        "body": [
            "sort(key=lambda x: x[1])"
        ],
        "description": [
            "itemgetterソート"
        ]
    },
    "defaultdict": {
        "prefix": [
            "dd=defaultdict"
        ],
        "body": [
            "dd = defaultdict($int)"
        ],
        "description": [
            "デフォルトディクショナリ"
        ]
    },
    "sort_by_function": {
        "prefix": [
            "Lib_sort_by_function"
        ],
        "body": [
            "from functools import cmp_to_key",
            "def sort_by_function(x):",
            "    \"\"\"比較関数を設定してソート",
            "    \"\"\"",
            "    def compare(item1, item2):",
            "        \"\"\" \"小さい\" -> -1",
            "            \"等しい\" -> 0",
            "            \"大きい\" -> 1",
            "        \"\"\"",
            "        # 以下はx, yが与えられてy/xで比較する例",
            "        # y1/x1 < y2/x2",
            "        # -> y1*x2 < y2*x1",
            "        x1, y1 = item1",
            "        x2, y2 = item2",
            "",
            "        if y1*x2 < y2*x1:",
            "            return -1",
            "        elif y1*x2 > y2*x1:",
            "            return 1",
            "        else:",
            "            return 0",
            "    x.sort(key=cmp_to_key(compare))",
            "    return x",
            "########################################",
            "a = [[1, 2], [2, 6] , [3, 6], [4, 5], [5, 7]]",
            "print(a)",
            "a = sort_by_function(a)",
            "print(a)",
            "# [[4, 5], [5, 7], [1, 2], [3, 6], [2, 6]]",
            "#   1.25    0.714    0.5     0.5    0.333"
        ],
        "description": [
            "比較関数使って並べ替え"
        ]
    },
    "順列・組み合わせ": {
        "prefix": [
            "itertools",
            "Lib_順列・組み合わせ"
        ],
        "body": [
            "P = list(permutations(range(n), r))   # 順列(nPr)",
            "C = list(combinations(range(n), r))   # 組み合わせ(nCr)",
            "CR = list(combinations_with_replacement(range(n), r))  # 重複も許容した組み合わせ(nHr=n+r-1Cr)",
            "PN = list(product(range(n), repeat=r)) # 重複順列(n**r)",
            "T = [[1, 2],[3, 4, 5, 6],[7, 8, 9]]",
            "PT = list(product(*T))"
        ],
        "description": [
            "順列・組み合わせ"
        ]
    },
    "区間カウント": {
        "prefix": [
            "Lib_区間カウント"
        ],
        "body": [
            "def count_intervals(a:list, x)->int:",
            "    dm = a + [float('inf')]",
            "    ret = 0",
            "    is_yes = False",
            "    for ai in dm:",
            "        if ai == x:",
            "            if is_yes: continue",
            "            is_yes = True",
            "        else:",
            "            if not is_yes: continue",
            "            is_yes = False",
            "            ret += 1",
            "",
            "    return ret",
            "# A=[0, 0, 1, 1, 1, 1, 0, 1, 1, 1]",
            "# x=1 の区間がいくつあるか ans = 2"
        ],
        "description": [
            "区間カウント",
            "A=[0, 0, 1, 1, 1, 1, 0, 1, 1, 1]",
            "x=1 の区間がいくつあるか ans = 2"
        ]
    },
    "direc": {
        "prefix": [
            "direc"
        ],
        "body": [
            "direc = {(1, 0), (-1, 0), (0, 1), (0, -1)}",
            "direc = {(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1) (-1, 1), (-1, -1)}",
            "",
            "for dh, dw in direc:",
            "    nh, nw = ch + dh, cw + dw",
            "    if not (0 <= nh < h and 0 <= nw < w): continue"
        ],
        "description": [
            "direc"
        ]
    },
    "memo": {
        "prefix": [
            "memo_lru_chache"
        ],
        "body": [
            "from functools import lru_cache",
            "@lru_chache()"
        ],
        "description": [
            "memo"
        ]
    },
    "Mo'sAlgorythm#": {
        "prefix": [
            "Lib_Mos_モアルゴリズム"
        ],
        "body": [
            "",
            "# A:リスト n = 10**5",
            "# Q: l, r q = 10**5",
            "",
            "class _Mo:",
            "    def __init__(self, N:int):",
            "        self.N=N",
            "        self.query = []",
            "        self.Q = 0",
            "        self.shift = 20",
            "    def add_query(self, l:int, r:int): # [l,r)",
            "        self.query.append((l,r))",
            "        self.Q += 1",
            "    def solve(self):",
            "        assert max(self.N, self.Q)<(1<<self.shift)",
            "        block_size = self.N // (min(self.N, int(len(self.query)**0.5+0.5)))",
            "        query = [None] * self.Q",
            "        for i,(l,r) in enumerate(self.query):",
            "            L = l // block_size",
            "            query[i] = (L<<(2*self.shift))+((r if L&1 else -r)<<self.shift) + i",
            "        query.sort()",
            "        L=R=0",
            "        ret = [0]*self.Q",
            "        mask=(1<<self.shift)-1",
            "        for q in query:",
            "            i = q&mask",
            "            l,r=self.query[i]",
            "            while l<L:",
            "                L-=1;",
            "                self.add_left(L)",
            "            while L<l:",
            "                self.remove_left(L)",
            "                L+=1",
            "            while R<r:",
            "                self.add_right(R)",
            "                R+=1",
            "            while r<R:",
            "                R-=1",
            "                self.remove_right(R)",
            "            ret[i] = self.get_state()",
            "        return ret",
            "",
            "N,Q=map(int,input().split())",
            "A=list(map(int,input().split()))",
            "",
            "class Mo(_Mo):",
            "    def __init__(self, N):",
            "        super().__init__(N)",
            "        self.value = 0",
            "        self.count = [0] * (max(A)+1)",
            "    def get_state(self):",
            "        return self.value",
            "    def add_left(self, i):",
            "        a = A[i]",
            "        x = self.count[a]",
            "        self.count[a] += 1",
            "#        self.value += (x+1)*x*(x-1) // 6 - x*(x-1)*(x-2) // 6",
            "        self.value += x*(x-1) // 2",
            "    def remove_left(self, i):",
            "        a = A[i]",
            "        x = self.count[a]",
            "        self.count[a] -= 1",
            "#        self.value += (x-1)*(x-2)*(x-3) // 6 - x*(x-1)*(x-2) // 6",
            "        self.value -= (x-1)*(x-2)//2",
            "",
            "    add_right = add_left",
            "    remove_right = remove_left",
            "",
            "",
            "mo = Mo(N)",
            "for _ in range(Q):",
            "    l,r=map(int,input().split())",
            "    mo.add_query(l-1,r)",
            "ans = mo.solve()",
            "",
            "print(\"\\n\".join(map(str,ans)))",
            "",
            ""
        ],
        "description": [
            "Mo'sAlgorythm#"
        ]
    },
    "三分探索": {
        "prefix": [
            "Lib_A_三分探索"
        ],
        "body": [
            "#######################",
            "# ムーアの法則",
            "# 三分探索/黄金分割探索",
            "#######################",
            "",
            "def f(x):",
            "    return x**2",
            "",
            "d = 0.000000001",
            "low, high = 0, 1000",
            "",
            "# 分割割合",
            "alp = 1/3           #三分探索",
            "alp = (3-5**0.5)/2  #黄金分割探索",
            "",
            "while abs(f(low) - f(high)) > d:",
            "    l_ = high * alp + (1-alp) * low",
            "    h_ = high * (1-alp) + alp * low",
            "    if f(h_) < f(l_):",
            "        low = l_",
            "    else:",
            "        high = h_",
            "print(f(low))",
            "",
            "",
            "",
            "#######################",
            "# 内包円",
            "# 三分探索",
            "# https://atcoder.jp/contests/abc151/tasks/abc151_f",
            "# 平面上の N 個の点 (xi, yi) が与えられます。",
            "# これら全てを内部または周上に含む円の半径の最小値を求めてください。",
            "#######################",
            "",
            "n = int(input())",
            "pt = [tuple(map(int, input().split())) for i in range(n)]",
            "",
            "def f(x, y):",
            "    # (x, y)を与えたときに、各点との距離の最大値",
            "    return max([((x-u)**2 + (y-v)**2)**0.5 for u, v in pt])",
            "",
            "d = 0.0000001",
            "",
            "def g(x):",
            "    low, high = 0, 1000",
            "    for i in range(80):",
            "        l_ = (high+2*low)/3",
            "        h_ = (high*2+low)/3",
            "        if f(x, h_)<f(x, l_):",
            "            low = l_",
            "        else:",
            "            high = h_",
            "    return f(x, low)",
            "",
            "",
            "low, high = 0, 1000",
            "for i in range(80):",
            "    l_ = (high+2*low)/3",
            "    h_ = (high*2+low)/3",
            "    if g(h_)<g(l_):",
            "        low = l_",
            "    else:",
            "        high = h_",
            "",
            "print(g(low))",
            ""
        ],
        "description": [
            "三分探索"
        ]
    },
    "トポロジカルソート木": {
        "prefix": [
            "Lib_GT_木トポロジカルソート_topologicalsort"
        ],
        "body": [
            "# トポロジカルソート",
            "# 有向非巡回グラフ（DAG）の各ノードを順序付けして、どのノードもその出力辺の先のノードより前にくるように並べることである。",
            "# 有向非巡回グラフは必ずトポロジカルソートすることができる。",
            "from collections import deque",
            "",
            "class topological_sort:",
            "    def __init__(self, n:int, G) -> None:",
            "        self.n = n",
            "        self.ts = []            # トポロジカルソート",
            "        self.parents = [-1] * n # 親 -1は根",
            "        self.G = G              # 辺",
            "        self.childrens = G.copy() # 辺",
            "",
            "",
            "    def build(self, root):",
            "        que = deque([root])",
            "        self.ts = []            # トポロジカルソート",
            "        while que:",
            "            x = que.popleft()",
            "            self.ts.append(x)",
            "            for nx in self.G[x]:",
            "                if nx == self.parents[x]: continue",
            "                self.parents[nx] = x",
            "                self.childrens[nx].remove(x)",
            "                que.append(nx)",
            "",
            "#########################################",
            "# n, m = map(int, input().split())",
            "n = int(input())",
            "G = [[] for _ in range(n)]",
            "m = n",
            "for _ in range(m):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    w = 0",
            "    G[a].append((b, w))",
            "",
            "ts = topological_sort(n, G)",
            "",
            "ts.build(0)",
            "",
            "print(ts.ts)",
            "print(ts.parents)",
            "",
            "# 木dp  #ノードに1を置いて葉から合計する",
            "dp = [1] * n",
            "for i in ts.ts[::-1]:  #葉から",
            "    for j in ts.childrens[i]:",
            "        dp[i] += dp[j]",
            "",
            ""
        ],
        "description": [
            "木トポロジカルソート topologicalsort"
        ]
    },
    "ワーシャルフロイド法": {
        "prefix": [],
        "body": [],
        "description": []
    },
    "全頂点間最短路": {
        "prefix": [],
        "body": [],
        "description": []
    },
    "d[i][j]は2頂点間i, j間の移動コストを格納, Mは頂点数": {
        "prefix": [],
        "body": [],
        "description": []
    },
    "O(N^3)": {
        "prefix": [
            "Lib_SP_最短経路探索_warshall"
        ],
        "body": [
            "import copy",
            "",
            "class warshall_floyd:",
            "    def __init__(self, n:int) -> None:",
            "        self.INF = float(\"inf\")",
            "        self.n = n",
            "        self.d = [[self.INF] * n for _ in range(n)]",
            "        #d[u][v] : 辺uvのコスト(存在しないときはinf)",
            "        for i in range(n):",
            "            self.d[i][i] = 0 #自身のところに行くコストは０",
            "",
            "",
            "",
            "    def build(self):",
            "        n = self.n",
            "        wf = copy.deepcopy(self.d)",
            "        for k in range(n):",
            "            for i in range(n):",
            "                for j in range(n):",
            "                    wf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j])",
            "",
            "        self.wf = wf #wf[i][j]に頂点i, j間の最短距離を格納",
            "",
            "",
            "    def add_edge(self, fm, to, cost):",
            "        self.d[fm][to] = cost",
            "",
            "",
            "    # 負値閉路検索",
            "    @property",
            "    def is_neg_cycle(self) -> bool:",
            "        for i in range(self.n):",
            "            if self.wf[i][i] < 0:",
            "                return True",
            "        return False",
            "",
            "",
            "    # 経路復元",
            "    def path(self, s, g):",
            "        ret = []",
            "        if s == g or self.wf[s][g] == self.INF:",
            "            return ret",
            "        cur = s",
            "        while cur!=g:",
            "            for nxt in range(self.n):",
            "                if nxt==cur or nxt==s: continue",
            "                if self.d[cur][nxt] + self.wf[nxt][g] == self.wf[cur][g]:",
            "                    ret.append((cur, nxt))",
            "    #                ret.append((nxt, cur))",
            "                    cur = nxt",
            "                    break",
            "        return ret",
            "",
            "##############################",
            "",
            "n, m = map(int,input().split()) #N:頂点数 m:辺の数",
            "",
            "WF = warshall_floyd(n)",
            "",
            "for _ in range(m):",
            "    _u, _v, _w = map(int,input().split())",
            "    _u -= 1; _v -= 1",
            "    WF.add_edge(_u, _v, _w)",
            "    WF.add_edge(_v, _u, _w)",
            "",
            "WF.build()",
            "",
            "print(WF.path(0, n-1))",
            ""
        ],
        "description": []
    },
    "約数列挙": {
        "prefix": [
            "Lib_N_約数列挙"
        ],
        "body": [
            "##############################",
            "# 約数列挙 O(n**0.5)",
            "# returns sorted list",
            "##############################",
            "def make_divisors(n:int) -> list:",
            "    lower_divisors, upper_divisors = [], []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i != 0: i += 1; continue",
            "        lower_divisors.append(i)",
            "        j = n // i",
            "        if i != j: upper_divisors.append(j)",
            "    return lower_divisors + upper_divisors[::-1]",
            "",
            "#####################",
            "print(make_divisors(10))",
            "#####################",
            "",
            "",
            "##############################",
            "# n!が素数pで何回割れるか O(logn)",
            "# legendre(n, p)",
            "##############################",
            "def legendre(n, p):",
            "    ret = 0",
            "    while n > 0:",
            "        ret += n // p",
            "        n //= p",
            "    return ret",
            "",
            "    "
        ],
        "description": []
    },
    "Lib_math": {
        "prefix": [
            "Lib_math_最大公約数_三角関数",
            "import math"
        ],
        "body": [
            "import math",
            "print(math.sin(math.pi/4))",
            "print(math.cos(math.pi/4))",
            "print(math.tan(math.pi/4))",
            "# 度→radian",
            "math.radians(180)",
            "# radian→度",
            "math.degrees(3.1415)",
            "",
            "print(math.gcd(x, y))",
            "def lcm(x, y): return x * y // math.gcd(x, y)",
            ""
        ],
        "description": [
            "mathのライブラリ"
        ]
    },
    "Lib_decimal": {
        "prefix": [
            "Lib_四捨五入_Decimal"
        ],
        "body": [
            "",
            "pypyで使っちゃダメ！！！！！",
            "from decimal import Decimal",
            "x, y, r = map(Decimal, input().split())",
            "f = 123.456",
            "fd = Decimal(str(f))",
            "fr = fd.quantize(Decimal('0'), rounding=ROUND_HALF_UP)  #123",
            "fr = fd.quantize(Decimal('0.1'), rounding=ROUND_HALF_UP)#123.5"
        ],
        "description": [
            "四捨五入が正しくできるツール",
            "Decimal で扱う"
        ]
    },
    "Lib_math_複素数": {
        "prefix": [
            "Lib_math_複素数"
        ],
        "body": [
            "import cmath",
            "",
            "z1 = 5 + 13j",
            "a, b = 5, 13",
            "z2 = complex(a, b)",
            "",
            "print(z1.real)",
            "print(z1.imag)",
            "",
            "",
            "# 極座標表示",
            "r, theta = cmath.polar(z1)",
            "",
            "# 90度回転",
            "print(cmath.rect(1, cmath.pi/2))",
            "# (6.123233995736766e-17+1j)",
            "",
            "# 共役数",
            "print(z2.conjugate())",
            "# (5-13j)",
            ""
        ],
        "description": [
            "Lib_複素数"
        ]
    },
    "Lib_sort_by_function": {
        "prefix": [
            "Lib_sort_by_function"
        ],
        "body": [
            "",
            "# https://atcoder.jp/contests/abc308/tasks/abc308_c",
            "",
            "class ordobj:",
            "    def __init__(self, x):",
            "        self.a, self.b, self.i = x",
            "",
            "    def __lt__(self, other):",
            "        if self.a * (other.a+other.b) < other.a * (self.a+self.b):",
            "            return True",
            "        if self.i > other.i:",
            "            return True",
            "        return False",
            "",
            "    def __repr__(self):",
            "        return f'{self.a} {self.b} {self.i}'",
            "",
            ""
        ],
        "description": [
            "Lib_sort_by_function"
        ]
    },
    "LCA": {
        "prefix": [
            "Lib_GT_最小共通祖先_LCA"
        ],
        "body": [
            "from collections import deque",
            "class Lca:",
            "    \"\"\"Lowest Common Ancestor",
            "",
            "    u, vの共通の親",
            "    ダブリング p[i][v] = vの2^i個 親",
            "",
            "    Parameters",
            "    ----------",
            "    n : int",
            "        nodeの数",
            "    G : graph",
            "    r : root",
            "    \"\"\"",
            "    def __init__(self, n: int, G, r:int) -> None:",
            "        self.n = n",
            "        self.root = r",
            "        self.edges = G",
            "        self.lv = n.bit_length()",
            "        self.p = [[None] * n for _ in range(self.lv)]",
            "        self._depth = [None] * n",
            "        self._costs = [None] * n",
            "        self.construct()",
            "",
            "    def construct(self):",
            "        \"\"\"深さと親の設定とダブリング",
            "        \"\"\"",
            "        # 深さと親の設定",
            "        r = self.root",
            "        q = deque([r])",
            "        self._depth[r], self._costs[r], self.p[0][r] = 0, 0, r",
            "        while q:",
            "            cur = q.popleft()",
            "            dep = self._depth[cur]",
            "            dis = self._costs[cur]",
            "            for nxt in self.edges[cur]:",
            "                if type(nxt) != int:",
            "                    nxt, cost = nxt",
            "                else:",
            "                    cost = 1",
            "                if self.p[0][nxt] != None: continue",
            "                q.append(nxt)",
            "                self._depth[nxt], self._costs[nxt], self.p[0][nxt] = dep + 1, dis + cost, cur",
            "        # ダブリング",
            "        for i in range(1, self.lv):",
            "            for v in range(self.n):",
            "                self.p[i][v] = self.p[i-1][self.p[i-1][v]]",
            "",
            "",
            "    def la(self, x, h):",
            "        \"\"\"h代前祖先",
            "",
            "        \"\"\"",
            "        for i in range(self.lv)[::-1]:",
            "            if h >= 1 << i:",
            "                x = self.p[i][x]",
            "                h -= 1 << i",
            "        return x",
            "",
            "",
            "    def lca(self, u, v):",
            "        \"\"\"共通祖先",
            "",
            "        Parameters",
            "        ----------",
            "        u, v : node",
            "            ノード",
            "",
            "        Returns",
            "        -------",
            "        int",
            "            共通祖先のノード",
            "        \"\"\"",
            "        # u,vの高さを合わせる",
            "        if self._depth[u] < self._depth[v]: u, v = v, u",
            "        u = self.la(u, self._depth[u] - self._depth[v])",
            "        if u == v: return u",
            "        # u, vのギリギリ合わない高さまで昇る",
            "        for i in range(self.lv)[::-1]:",
            "            if self.p[i][u] != self.p[i][v]:",
            "                u = self.p[i][u]",
            "                v = self.p[i][v]",
            "        return self.p[0][u]",
            "",
            "",
            "    def distance(self, u, v):",
            "        lca = self.lca(u, v)",
            "        return self._depth[u] + self._depth[v] - 2 * self._depth[lca]",
            "",
            "",
            "    def cost(self, u, v):",
            "        lca = self.lca(u, v)",
            "        return self._costs[u] + self._costs[v] - 2 * self._costs[lca]",
            "",
            "",
            "    def jump(self, u, v, i):",
            "        \"\"\"",
            "        u -> vへのパスのk番目の頂点",
            "        \"\"\"",
            "        c = self.lca(u, v)",
            "        du = self._depth[u]",
            "        dv = self._depth[v]",
            "        dc = self._depth[c]",
            "",
            "        path_len = du - dc + dv - dc",
            "        if path_len < i:",
            "            return -1",
            "",
            "        if du - dc >= i:",
            "            return self.la(u, i)",
            "",
            "        return self.la(v, path_len - i)",
            "",
            "########################################",
            "",
            "n, q = map(int, input().split())",
            "G = [[] for _ in range(n)]",
            "for _ in range(n-1):",
            "    a, b = map(int, input().split())",
            "    G[a].append(b)",
            "    G[b].append(a)",
            "",
            "lca = Lca(n, G, 0)",
            "for _ in range(q):",
            "    u, v, k = map(int, input().split())",
            "    print(lca.jump(u, v, k))",
            ""
        ],
        "description": [
            "最小共通祖先"
        ]
    },
    "転倒数": {
        "prefix": [
            "Lib_A_転倒数"
        ],
        "body": [
            "# 転倒数",
            "# 配列中 i<j, ai>ajとなるものの個数",
            "# https://atcoder.jp/contests/chokudai_S001/tasks/chokudai_S001_j",
            "# ex: a = [3, 5, 2, 0, 4, 1]  -> 10",
            "# index: 0  1  2  3  4  5",
            "# a    : 3  5  2  0  4  1",
            "# bit_0:          1*        (a_0=3) 右側/反転数0",
            "# bit_1:          1     1*  (a_1=5) 右側/反転数0",
            "# bit_2:       1* 1     1   (a_2=2) 右側/反転数2",
            "# bit_3: 1*    1  1     1   (a_3=0) 右側/反転数3",
            "# bit_4: 1     1  1  1* 1   (a_4=4) 右側/反転数1",
            "# bit_5: 1  1* 1  1  1  1   (a_5=1) 右側/反転数4",
            "",
            "class BinaryIndexedTree:",
            "    # 初期化処理",
            "    def __init__(self, size):",
            "        self.size = size",
            "        self.dat = [0]*(size+1)",
            "        self.depth = size.bit_length()",
            "",
            "    def add(self, i, x):",
            "        i += 1",
            "        while i <= self.size:",
            "            self.dat[i] += x",
            "            i += i & -i # 更新すべき位置",
            "",
            "    def sum(self, r):",
            "        r += 1",
            "        ret = 0",
            "        while r>0:",
            "            ret += self.dat[r]",
            "            r -= r & -r # 加算すべき位置",
            "        return ret",
            "",
            "def compress(points:list) -> list:",
            "    pos = {}",
            "    sx = set(points)",
            "    for i, xi in enumerate(sorted(set(sx))):",
            "        pos[xi] = i",
            "    return [pos[xi] for xi in points]",
            "",
            "def inv_numbers(a: list) -> int:",
            "    _a = compress(a)",
            "    bit = BinaryIndexedTree(max(_a) + 2)",
            "    ret = 0",
            "    for i, ai in enumerate(_a):",
            "        ret += i - bit.sum(ai)  #aiの位置より右側の合計=見てきた総計i - 左側の合計 => 反転数",
            "        bit.add(ai, 1)          #aiの位置にメモ",
            "    return ret",
            "",
            "###################################",
            "",
            "n = int(input())",
            "a = list(map(int, input().split()))",
            "ret = inv_numbers(a)",
            "print(ret)"
        ],
        "description": [
            "Lib_転倒数"
        ]
    },
    "累積和": {
        "prefix": [
            "Lib_D_累積和_accum"
        ],
        "body": [
            "class Imos:",
            "    def __init__(self, h, w):",
            "        self.h = h",
            "        self.w = w",
            "        # 拡張grid生成",
            "        self.grid = [[0] * (w+1) for _ in range(h+1)]",
            "",
            "    def import_grid(self, grid):",
            "        for i in range(self.h):",
            "            for j in range(self.w):",
            "                self.grid[i+1][j+1] = grid[i][j]",
            "",
            "    def grid_add(self, i, j, ad):",
            "        # i, j is 0 index on self.grid",
            "        self.grid[i][j] += ad",
            "",
            "    def accumlate(self):",
            "        # 累積和",
            "        for i in range(self.h+1):",
            "            for j in range(1, self.w+1):",
            "                self.grid[i][j] += self.grid[i][j-1]",
            "        for j in range(self.w+1):",
            "            for i in range(1, self.h+1):",
            "                self.grid[i][j] += self.grid[i-1][j]",
            "",
            "    def count(self, x, y, u, v):",
            "        if not 0<= x <= u < self.h+1: return 0",
            "        if not 0<= y <= v < self.w+1: return 0",
            "        gd = self.grid",
            "        return gd[u][v] - gd[u][y] - gd[x][v] + gd[x][y]",
            "",
            "###############################################",
            "h, w, n = map(int, input().split())",
            "im = Imos(h, w)",
            "for _ in range(n):",
            "    a, b, c, d = map(int, input().split())",
            "    im.grid_add(a-1, b-1, 1)",
            "    im.grid_add(c, d, 1)",
            "    im.grid_add(a-1, d, -1)",
            "    im.grid_add(c, b-1, -1)",
            "",
            "im.accumlate()",
            "for i in range(im.h):",
            "    print(*im.grid[i][:-1])",
            ""
        ],
        "description": [
            "累積和"
        ]
    },
    "ベルマンフォード法": {
        "prefix": [
            "Lib_SP_最短経路探索_bellmanford"
        ],
        "body": [
            "# ベルマンフォード法",
            "# 重み付きグラフ関係により最短経路のリストを作る",
            "# 辺を繰り返しみて、最小化していく",
            "# |V|回更新するとで収束する/しなければ、負の閉路がある",
            "",
            "# https://atcoder.jp/contests/abc061/tasks/abc061_d",
            "",
            "def bellman_ford(st=0):",
            "    \"\"\"",
            "    n: グラフの頂点数",
            "    st: 始点",
            "    G[v] = [(w, cost), ...]: 頂点vからコストcostで到達できる頂点w",
            "    returns",
            "    dist or -1 if 閉路あり",
            "    \"\"\"",
            "",
            "    INF = float('INF')",
            "    dist = [INF] * n",
            "    dist[st] = 0",
            "    prev = [-1] * n",
            "    for _ in range(n):",
            "        update = False",
            "        for v, e in enumerate(G):",
            "            for t, cost in e:",
            "                if dist[v] == INF: continue",
            "                if dist[v] + cost >= dist[t]: continue",
            "                dist[t] = dist[v] + cost",
            "                prev[t] = v",
            "                update = True",
            "                upi = t",
            "        if not update: return dist  # prev",
            "    # 負閉路検出処理",
            "    dist[upi] = -INF",
            "    for _ in range(n):",
            "        update = False",
            "        for v, e in enumerate(G):",
            "            for t, cost in e:",
            "                if dist[v] == INF: continue",
            "                if dist[v] + cost >= dist[t]: continue",
            "                dist[t] = dist[v] + cost",
            "                update = True",
            "                upi = t",
            "        if not update: return dist",
            "    return -1",
            "",
            "######################################",
            "",
            "n, m = map(int, input().split())",
            "G = [[] for _ in range(n)]",
            "# 隣接リストの作成",
            "for _ in range(m):",
            "    _a, _b, _c = map(int, input().split())",
            "    _a -= 1; _b -= 1",
            "    G[_a].append((_b, -_c))",
            "",
            "st = 0",
            "ret = bellman_ford(st)",
            "if ret == -1:",
            "    print('inf')",
            "else:",
            "    print(-ret[-1])",
            ""
        ],
        "description": [
            "ベルマンフォード法・負閉路OK",
            "O(NM)"
        ]
    },
    "ランレングス圧縮": {
        "prefix": [
            "Lib_A_ランレングス圧縮_rle"
        ],
        "body": [
            "#####################################",
            "from itertools import groupby",
            "strings = \"aabbbbbbbbbbbba\"",
            "",
            "ans = [(k, len(list(g))) for k,g in groupby(strings)]",
            "print(ans)",
            "#[('a', 2), ('b', 12), ('a', 1)]"
        ],
        "description": [
            "ランレングス圧縮"
        ]
    },
    "行列演算2": {
        "prefix": [],
        "body": [],
        "description": []
    },
    "行列回転": {
        "prefix": [
            "Lib_M_matrix-回転と反転"
        ],
        "body": [
            "class Matrix():",
            "    def __init__(self, n, v=None):",
            "        self.n = n",
            "        self.state = [0, 0]",
            "        self.matrix_origin = [[v] * n for _ in range(n)]",
            "",
            "    def rotate(self, t):",
            "        self.state[0] = (self.state[0] + t) % 4",
            "",
            "",
            "    def reverse_lr(self):",
            "        self.state[1] = 1 - self.state[1]",
            "        if self.state[0] % 2 == 1:",
            "            self.state[0] = (self.state[0] + 2) % 4",
            "",
            "    def reverse_ud(self):",
            "        self.state[1] = 1 - self.state[1]",
            "        if self.state[0] % 2 == 0:",
            "            self.state[0] = (self.state[0] + 2) % 4",
            "",
            "    def get_original_positon(self, x, y):",
            "        n = self.n",
            "        if self.state == [0, 0]: return x, y",
            "        if self.state == [1, 0]: return n-1-y, x",
            "        if self.state == [2, 0]: return n-1-x, n-1-y",
            "        if self.state == [3, 0]: return y, n-1-x",
            "",
            "        if self.state == [0, 1]: return x, n-1-y",
            "        if self.state == [1, 1]: return n-1-y, n-1-x",
            "        if self.state == [2, 1]: return n-1-x, y",
            "        if self.state == [3, 1]: return y, x",
            "        else:",
            "            print(self.state)",
            "",
            "    def set_value(self, x, y, v):",
            "        ox, oy = self.get_original_positon(x, y)",
            "        self.matrix_origin[ox][oy] = v",
            "",
            "    def get_value(self, x, y):",
            "        ox, oy = self.get_original_positon(x, y)",
            "        return self.matrix_origin[ox][oy]",
            "",
            "n, q = map(int, input().split())",
            "mx = Matrix(n, 0)",
            "",
            "for _ in range(q):",
            "    que = list(input().split())",
            "    if que[0] == '1':",
            "        x = int1(que[1])",
            "        y = int1(que[2])",
            "        mx.set_value(x, y, 1 - mx.get_value(x, y))",
            "    if que[0] == '2':",
            "        if que[1] == 'A':",
            "            mx.rotate(1)",
            "        else:",
            "            mx.rotate(3)",
            "    if que[0] == '3':",
            "        if que[1] == 'A':",
            "            mx.reverse_ud()",
            "        else:",
            "            mx.reverse_lr()",
            "",
            "for i in range(n):",
            "    ret = []",
            "    for j in range(n):",
            "        ret.append(mx.get_value(i, j))",
            "    print(''.join(map(str, ret)))",
            ""
        ],
        "description": []
    },
    "Zアルゴリズム": {
        "prefix": [
            "Lib_STr_Zalgorithm"
        ],
        "body": [
            "",
            "# Zアルゴリズム",
            "# S と S[i:]が接頭辞が一致する長さ",
            "# https://snuke.hatenablog.com/entry/2014/12/03/214243",
            "def z_algo(S):",
            "    n = len(S)",
            "    A = [n] + [0] * (n-1)",
            "    i, j = 1, 0",
            "    while i < n:",
            "        while i+j < n and S[j] == S[i+j]:",
            "            j += 1",
            "        A[i] = j",
            "        if not j:",
            "            i += 1",
            "            continue",
            "        k = 1",
            "        while n-i > k < j - A[k]:",
            "            A[i+k] = A[k]",
            "            k += 1",
            "        i += k; j -= k",
            "    return A",
            "",
            "s = input()",
            "ret = z_algo(s)",
            "",
            "# s = 'abcbcba'",
            "# ret = z_algo(s)",
            "# for i in range(len(s)):",
            "#     print(i, ret[i], s, s[i:])",
            "# 0 7 abcbcba abcbcba",
            "# 1 0 abcbcba bcbcba",
            "# 2 0 abcbcba cbcba",
            "# 3 0 abcbcba bcba",
            "# 4 0 abcbcba cba",
            "# 5 0 abcbcba ba",
            "# 6 1 abcbcba a",
            ""
        ],
        "description": [
            "Zアルゴリズム",
            "S と S[i:]が接頭辞が一致する長さ"
        ]
    },
    "Lib_permutation": {
        "prefix": [
            "Lib_permutation_順列"
        ],
        "body": [
            "",
            "class permutation:",
            "    def __init__(self, L):",
            "        self.n = len(L)",
            "        self.L = L",
            "        self.LS = sorted(L[:])",
            "        self.map = {li: i for i, li in enumerate(self.LS)}",
            "        nn = self.n + 1",
            "        fa = [1] * (nn + 1)",
            "        for i in range(nn):",
            "            fa[i+1] = fa[i] * (i+1)",
            "        self.fa = fa",
            "        self.convL = self._convL(self.L)",
            "        self.facn = self.fa[self.n]",
            "        self.k = self.id_of_permutation(self.L)",
            "",
            "    def _convL(self, L):",
            "        return [self.map[li] for li in L]",
            "",
            "    def _restoreP(self, P):",
            "        return [self.LS[i] for i in P]",
            "",
            "    def _kth_permutation(self, k):",
            "        # zero-indexed here",
            "        n = self.n",
            "        S = [i for i in range(n)]",
            "        L = []",
            "        for i in range(n):",
            "            a = self.fa[n-1-i]",
            "            j = k // a",
            "            k %= a",
            "            L.append(S[j])",
            "            S = S[:j] + S[j+1:]",
            "        return L",
            "",
            "    def _id_of_permutation(self, P):",
            "        # zero-indexed here",
            "        ret = 0",
            "        while len(P) > 1:",
            "            a = len([l for l in P if l < P[0]])",
            "            ret += a * self.fa[len(P) - 1]",
            "            P = P[1:]",
            "        return ret",
            "",
            "    def id_of_permutation(self, L=None)->int:",
            "        \"\"\"",
            "        return: 順列の辞書順",
            "        \"\"\"",
            "        if L:",
            "            P = self._convL(L)",
            "            return self._id_of_permutation(P)",
            "        else: return self.k",
            "",
            "    def kth_permutation(self, k)->list:",
            "        \"\"\"",
            "        return: k番目の順列",
            "        \"\"\"",
            "        P = self._kth_permutation(k)",
            "        return self._restoreP(P)",
            "",
            "    def prev(self, L=None):",
            "        \"\"\"",
            "        return: 初期順列または入力順列のひとつ前",
            "        \"\"\"",
            "        if L:",
            "            k = self.id_of_permutation(L)",
            "        else:",
            "            k = self.k",
            "        if k == 0: return None",
            "        return self.kth_permutation(self.k - 1)",
            "",
            "    def next(self, L=None):",
            "        if L:",
            "            k = self.id_of_permutation(L)",
            "        else:",
            "            k = self.k",
            "        if k + 1 == self.facn: return None",
            "        return self.kth_permutation(k + 1)",
            "",
            "##################################",
            "N = int(input())",
            "P = [int(a) for a in input().split()]",
            "mut = permutation(P)",
            "print(*mut.prev())",
            ""
        ],
        "description": [
            "順列のライブラリ"
        ]
    },
    "木の上の範囲クエリ": {
        "prefix": [
            "Lib_GT_木上の辺の１点更新区間クエリ_RangeQuery"
        ],
        "body": [
            "#############################################",
            "# 木の上で経路上の範囲クエリするもの",
            "# https://atcoder.jp/contests/abc294/tasks/abc294_g",
            "",
            "class SegmentTree:",
            "    def __init__(self, init, f, ie):",
            "        # initがリストなら初期化, 整数ならinit個の配列",
            "        self._f = f",
            "        self._ie = ie",
            "        if type(init) == int:",
            "            init = [ie] * init",
            "        self._n = len(init)",
            "        self._log = (self._n - 1).bit_length()",
            "        self._size = 1 << self._log",
            "        self._dat = [ie] * self._size + init + [ie] * (self._size - len(init))",
            "        for i in range(self._size-1, 0, -1): self._update(i)",
            "",
            "    def _update(self, i):",
            "        self._dat[i] = self._f(self._dat[i<<1], self._dat[(i<<1)+1])",
            "",
            "    def __getitem__(self, i):",
            "        return self._dat[i + self._size]",
            "",
            "    def __str__(self):",
            "        return ' '.join(map(str, (self[i] for i in range(self._n))))",
            "",
            "    def update(self, i, x):",
            "        # one point update  a[i] を xに更新",
            "        i += self._size",
            "        self._dat[i] = x",
            "        while i:",
            "            i >>= 1",
            "            self._update(i)",
            "",
            "    def add(self, i, x):",
            "        # one point update a[i] に xを加算",
            "        i += self._size",
            "        self._dat[i] += x",
            "        while i:",
            "            i >>= 1",
            "            self._update(i)",
            "",
            "    def query(self, l, r):",
            "        # 半開区間[l, r)にf(a[l], a[l+1])演算",
            "        l += self._size",
            "        r += self._size",
            "        lret, rret = self._ie, self._ie",
            "        while l < r:",
            "            if l & 1:",
            "                lret = self._f(lret, self._dat[l])",
            "                l += 1",
            "            if r & 1:",
            "                r -= 1",
            "                rret = self._f(self._dat[r], rret)",
            "            l >>= 1",
            "            r >>= 1",
            "        return self._f(lret, rret)",
            "",
            "",
            "class EulerTour:",
            "    def __init__(self, n, G, node_cost=None):",
            "        self.n = n",
            "        self.G = G",
            "        self.root = None        # 根",
            "        self.Depth = [0] * n    # 頂点iの深さ",
            "        if node_cost:",
            "            self.Ncost = node_cost",
            "        else:",
            "            self.Ncost = [0] * n       # 頂点iの値",
            "        self.Ecost = [0] * n       # 辺iのコスト",
            "        self.TimeIn = [0] * n   # 頂点iに到達する時間",
            "        self.TimeOut = [0] * n  # 頂点iから抜け出す時間",
            "        self.ETNodes = []       # ツアー順i番目の頂点番号",
            "        self.ETDepth = []       # ツアー順i番目の深さ番号",
            "        self.ETNodesCost = []   # ツアー順i番目の頂点のコスト",
            "        self.ETEdgesCost = []   # ツアー順i番目の辺のコスト",
            "",
            "",
            "    def set_euler_tour(self, root=0):",
            "        self.root = root        # 根を設定して",
            "        pa = [-1] * self.n",
            "        stack = [~root, root]",
            "        ct = -1; de = -1",
            "        _ETedges = []",
            "        while stack:",
            "            v = stack.pop()",
            "            ct += 1",
            "            _ETedges.append(v)",
            "            if v >= 0:",
            "                self.TimeIn[v] = ct",
            "                de += 1",
            "                self.ETNodes.append(v)",
            "                self.ETDepth.append(de)",
            "                self.Depth[v] = de",
            "                p = pa[v]",
            "                for w, cost in self.G[v][::-1]:",
            "                    if w == p: continue",
            "                    self.Ecost[w] = cost",
            "                    pa[w] = v",
            "                    stack.extend([~w, w])",
            "                self.ETNodesCost.append(self.Ncost[v])",
            "                self.ETEdgesCost.append(self.Ecost[v])",
            "            else:",
            "                self.TimeOut[~v] = ct",
            "                de -= 1",
            "                if de < 0:",
            "                    self.ETDepth.append(self.n)",
            "                else:",
            "                    self.ETDepth.append(de)",
            "                self.ETNodes.append(pa[~v])",
            "                self.ETNodesCost.append(-self.Ncost[~v])",
            "                self.ETEdgesCost.append(-self.Ecost[~v])",
            "        self.sgt_depth = SegmentTree(self.ETDepth, lambda x, y: min(x, y), float('inf'))",
            "        self._ETedges = _ETedges",
            "        self.set_query()",
            "        self.parent = pa",
            "",
            "",
            "    def lca(self, a:int, b:int):",
            "        l = min(self.TimeIn[a], self.TimeIn[b])",
            "        r = max(self.TimeOut[a], self.TimeOut[b])",
            "        if l > r: l, r = r, l",
            "        mindepth = self.sgt_depth.query(l, r)",
            "        while r - l > 1:",
            "            mid = (l+r) // 2",
            "            if self.sgt_depth.query(l, mid) == mindepth:",
            "                r = mid",
            "            else:",
            "                l = mid",
            "        return self.ETNodes[l]",
            "",
            "    def __str__(self):",
            "        ret = \"\"",
            "        ret += \"[ NODE] \" + \" \".join(map(lambda x: str(x).rjust(4), range(self.n))) + \"\\n\"",
            "        ret += \"[   IN] \" + \" \".join(map(lambda x: str(x).rjust(4), self.TimeIn)) + \"\\n\"",
            "        ret += \"[  OUT] \" + \" \".join(map(lambda x: str(x).rjust(4), self.TimeOut)) + \"\\n\"",
            "        ret += \"[DEPTH] \" + \" \".join(map(lambda x: str(x).rjust(4), self.Depth)) + \"\\n\"",
            "        ret += \"[NCOST] \" + \" \".join(map(lambda x: str(x).rjust(4), self.Ncost)) + \"\\n\"",
            "        ret += \"[ECOST] \" + \" \".join(map(lambda x: str(x).rjust(4), self.Ecost)) + \"\\n\" * 2",
            "        if not self.ETNodes: return ret",
            "        ret += \"[ TIME] \" + \" \".join(map(lambda x: str(x).rjust(4), range(len(self.ETNodes)))) + \"\\n\"",
            "        ret += \"[ NODE] \" + \" \".join(map(lambda x: str(x).rjust(4), self.ETNodes)) + \"\\n\"",
            "        ret += \"[DEPTH] \" + \" \".join(map(lambda x: str(x).rjust(4), self.ETDepth)) + \"\\n\"",
            "        ret += \"[NCOST] \" + \" \".join(map(lambda x: str(x).rjust(4), self.ETNodesCost)) + \"\\n\"",
            "        ret += \"[ECOST] \" + \" \".join(map(lambda x: str(x).rjust(4), self.ETEdgesCost)) + \"\\n\"",
            "        return ret",
            "",
            "    def root_edge_dist(self, u:int): return self.Depth[u]",
            "    def root_edge_cost(self, u:int): return self.sgt_edges.query(0, self.TimeIn[u] + 1)",
            "",
            "    def uv_edge_dist(self, u:int, v:int):",
            "        redist = self.root_edge_dist",
            "        lca = self.lca(u, v)",
            "        return redist(u) + redist(v) - 2 * redist(lca)",
            "",
            "    def uv_edge_cost(self, u:int, v:int):",
            "        recost = self.root_edge_cost",
            "        lca = self.lca(u, v)",
            "        return recost(u) + recost(v) - 2 * recost(lca)",
            "",
            "    def update_edge_cost(self, u, v, w):",
            "        if self.TimeIn[u] > self.TimeIn[v]: u, v = v, u",
            "        self.sgt_edges.update(self.TimeIn[v], w)",
            "        self.sgt_edges.update(self.TimeOut[v], -w)",
            "        self.ETEdgesCost[self.TimeIn[v]] = w",
            "        self.ETEdgesCost[self.TimeOut[v]] = -w",
            "",
            "    def add_edge_cost(self, u, v, w):",
            "        if self.TimeIn[u] > self.TimeIn[v]: u, v = v, u",
            "        self.sgt_edges.add(self.TimeIn[v], w)",
            "        self.sgt_edges.add(self.TimeOut[v], -w)",
            "        self.ETEdgesCost[self.TimeIn[v]] += w",
            "        self.ETEdgesCost[self.TimeOut[v]] -= w",
            "",
            "    def set_query(self):",
            "        ####################### 経路上の頂点ないしは辺の和",
            "        self.sgt_nodes = SegmentTree(self.ETNodesCost, lambda x, y: x + y, 0)",
            "        self.sgt_edges = SegmentTree(self.ETEdgesCost, lambda x, y: x + y, 0)",
            "",
            "",
            "###########################################",
            "n = int(input())",
            "G = [[] for _ in range(n)]",
            "edges = []",
            "for _ in range(n-1):",
            "    a, b, w = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G[a].append((b, w))",
            "    G[b].append((a, w))",
            "    edges.append([a, b, w])",
            "",
            "et = EulerTour(n, G)",
            "et.set_euler_tour(0)",
            "",
            "q = int(input())",
            "for _ in range(q):",
            "    f, x, y = map(int, input().split())",
            "    if f == 1:",
            "        u, v, _ = edges[x-1]",
            "        et.update_edge_cost(u, v, y)",
            "    else:",
            "        print(et.uv_edge_cost(x-1, y-1))",
            "",
            ""
        ],
        "description": [
            "木の上の範囲クエリ RangeQuery"
        ]
    },
    "最小全域木": {
        "prefix": [
            "Lib_GT_最小全域木_MST"
        ],
        "body": [
            "class UnionFind:",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [i for i in range(n)]",
            "        self.ranks = [0] * n",
            "",
            "    def find(self, x):",
            "        p = self.parents[x]",
            "        if p == x: return x",
            "        self.parents[x] = p = self.find(p)",
            "        return p",
            "",
            "    def unite(self, x, y):",
            "        x = self.find(x); y = self.find(y)",
            "        if x == y: return",
            "        if self.ranks[x] > self.ranks[y]: x , y = y, x",
            "        if self.ranks[x] == self.ranks[y]: self.ranks[y] += 1",
            "        self.parents[x] = y",
            "",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "",
            "",
            "class Kruskal:",
            "    def __init__(self, n:int, G:list)->None:",
            "        self.n = n",
            "        self.all_edges = G",
            "        self.weight = None",
            "        self.edges = None",
            "        self.edges_nouse = None",
            "        self.nodes = None",
            "",
            "    def build(self)->None:",
            "        self.weight = 0",
            "        self.edges = []",
            "        self.edges_nouse = []",
            "        self.nodes = set([])",
            "        self.all_edges.sort(key=lambda x: x[-1])",
            "        uf = UnionFind(self.n)",
            "        for u, v, w in self.all_edges:",
            "            if not uf.same(u, v):",
            "                uf.unite(u, v)",
            "                self.weight += w",
            "                # self.edges.append((u, v, w))",
            "                self.nodes |= {u, v}",
            "            else:",
            "                pass",
            "                # self.edges_nouse.append((u, v, w))",
            "        if len(self.nodes) != self.n:",
            "            self.weight = float('inf')",
            "################################",
            "",
            "n, m = map(int, input().split())",
            "",
            "#辺リストの作成",
            "G = []",
            "for i in range(m):",
            "    a, b, w = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G.append((a, b, w))",
            "",
            "mst = Kruskal(n, G)",
            "mst.build()",
            "print(mst.weight)",
            ""
        ],
        "description": [
            "最小全域木 クラスカル法 minimum_spanning_tree",
            "重み付き無向グラフで、それらの全ての頂点を結び連結するような木の最小のコストを求める",
            "辺の重みの小さい順にみて、連結成分が閉路にならない辺を追加していく",
            "つなぐ頂点が同じ連結成分にないことをUnion Find Tree でみる"
        ]
    },
    "素因数分解": {
        "prefix": [
            "Lib_N_素因数分解"
        ],
        "body": [
            "##############################",
            "# 素因数分解",
            "# nは10**15くらいまでOK",
            "# returns dict s.t. key = {prime}   value = {degree}",
            "##############################",
            "def prime_factorize(n:int) -> dict:",
            "    if n == 1: return {1: 1}",
            "    pd = dict()",
            "    for p in range(2, int(n**0.5)+1):",
            "        if n % p != 0: continue",
            "        d = 0",
            "        while n % p == 0:",
            "            d += 1",
            "            n //= p",
            "        pd[p] = d",
            "    if n != 1: pd[n] = 1",
            "    return pd",
            "",
            "print(prime_factorize(360))  # 72 = 2**3 * 3**2 * 5**1",
            "                             # {2: 3, 3: 2, 5: 1}",
            "",
            "##############################",
            "# 素因数分解（複数個版）",
            "# max(A)が大きい場合はNG  10**6くらいまで",
            "# 最初に素数一覧を作っておく",
            "##############################",
            "def prime_factorize(A : list):",
            "    Max = max(A) + 1",
            "    IsPrime = [True] * Max",
            "    MinFactor = [-1] * Max",
            "    dica = {}",
            "    IsPrime[0], IsPrime[1] = False, False",
            "    MinFactor[0], MinFactor[1] = 0, 1",
            "    for p in range(2, Max):",
            "        if IsPrime[p]:",
            "            MinFactor[p] = p",
            "            for k in range(p*2, Max, p):",
            "                IsPrime[k] = False",
            "                if MinFactor[k] == -1:",
            "                    MinFactor[k] = p",
            "",
            "    ret = []",
            "    for a in A:",
            "        res = dict()",
            "        while a != 1:",
            "            prime = MinFactor[a]",
            "            exp = 0",
            "            while MinFactor[a] == prime:",
            "                exp += 1",
            "                a //= prime",
            "            res[prime] = exp",
            "            if not prime in dica:",
            "                dica[prime] = 1",
            "            else:",
            "                dica[prime] += 1",
            "        ret.append(res)",
            "    return ret",
            "",
            "##############################",
            "# n!が素数pで何回割れるか O(logn)",
            "# legendre(n, p)",
            "##############################",
            "def legendre(n, p):",
            "    ret = 0",
            "    while n > 0:",
            "        ret += n // p",
            "        n //= p",
            "    return ret",
            ""
        ],
        "description": []
    },
    "トポロジカルソート 有向グラフ": {
        "prefix": [
            "Lib_GD_トポロジカルソート_topologicalsort"
        ],
        "body": [
            "# トポロジカルソート",
            "# 有向非巡回グラフ（DAG）の各ノードを順序付けして、どのノードもその出力辺の先のノードより前にくるように並べることである。",
            "# 有向非巡回グラフは必ずトポロジカルソートすることができる。",
            "",
            "from collections import deque",
            "",
            "class topological_sort:",
            "    def __init__(self, n:int, G) -> None:",
            "        self.n = n",
            "        self.ts = []            # トポロジカルソート",
            "        self.parents = [-1] * n # 親 -1は根",
            "        self.G = G              # 辺",
            "        self.in_cnt = [0] * n   # 入力",
            "        self.node_zero = []     # ゼロ次のノード",
            "        for i, gi in enumerate(G):",
            "            for j in gi:",
            "                self.in_cnt[j] += 1",
            "        self.node_zero = [i for i in range(self.n) if self.in_cnt[i] == 0]",
            "",
            "",
            "    def _build_sort_by_appear(self) -> None:",
            "        q = self.node_zero[:]",
            "        q = deque(q)",
            "        while q:",
            "            p = q.popleft()",
            "            self.ts.append(p)",
            "            for nxt in self.G[p]:",
            "                self.in_cnt[nxt] -= 1",
            "                if self.in_cnt[nxt] == 0:",
            "                    q.append(nxt)",
            "                    self.parents[nxt] = p",
            "",
            "",
            "    def _build_sort_by_nodeid(self) -> None:",
            "        q = self.node_zero[:]",
            "        heapify(q)",
            "        while q:",
            "            p = heappop(q)",
            "            self.ts.append(p)",
            "            for nxt, nxtw in self.G[p]:",
            "                self.in_cnt[nxt] -= 1",
            "                if self.in_cnt[nxt] == 0:",
            "                    heappush(q, nxt)",
            "                    self.parents[nxt] = p",
            "",
            "",
            "    def build(self, sorttype='appear'):",
            "        self.ts = []            # トポロジカルソート",
            "        if sorttype == 'appear':        # 出たとこ順番",
            "            self._build_sort_by_appear()",
            "        elif sorttype == 'nodeid':      # ノードの順番",
            "            self._build_sort_by_nodeid()",
            "",
            "",
            "    @property",
            "    def is_dag(self) -> bool:",
            "        return len(self.ts)==self.n",
            "        # True 閉路なしDAG",
            "        # False 閉路あり",
            "",
            "",
            "    @property",
            "    def is_unique(self) -> bool:",
            "        if not self.is_dag: return False",
            "        for i in range(self.n-1):",
            "            u, v = self.ts[i:i+2]",
            "            if not v in self.G[u]: return False",
            "        return True",
            "        # True トポロジカルソートの経路が一意",
            "        # False 複数あり",
            "",
            "",
            "#########################################",
            "# n, m = map(int, input().split())",
            "n = int(input())",
            "G = [[] for _ in range(n)]",
            "m = n",
            "for _ in range(m):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    w = 0",
            "    G[a].append(b)",
            "",
            "ts = topological_sort(n, G)",
            "",
            "ts.build()",
            "",
            "print(ts.ts)",
            "print(ts.parents)",
            "print(ts.is_dag)",
            "print(ts.is_unique)",
            ""
        ],
        "description": [
            "トポロジカルソート topologicalsort"
        ]
    },
    "遅延評価セグメント木": {
        "prefix": [
            "Lib_Q_LazySeg_区間Add,Update x 区間Min,Sumクエリ"
        ],
        "body": [
            "import sys",
            "def input(): return sys.stdin.readline().rstrip()",
            "",
            "####################################",
            "class LazySegmentTree_RAQ:",
            "    \"\"\"RAQRangeQuery",
            "    区間加算・区間Min/Sum",
            "    Parameters",
            "    ----------",
            "    a : list",
            "        初期リスト",
            "    e : 単位元",
            "        by default float('inf')",
            "    Attributes",
            "    ----------",
            "    log : int",
            "        木の高さ",
            "    size : int",
            "        木のノード数",
            "    data : list",
            "        木のノードの値",
            "    lazy : list",
            "        遅延評価用値",
            "    \"\"\"",
            "    def __init__(self, a:list, f, ie, type) -> None:",
            "        self.type = type.lower()",
            "        self.f = f",
            "        self.INF = ie",
            "        self.n = len(a)",
            "        self.log = self.n.bit_length()",
            "        self.size = 1 << self.log",
            "        self.data = [self.INF] * (2*self.size)",
            "        self.lazy = [0] * (2*self.size)",
            "        for i, ai in enumerate(a):",
            "            self.data[i + self.size] = ai",
            "        for i in range(self.size)[::-1]:",
            "            self.data[i] = self.f(self.data[2*i], self.data[2*i+1])",
            "",
            "    def _prop_value(self, v):",
            "        if self.type == 'min':",
            "            return v",
            "        elif self.type == 'sum':",
            "            return v // 2",
            "",
            "    def _update_value(self, x):",
            "        if self.type == 'min':",
            "            return x",
            "        elif self.type == 'sum':",
            "            return x * 2",
            "",
            "    def __gindex(self, l, r):",
            "        \"\"\"伝搬される区間のインデックス(1-indexed)を全て列挙するgenerator",
            "        \"\"\"",
            "        L = l + self.size; R = r + self.size",
            "        lm = (L // (L & -L)) >> 1",
            "        rm = (R // (R & -R)) >> 1",
            "        while L < R:",
            "            if R <= rm:",
            "                yield R",
            "            if L <= lm:",
            "                yield L",
            "            L >>= 1; R >>= 1",
            "        while L:",
            "            yield L",
            "            L >>= 1",
            "",
            "",
            "    def __propagates(self, *ids):",
            "        \"\"\"遅延伝搬処理",
            "        \"\"\"",
            "        for i in reversed(ids):",
            "            v = self.lazy[i]",
            "            if not v: continue",
            "            v = self._prop_value(v)",
            "            self.lazy[2*i] += v",
            "            self.lazy[2*i+1] += v",
            "            self.data[2*i] += v",
            "            self.data[2*i+1] += v",
            "            self.lazy[i] = 0",
            "",
            "",
            "    def update(self, l: int, r: int, x: int) -> None:",
            "        \"\"\"半開区間[l, r)に対して値xxを加算",
            "        \"\"\"",
            "        *ids, = self.__gindex(l, r)",
            "        self.__propagates(*ids)",
            "        L = self.size + l; R = self.size + r",
            "        xx = x",
            "        while L < R:",
            "            if R & 1:",
            "                R -= 1",
            "                self.lazy[R] += xx",
            "                self.data[R] += xx",
            "            if L & 1:",
            "                self.lazy[L] += xx",
            "                self.data[L] += xx",
            "                L += 1",
            "            L >>= 1; R >>= 1",
            "            xx = self._update_value(xx)",
            "        for i in ids:",
            "            self.data[i] = self.f(self.data[2*i], self.data[2*i+1])",
            "            self.data[i] += self.lazy[i]",
            "",
            "",
            "    def query(self, l: int, r: int) -> None:",
            "        \"\"\"半開区間[l, r)内のfを求める",
            "        \"\"\"",
            "        self.__propagates(*self.__gindex(l, r))",
            "        L = self.size + l; R = self.size + r",
            "",
            "        s = self.INF",
            "        while L < R:",
            "            if R & 1:",
            "                R -= 1",
            "                s = self.f(s, self.data[R])",
            "            if L & 1:",
            "                s = self.f(s, self.data[L])",
            "                L += 1",
            "            L >>= 1; R >>= 1",
            "        return s",
            "",
            "",
            "    def __getitem__(self, i:int) -> int:",
            "        \"\"\"index = i の値を求める",
            "        \"\"\"",
            "        return self.query(i, i+1)",
            "",
            "",
            "    def __str__(self):",
            "        \"\"\"元の配列を出力",
            "        \"\"\"",
            "        for i in range(self.size):",
            "            self.__getitem__(i)",
            "        return \" \".join(map(str, self.data[self.size:]))",
            "",
            "####################################",
            "class LazySegmentTree_RUQ:",
            "    \"\"\"RUQRangeQuery",
            "    区間更新・区間Min/Sum",
            "    Parameters",
            "    ----------",
            "    a : list",
            "        初期リスト",
            "    e : 単位元",
            "        by default float('inf')",
            "    Attributes",
            "    ----------",
            "    log : int",
            "        木の高さ",
            "    size : int",
            "        木のノード数",
            "    data : list",
            "        木のノードの値",
            "    lazy : list",
            "        遅延評価用値",
            "    \"\"\"",
            "    def __init__(self, a:list, f, ie, type) -> None:",
            "        self.type = type.lower()",
            "        self.f = f",
            "        self.INF = ie",
            "        self.log = len(a).bit_length()",
            "        self.size = 1 << self.log",
            "        self.data = [self.INF] * (2*self.size)",
            "        self.lazy = [None] * (2*self.size)",
            "        for i, ai in enumerate(a):",
            "            self.data[i + self.size] = ai",
            "        for i in range(self.size)[::-1]:",
            "            self.data[i] = self.f(self.data[2*i], self.data[2*i+1])",
            "",
            "    def _prop_value(self, v):",
            "        if self.type == 'min':",
            "            return v",
            "        elif self.type == 'sum':",
            "            return v // 2",
            "",
            "    def _update_value(self, x):",
            "        if self.type == 'min':",
            "            return x",
            "        elif self.type == 'sum':",
            "            return x * 2",
            "",
            "    def __gindex(self, l, r):",
            "        \"\"\"伝搬される区間のインデックス(1-indexed)を全て列挙するgenerator",
            "        \"\"\"",
            "        L = l + self.size; R = r + self.size",
            "        lm = (L // (L & -L)) >> 1",
            "        rm = (R // (R & -R)) >> 1",
            "        while L < R:",
            "            if R <= rm:",
            "                yield R",
            "            if L <= lm:",
            "                yield L",
            "            L >>= 1; R >>= 1",
            "        while L:",
            "            yield L",
            "            L >>= 1",
            "",
            "",
            "    def __propagates(self, *ids):",
            "        \"\"\"遅延伝搬処理",
            "        \"\"\"",
            "        for i in reversed(ids):",
            "            v = self.lazy[i]",
            "            if v is None: continue",
            "            v = self._prop_value(v)",
            "            self.lazy[2*i] = v",
            "            self.lazy[2*i+1] = v",
            "            self.data[2*i] = v",
            "            self.data[2*i+1] = v",
            "            self.lazy[i] = None",
            "",
            "",
            "    def update(self, l: int, r: int, x: int) -> None:",
            "        \"\"\"半開区間[l, r)に対して値をxに更新",
            "        \"\"\"",
            "        *ids, = self.__gindex(l, r)",
            "        self.__propagates(*ids)",
            "        L = self.size + l; R = self.size + r",
            "        xx = x",
            "        while L < R:",
            "            if R & 1:",
            "                R -= 1",
            "                self.lazy[R] = xx",
            "                self.data[R] = xx",
            "            if L & 1:",
            "                self.lazy[L] = xx",
            "                self.data[L] = xx",
            "                L += 1",
            "            L >>= 1; R >>= 1",
            "            xx = self._update_value(xx)",
            "        for i in ids:",
            "            self.data[i] = self.f(self.data[2*i], self.data[2*i+1])",
            "",
            "",
            "    def query(self, l: int, r: int) -> None:",
            "        \"\"\"半開区間[l, r)内のfを求める",
            "        \"\"\"",
            "        self.__propagates(*self.__gindex(l, r))",
            "        L = self.size + l; R = self.size + r",
            "",
            "        s = self.INF",
            "        while L < R:",
            "            if R & 1:",
            "                R -= 1",
            "                s = self.f(s, self.data[R])",
            "            if L & 1:",
            "                s = self.f(s, self.data[L])",
            "                L += 1",
            "            L >>= 1; R >>= 1",
            "        return s",
            "",
            "",
            "    def __getitem__(self, i:int) -> int:",
            "        \"\"\"index = i の値を求める",
            "        \"\"\"",
            "        return self.query(i, i+1)",
            "",
            "",
            "    def __str__(self):",
            "        \"\"\"元の配列を出力",
            "        \"\"\"",
            "        for i in range(self.size):",
            "            self.__getitem__(i)",
            "        return \" \".join(map(str, self.data[self.size:]))",
            "",
            "",
            "####################################",
            "# Range Minimum Query",
            "class RAQRMQ(LazySegmentTree_RAQ):",
            "    def __init__(self, a):",
            "        super().__init__(a, min, float('inf') ,'min')",
            "",
            "# Range Sum Query",
            "class RAQRSQ(LazySegmentTree_RAQ):",
            "    def __init__(self, a):",
            "        super().__init__(a, lambda x, y: x+y, 0 ,'sum')",
            "",
            "####################################",
            "# Range Minimum Query",
            "class RUQRMQ(LazySegmentTree_RUQ):",
            "    def __init__(self, a):",
            "        super().__init__(a, min, 2**31-1 ,'min')",
            "",
            "# Range Sum Query",
            "class RUQRSQ(LazySegmentTree_RUQ):",
            "    def __init__(self, a):",
            "        super().__init__(a, lambda x, y: x+y, 0 ,'sum')",
            "",
            "####################################",
            "",
            "n, q = map(int, input().split())",
            "lst = RAQRSQ([0]*n)",
            "lst = RAQRMQ([0]*n)",
            "lst = RUQRMQ([2**31-1] * n)",
            "lst = RUQRSQ([0]*n)",
            "",
            "ret = []",
            "for _ in range(q):",
            "    t, *qry = map(int, input().split())",
            "    if t == 0:",
            "        l, r, x = qry",
            "        r += 1",
            "        lst.update(l, r, x)",
            "    else:",
            "        l, r = qry",
            "        r += 1",
            "        ret.append(lst.query(l, r))",
            "print('\\n'.join(map(str, ret)))",
            ""
        ],
        "description": [
            "遅延評価セグメント木"
        ]
    },
    "n=intinput": {
        "prefix": [
            "nin"
        ],
        "body": [
            "n = int(input())"
        ],
        "description": [
            "整数nの読み込み"
        ]
    },
    "nainput": {
        "prefix": [
            "nain"
        ],
        "body": [
            "n = int(input())",
            "a = list(map(int, input().split()))"
        ],
        "description": [
            "整数nの読み込み"
        ]
    },
    "s=input": {
        "prefix": [
            "sin"
        ],
        "body": [
            "s = list(input())"
        ],
        "description": [
            "文字列sの読み込み"
        ]
    },
    "ab=mapintinput": {
        "prefix": [
            "a, b=map"
        ],
        "body": [
            "a, b = map(int, input().split())"
        ],
        "description": [
            "整数a, bの読み込み"
        ]
    },
    "n,m=map(int, input().split())": {
        "prefix": [
            "n, m=map"
        ],
        "body": [
            "n, m = map(int, input().split())"
        ],
        "description": [
            "整数n, mの読み込み"
        ]
    },
    "a=list(map(int, input().split()))": {
        "prefix": [
            "a =list"
        ],
        "body": [
            "a = list(map(int, input().split()))"
        ],
        "description": [
            "リストの読み込み"
        ]
    },
    "b=list(map(int, input().split()))": {
        "prefix": [
            "b =list"
        ],
        "body": [
            "b = list(map(int, input().split()))"
        ],
        "description": [
            "リストの読み込み"
        ]
    },
    "edges": {
        "prefix": [
            "G ="
        ],
        "body": [
            "G = [[] for _ in range($n)]",
            "for _ in range($m):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G[a].append(b)",
            "    G[b].append(a)",
            ""
        ],
        "description": [
            "edges"
        ]
    },
    "edgesweighted": {
        "prefix": [
            "G = w"
        ],
        "body": [
            "G = [[] for _ in range($n)]",
            "for _ in range($m):",
            "    a, b, w = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G[a].append((b, w))",
            "    G[b].append((a, w))",
            ""
        ],
        "description": [
            "edges(重み付き)"
        ]
    },
    "0インデックス": {
        "prefix": [
            "a -= 1; b -= 1"
        ],
        "body": [
            "a -= 1; b -= 1"
        ],
        "description": [
            "0-indexed"
        ]
    },
    "巡回セールスマン問題": {
        "prefix": [
            "Lib_A_巡回セールスマン問題_TSP_bitDP"
        ],
        "body": [
            "# bitDP",
            "# dp[s][i]  集合sに行って、今iにいる場合の最小距離",
            "",
            "INF = float('inf')",
            "n, m = map(int, input().split())",
            "",
            "# 辺の情報",
            "dist = [[INF] * n for _ in range(n)]",
            "for i in range(n):",
            "    dist[i][i] = 0",
            "for _ in range(m):",
            "    fm, to, d = map(int, input().split())",
            "    # fm, to = fm - 1, to - 1",
            "    dist[fm][to] = d",
            "",
            "# 距離関数",
            "def d(fm, to):",
            "    if dist[fm][to] != INF:",
            "        return dist[fm][to]",
            "    else:",
            "        # 何か変則処理",
            "        # ex. dist[fm][to] = abs(a-p) + abs(b-q) + max(0, r-c)",
            "        return dist[fm][to]",
            "",
            "# dp[s][i]  集合sに行って、今iにいる場合の最小距離",
            "# 最初は0だがsにはカウントしない",
            "dp = [[INF] * n for _ in range(1 << n)]",
            "for first in range(n):",
            "    dp[1 << first][first] = d(0, first)",
            "",
            "for s in range(1, 1 << n):",
            "    for fm in range(n):",
            "        if not s >> fm & 1: continue    # fmがsに無い場合->スキップ",
            "        if dp[s][fm] == INF: continue   # 到達距離がINF->スキップ",
            "        for to in range(n):",
            "            if s >> to & 1: continue    # すでにtoがsにいる場合->スキップ",
            "            next_s = s | (1 << to)      # toを追加した状態",
            "            dp[next_s][to] = min(dp[next_s][to], dp[s][fm] + d(fm, to))",
            "",
            "ret = dp[-1][0]",
            "",
            "if ret == INF:",
            "    print(-1)",
            "else:",
            "    print(ret)",
            "",
            ""
        ],
        "description": [
            "巡回セールスマン問題"
        ]
    },
    "スパンクエリ": {
        "prefix": [
            "Lib_A_スパンクエリ_left_min_position"
        ],
        "body": [
            "#####################################",
            "# 左で自分より小さいものがあるindexを高速で計算",
            "def left_min_position(A, min_value=0):",
            "    ret = []",
            "    stack = []",
            "    stack.append([min_value, -1])",
            "    for i, ai in enumerate(A):",
            "        while stack[-1][0] >= ai:   #",
            "            stack.pop()",
            "        ret.append(stack[-1][1])",
            "        stack.append([ai, i])",
            "    return ret",
            "",
            "def right_min_position(A, min_value=0):",
            "# 左で自分より小さいものがあるindexを高速で計算",
            "    n = len(A)",
            "    return [n - pi - 1 for pi in reversed(left_min_position(A[::-1]))]",
            "",
            "",
            "n = int(input())",
            "A = list(map(int, input().split()))",
            "l = left_min_position(A)",
            "r = right_min_position(A)",
            "",
            "mx = 0",
            "for li, ri, ai in zip(l, r, A):",
            "    mx = max(mx, ai*(ri-li-1))",
            "print(mx)",
            ""
        ],
        "description": [
            "スパンクエリ"
        ]
    },
    "部分列の個数": {
        "prefix": [
            "Lib_部分列個数_subsetcount#"
        ],
        "body": [
            "",
            "def count_subsets(S, mod=10**9+7):",
            "    \"\"\"",
            "    部分列（連続でない）の個数を数える",
            "    空集合を含める",
            "    \"\"\"",
            "    if type(S) == str:",
            "        S = [ord(si)-ord('a') for si in S]",
            "    ls = len(S)",
            "    maxs = max(S)",
            "    pps = [[-1] * (maxs+1) for _ in range(ls+1)]",
            "    for i, si in enumerate(S):",
            "        for j in range(maxs+1):",
            "            pps[i+1][j] = pps[i][j]",
            "            if si == j: pps[i+1][j] = i",
            "",
            "    dp = [0] * (ls+1)",
            "    dp[0] = 1",
            "    for i, si in enumerate(S):",
            "        dp[i+1] = dp[i]",
            "        if pps[i][si] == -1:",
            "            dp[i+1] += dp[i]",
            "        else:",
            "            dp[i+1] += dp[i] - dp[pps[i][si]]",
            "        dp[i+1] %= mod",
            "",
            "    return dp[ls]",
            "",
            "",
            "#####################",
            "",
            "",
            "# https://atcoder.jp/contests/past202206-open/tasks/past202206_k",
            "class CountSubsets:",
            "    def __init__(self, S, T, mod) -> None:",
            "        self.S = S",
            "        self.T = T",
            "        self.ls = n = len(S)",
            "        self.lt = m = len(T)",
            "        self.dp = [[0]*(m+1) for _ in range(n+1)]",
            "        self._adj()",
            "        self.mod = mod",
            "        self.scS, self.ppS = self._substr_count(self.S)",
            "        self.scT, self.ppT = self._substr_count(self.T)",
            "        self.scbothST = self._substr_count_both()",
            "",
            "    def _adj(self):",
            "        mn = min(min(self.S), min(self.T))",
            "        self.S = [u - mn for u in self.S]",
            "        self.T = [u - mn for u in self.T]",
            "        self.Max = max(max(self.S), max(self.T))",
            "",
            "    def _pp(self, S):",
            "        ls = len(S)",
            "        pps = [[-1] * (self.Max+1) for _ in range(ls+1)]",
            "        for i, si in enumerate(S):",
            "            for j in range(self.Max+1):",
            "                pps[i+1][j] = pps[i][j]",
            "                if si == j: pps[i+1][j] = i",
            "        return pps",
            "",
            "    def _substr_count(self, S):",
            "        mod = self.mod",
            "        pps = self._pp(S)",
            "        ls = len(S)",
            "        dp = [0] * (ls+1)",
            "        dp[0] = 1",
            "        for i, si in enumerate(S):",
            "            dp[i+1] = dp[i]",
            "            if pps[i][si] == -1:",
            "                dp[i+1] += dp[i]",
            "            else:",
            "                dp[i+1] += dp[i] - dp[pps[i][si]]",
            "            dp[i+1] %= mod",
            "",
            "        return dp[ls], pps",
            "",
            "    def _substr_count_both(self):",
            "        S, T = self.S, self.T",
            "        ls, lt = self.ls, self.lt",
            "        pps, ppt = self.ppS, self.ppT",
            "        dp = [[0] * (lt+1) for _ in range(ls+1)]",
            "        for i in range(ls+1):",
            "            dp[i][0] = 1",
            "        for j in range(lt+1):",
            "            dp[0][j] = 1",
            "",
            "        for i, si in enumerate(S):",
            "            for j, tj in enumerate(T):",
            "                dp[i+1][j+1] = dp[i][j+1] + dp[i+1][j] - dp[i][j]",
            "                if si != tj: continue",
            "                pi, pj = pps[i][si], ppt[j][tj]",
            "                if pi != -1 and pj != -1:",
            "                    dp[i+1][j+1] += dp[i][j] - dp[i][pj] - dp[pi][j] + dp[pi][pj]",
            "                elif pi != -1 and pj == -1:",
            "                    dp[i+1][j+1] += dp[i][j] - dp[pi][j]",
            "                elif pi == -1 and pj != -1:",
            "                    dp[i+1][j+1] += dp[i][j] - dp[i][pj]",
            "                else:",
            "                    dp[i+1][j+1] += dp[i][j]",
            "                dp[i+1][j+1] %= self.mod",
            "        return dp[ls][lt]",
            "",
            "#####################",
            "",
            "mod = 998244353",
            "s = input()",
            "t = input()",
            "s = [ord(si)-ord('a') for si in s]",
            "t = [ord(si)-ord('a') for si in t]",
            "cs = CountSubsets(s, t, mod)",
            "print((cs.scS+cs.scT-cs.scbothST - 1)%mod)",
            ""
        ],
        "description": [
            "Lib_Substrings_count"
        ]
    },
    "Lib_AL_図形_座標回転": {
        "prefix": [
            "Lib_AL_図形_座標回転"
        ],
        "body": [
            "",
            "########################",
            "import math",
            "",
            "########################",
            "# 二次元座標を回転",
            "########################",
            "def rot(point: tuple, R) -> tuple:",
            "    R = math.radians(R)  # Rが度数の場合",
            "    a, b = point",
            "    cos, sin = math.cos(R), math.sin(R)",
            "    return (cos*a-sin*b, sin*a+cos*b)",
            "",
            ""
        ],
        "description": [
            "図形のライブラリ"
        ]
    },
    "削除機能付きheapque": {
        "prefix": [
            "Lib_D_heapque"
        ],
        "body": [
            "from heapq import heappush, heappop",
            "from collections import defaultdict",
            "class DeletableMaxMinHeapQ():",
            "    def __init__(self):",
            "        self.Hma = []",
            "        self.Hmi = []",
            "        self.HC = defaultdict(int)",
            "    def heappush(self, x):",
            "        heappush(self.Hma, -x)",
            "        heappush(self.Hmi, x)",
            "        self.HC[x] += 1",
            "    def heappopmax(self):",
            "        t = -heappop(self.Hma)",
            "        while not self.HC[t]:",
            "            t = -heappop(self.Hma)",
            "        self.HC[t] -= 1",
            "        return t",
            "    def heappopmin(self):",
            "        t = heappop(self.Hmi)",
            "        while not self.HC[t]:",
            "            t = heappop(self.Hmi)",
            "        self.HC[t] -= 1",
            "        return t",
            "    def heapmax(self):",
            "        t = -self.Hma[0]",
            "        while not self.HC[t]:",
            "            heappop(self.Hma)",
            "            t = -self.Hma[0]",
            "        return t",
            "    def heapmin(self):",
            "        t = self.Hmi[0]",
            "        while not self.HC[t]:",
            "            heappop(self.Hmi)",
            "            t = self.Hmi[0]",
            "        return t",
            "    def heapdel(self, x):",
            "        assert self.HC[x] > 0",
            "        self.HC[x] -= 1",
            "    def __contains__(self, x):",
            "        return 1 if x in self.HC and self.HC[x] else 0",
            "",
            "hq = DeletableMaxMinHeapQ()",
            "n, q = map(int, input().split())",
            "a = list(map(int, input().split()))",
            "for ai in a:",
            "    hq.heappush(ai)",
            "",
            "for _ in range(q):",
            "    query = list(map(int, input().split()))",
            "    if query[0] == 0:",
            "        hq.heappush(query[1])",
            "    elif query[0] == 1:",
            "        x = hq.heappopmin()",
            "        print(x)",
            "    else:",
            "        x = hq.heappopmax()",
            "        print(x)",
            "",
            "",
            "# https://judge.yosupo.jp/problem/double_ended_priority_queue",
            "",
            "############",
            ""
        ],
        "description": [
            "削除機能付きheapque"
        ]
    },
    "セグメント木区間加算１点集約": {
        "prefix": [
            "Lib_Q_Seg_区間加算一点集約"
        ],
        "body": [
            "class SegmentTree:",
            "    \"\"\"RAQ Segment Tree",
            "    区間加算・1点抽出",
            "    Parameters",
            "    ----------",
            "    a : list",
            "        初期リスト",
            "    e : 単位元",
            "        by default float('inf')",
            "    Notes",
            "    -----",
            "    1-indexed",
            "    https://onlinejudge.u-aizu.ac.jp/problems/DSL_2_E",
            "    \"\"\"",
            "    def __init__(self, n: int, ie):",
            "        self._n = n                             # 元のデータサイズ",
            "        self._log = (self._n - 1).bit_length()  # seg木の深さ",
            "        self._size = 1 << self._log             # seg木のサイズ",
            "        self.INF = ie",
            "        # seg木の初期化",
            "        self._dat = [self.INF] * (2 * self._size)",
            "",
            "",
            "    def add(self, l: int, r: int, x: int) -> None:",
            "        \"\"\"半開区間[l, r)にxを加算",
            "        \"\"\"",
            "        l += self._size  # 1番下の層におけるインデックス",
            "        r += self._size  # 1番下の層におけるインデックス",
            "        # 左側の答えと右側の答えを初期化",
            "        while l < r:    # lとrが重なるまで上記の判定を用いて演算を実行",
            "            # 右が子同士の右側(rが奇数)(rの末桁=1)ならば、dat[r-1]を演算",
            "            if r & 1:",
            "                r -= 1",
            "                self._dat[r] += x",
            "            # 左が子同士の右側(lが奇数)(lの末桁=1)ならば、dat[l]を演算",
            "            if l & 1:",
            "                self._dat[l] += x",
            "                l += 1",
            "            l >>= 1",
            "            r >>= 1",
            "",
            "",
            "    def query(self, k: int) -> int:",
            "        \"\"\"a_kを取得",
            "        \"\"\"",
            "        k += self._size",
            "        t = 0",
            "        while k > 0:",
            "            if self._dat[k]:",
            "                t += self._dat[k]",
            "            k >>= 1",
            "        return t",
            "",
            "",
            "    def __getitem__(self, i:int) -> int:",
            "        \"\"\"index = i の値を求める",
            "        queryと同じ",
            "        \"\"\"",
            "        return self.query(i)",
            "",
            "",
            "###################################################",
            "n, q = map(int, input().split())",
            "",
            "raq = SegmentTree(n+2, 0)",
            "",
            "for _ in range(q):",
            "    t, *qry = map(int, input().split())",
            "    if t == 0:",
            "        l, r, x = qry",
            "#        l -= 1",
            "        r += 1",
            "        raq.add(l, r, x)",
            "    else:",
            "        i = qry[0]",
            "#        i -= 1",
            "        print(raq[i])",
            ""
        ],
        "description": [
            "セグメント木区間加算１点集約"
        ]
    },
    "Binary Indexed Tree": {
        "prefix": [
            "Lib_Q_BIT_Fenwick"
        ],
        "body": [
            "# 部分和の計算と要素の更新の両方を効率的に行える",
            "# 1-indexed",
            "# sum(r)        :閉区間 [0,r] の合計を取得する",
            "# [8] a0 + a1  + a2 + a3 + a4 + a5 + a6 + a7",
            "# [4] a0 + a1  + a2 + a3",
            "# [2] a0 + a1               [6] a4 + a5",
            "# [1] a0       [3] a2       [5] a4        [7] a6",
            "",
            "#                   [1000]",
            "#           [0100]",
            "#   [0010]                [0110]",
            "# [0001]    [0011]      [0111]      [1111]",
            "class BinaryIndexedTree:",
            "    # 初期化処理",
            "    def __init__(self, size):",
            "        self.size = size",
            "        self.dat = [0]*(size+1)",
            "        self.depth = size.bit_length()",
            "",
            "    def init(self, a):",
            "        for i, x in enumerate(a):",
            "            self.add(i, x)",
            "",
            "    def add(self, i, x):",
            "        i += 1",
            "        while i <= self.size:",
            "            self.dat[i] += x",
            "            i += i & -i # 更新すべき位置",
            "",
            "    def update(self, i, x):",
            "        x -= self[i]",
            "        self.add(i, x)",
            "",
            "    def sum(self, r):",
            "        \"\"\"",
            "        Returns",
            "        -------",
            "        sum of [0, r]",
            "        \"\"\"",
            "        r += 1",
            "        ret = 0",
            "        while r>0:",
            "            ret += self.dat[r]",
            "            r -= r & -r # 加算すべき位置",
            "        return ret",
            "",
            "    def range_sum(self, l, r):",
            "        \"\"\"閉区間 [l,r] の合計を取得する",
            "",
            "        Returns",
            "        -------",
            "        sum of [l, r]",
            "        \"\"\"",
            "        if l == 0:",
            "            return self.sum(r)",
            "        else:",
            "            return self.sum(r) - self.sum(l-1)",
            "",
            "",
            "    def __getitem__(self, i):",
            "        return self.range_sum(i, i)",
            "",
            "",
            "    def right_bound_of_x(self, x):",
            "        # pos       : sum([0, pos]) < x     となる最大のindex",
            "        sum_, pos = 0, 0",
            "        for i in range(self.depth, -1, -1):",
            "            k = pos + (1 << i)",
            "            if k <= self.size and sum_ + self.dat[k] <= x:",
            "                sum_ += self.dat[k]",
            "                pos += 1 << i",
            "        return pos",
            "",
            "    def right_bound_include_x(self, x):",
            "        # pos       : sum([0, pos]) <= x     となる最大のindex",
            "        sum_, pos = 0, 0",
            "        for i in range(self.depth, -1, -1):",
            "            k = pos + (1 << i)",
            "            if k <= self.size and sum_ + self.dat[k] < x:",
            "                sum_ += self.dat[k]",
            "                pos += 1 << i",
            "        return pos",
            "",
            "    def left_bound_of_x(self, x):",
            "        # pos   : x < sum([0, pos])  となる最小のindex",
            "        return self.right_bound_include_x(x) - 1",
            "",
            "    def left_bound_include_x(self, x):",
            "        # pos   : x <= sum([0, pos])  となる最小のindex",
            "        return self.right_bound_of_x(x) - 1",
            "",
            "",
            "#### for debug",
            "    def _get_original_sequence(self):",
            "        ret = [self[i] for i in range(self.size)]",
            "        return ret",
            "",
            "    def _get_aggrigate_sequence(self):",
            "        return [self.sum(i) for i in range(self.size)]",
            "",
            "    def __str__(self):",
            "        seq = self._get_original_sequence()",
            "        ret = 'original :' + ' '.join(map(str, seq))",
            "        ret += '\\n'",
            "        seq = self._get_aggrigate_sequence()",
            "        ret += 'aggrigate:' + ' '.join(map(str, seq))",
            "        return ret",
            "",
            "########################################",
            "",
            "a = [5,3,7,9,6,4]",
            "n = len(a)",
            "",
            "bit = BinaryIndexedTree(n)",
            "bit.init(a)",
            "",
            "print(bit[1])",
            "for i in range(36):",
            "    print(i, bit.right_bound_of_x(i), bit.right_bound_include_x(i), bit.left_bound_of_x(i), bit.left_bound_include_x(i))",
            "",
            "print(bit)"
        ],
        "description": []
    },
    "全方位木DP": {
        "prefix": [
            "Lib_GT_全方位木DP"
        ],
        "body": [
            "",
            "from collections import deque",
            "",
            "class Tree():",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.edges = [[] for _ in range(n)]",
            "        self.root = None    # 根",
            "        self.size = [1] * n # 部分木のノード数",
            "        self.depth = [-1] * self.n",
            "        self.par = [-1] * self.n",
            "        self.order = [] # 深さ優先探索の行きがけ順",
            "",
            "    def add_edge(self, u, v):",
            "        self.edges[u].append(v)",
            "        self.edges[v].append(u)",
            "",
            "    def set_root(self, root):",
            "        self.root = root",
            "        self.depth[root] = 0",
            "        self.order.append(root)",
            "        nxt_q = deque([root])",
            "        while nxt_q:",
            "            p = nxt_q.pop() # 深さ優先探索",
            "            for q in self.edges[p]:",
            "                if self.depth[q] != -1: continue",
            "                self.par[q] = p",
            "                self.depth[q] = self.depth[p] + 1",
            "                self.order.append(q)",
            "                nxt_q.append(q)",
            "        for p in self.order[::-1]:",
            "            for q in self.edges[p]:",
            "                if self.par[p] == q: continue",
            "                self.size[p] += self.size[q]",
            "",
            "    def rerooting(self, merge, op, fin, id):",
            "        dp1 = [id] * self.n",
            "        dp2 = [id] * self.n",
            "        for p in self.order[::-1]:",
            "            t = id",
            "            for q in self.edges[p]:",
            "                if self.par[p] == q: continue",
            "                dp2[q] = t",
            "                t = merge(t, op(dp1[q], p, q))",
            "            t = id",
            "            for q in self.edges[p][::-1]:",
            "                if self.par[p] == q: continue",
            "                dp2[q] = merge(t, dp2[q])",
            "                t = merge(t, op(dp1[q], p, q))",
            "            dp1[p] = t",
            "        for q in self.order[1:]:",
            "            pq = self.par[q]",
            "            dp2[q] = op(merge(dp2[q], dp2[pq]), q, pq)",
            "            dp1[q] = merge(dp1[q], dp2[q])",
            "        for q in self.order:",
            "            pq = self.par[q]",
            "            dp1[q] = fin(dp1[q], pq)",
            "",
            "        return dp1",
            "",
            "n = int(input())",
            "T = Tree(n)",
            "cost = dict()",
            "for _ in range(n-1):",
            "    a, b = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    T.add_edge(a, b)",
            "    cost[(a, b)] = 0",
            "    cost[(b, a)] = 0",
            "",
            "#######################################################",
            "# https://atcoder.jp/contests/abc160/tasks/abc160_f",
            "#####################################",
            "mod, lim = 10**9+7, 10**6                   # mod素数, 出力の制限",
            "g1, g2 = [[1]*(lim+1) for _ in range(2)]    # ！と逆元tbl",
            "for i in range(2, lim + 1):",
            "    g1[i] = g1[i-1] * i % mod",
            "g2[-1] = pow(g1[-1], mod-2, mod)",
            "for i in range(lim, 0, -1):",
            "    g2[i-1] = g2[i] * i % mod",
            "",
            "def fac(n): return g1[n]",
            "def facinv(n): return g2[n]",
            "#####################################",
            "# a, bはdpの値, pは考察している接点親, qは子",
            "# dpをmerge",
            "merge = lambda a, b: (a[0] * b[0] * facinv(a[1]) * facinv(b[1]) * fac(a[1]+b[1]) % mod, a[1] + b[1])",
            "# dpをmerge前にする作業",
            "op = lambda a, p, q: (a[0], a[1] + 1)",
            "# dpをmerge後にする作業",
            "fin = lambda a, p: (a[0] * fac(a[1]) % mod, a[1])",
            "# mergeの単位元",
            "id = (1, 0)",
            "",
            "#######################################################",
            "# https://atcoder.jp/contests/s8pc-4/tasks/s8pc_4_d",
            "# a, bはdpの値, pは考察している接点親, qは子",
            "# dpをmerge",
            "merge = lambda a, b: a + b",
            "# dpをmerge前にする作業",
            "op = lambda a, p, q: a / (len(T.edges[q])-1) + 1 if a != 0 else 1",
            "# dpをmerge後にする作業",
            "fin = lambda a, p: a / len(T.edges[p])",
            "# mergeの単位元",
            "id = 0",
            "",
            "#######################################################",
            "# https://atcoder.jp/contests/abc222/tasks/abc222_f",
            "# a, bはdpの値, pは考察している接点親, qは子",
            "# dpをmerge",
            "merge = lambda a, b: max(a, b)",
            "# dpをmerge前にする作業",
            "D = list(map(int, input().split()))",
            "op = lambda a, p, q: max(a, D[v]) + cost[(p, q)]",
            "# dpをmerge後にする作業",
            "fin = lambda a, p: a",
            "# mergeの単位元",
            "id = 0",
            "#######################################################",
            "",
            "T.set_root(0)",
            "dp = T.rerooting(merge, op, fin, id)",
            "ret = [dpi[0] for dpi in dp]",
            "print(\"\\n\".join(map(str, ret)))",
            ""
        ],
        "description": [
            "全方位木DP",
            "https://algo-logic.info/tree-dp/"
        ]
    },
    "nCr": {
        "prefix": [
            "Lib_N_nCr剰余"
        ],
        "body": [
            "",
            "",
            "#####################################",
            "# nCr % 10**9+7",
            "# http://zakii.la.coocan.jp/enumeration/10_balls_boxes.htm",
            "#####################################",
            "mod, lim = 10**9+7, 10**6                   # mod素数, 出力の制限",
            "g1, g2 = [[1]*(lim+1) for _ in range(2)]    # ！と逆元tbl",
            "for i in range(2, lim + 1):",
            "    g1[i] = g1[i-1] * i % mod",
            "g2[-1] = pow(g1[-1], mod-2, mod)",
            "for i in range(lim, 0, -1):",
            "    g2[i-1] = g2[i] * i % mod",
            "",
            "def fac(n): return g1[n]",
            "def facinv(n): return g2[n]",
            "def nCr(n, r):",
            "    \"\"\"nCr",
            "    n個のものからr個選ぶ",
            "    \"\"\"",
            "    if ( r<0 or r>n ):",
            "        return 0",
            "    r = min(r, n-r)",
            "    return fac(n) * facinv(r) * facinv(n-r) % mod",
            "",
            "ret = nCr(4, 2)",
            "",
            "#####################################",
            "nは大きいが固定で,rは小さい場合",
            "#####################################",
            "class Combination:",
            "    \"\"\"nCrの前計算",
            "",
            "    Parameters",
            "    ----------",
            "    n : int, optional",
            "        n固定 by default 1",
            "    mod : int, optional",
            "        modの値, by default 10**9+7",
            "",
            "    Note:",
            "    ----------",
            "    nCr % 10**9+7  n～10^9 r～10^5",
            "    nは大きいが固定で,rは小さい場合",
            "    \"\"\"",
            "    def __init__(self, n : int=10**9, mod : int=10**9+7) -> None:",
            "        self.n = n",
            "        self.max_r = 1",
            "        self.mod = mod",
            "        self.nCrseq = [1, n%mod]",
            "",
            "",
            "    def __preprocessing(self, max_r:int) -> None:",
            "        seq = self.nCrseq",
            "        mod = self.mod",
            "        seq += [0] * (max_r - self.max_r)",
            "        for i in range(self.max_r + 1, max_r + 1):",
            "            seq[i] = (seq[i-1] * (self.n-i+1) * pow(i,mod-2,mod)) % mod",
            "        self.max_r = max_r",
            "",
            "",
            "    def nCr(self, r:int) -> int:",
            "        if r > self.max_r: self.__preprocessing(r)",
            "        return self.nCrseq[r]",
            "",
            "cmb = Combination(10)",
            "print(cmb.nCr(4))",
            "",
            "",
            "",
            "#####################################",
            "# nCr % 3",
            "#####################################",
            "class combination_mod_3:",
            "    def __init__(self):",
            "        n = 10**6",
            "        self.bf = [0] * n",
            "        self.bg = [0] * n",
            "        self.bg[0] = 1",
            "",
            "        for i in range(1, n):",
            "            pos = i",
            "            while pos % 3 == 0:",
            "                pos //= 3",
            "                self.bf[i] += 1",
            "            self.bg[i] = pos % 3",
            "",
            "        for i in range(1, n):",
            "            self.bf[i] += self.bf[i-1]",
            "            self.bg[i] = self.bg[i] * self.bg[i-1] % 3",
            "        self.MaxN = n",
            "",
            "    def nCr(self, n, r):",
            "        bf = self.bf",
            "        if bf[n] != bf[r] + bf[n-r]: return 0",
            "        bgn = self.bg[n]",
            "        bgrnr = self.bg[r] * self.bg[n-r]",
            "        if bgn == 1 and bgrnr == 1: return 1",
            "        if bgn == 1 and bgrnr == 2: return 2",
            "        if bgn == 1 and bgrnr == 4: return 1",
            "        if bgn == 2 and bgrnr == 1: return 2",
            "        if bgn == 2 and bgrnr == 2: return 1",
            "        if bgn == 2 and bgrnr == 4: return 2",
            "        return -1",
            "",
            "c = combination_mod_3()",
            "print(c.nCr(5,1))   #5mod3->2",
            "print(c.nCr(5,2))   #10mod3->1",
            "print(c.nCr(6,2))   #15mod3->0",
            "print(c.nCr(6,3))   #20mod3->2",
            ""
        ],
        "description": [
            "nCr剰余"
        ]
    },
    "ユニオンファインド": {
        "prefix": [
            "Lib_G_unionfind"
        ],
        "body": [
            "class UnionFind:",
            "    def __init__(self, n):                      # 初期化",
            "        self.n = n                              # 要素数",
            "        self.parents = [i for i in range(n)]    # 親",
            "        self.ranks = [0] * n                    # 木の深さ",
            "        self.sizes = [1] * n                    # グループの要素数",
            "        self.group_count = n                    # グループの数",
            "",
            "",
            "    def find(self, x):",
            "        \"\"\"親を出力",
            "        Parameters",
            "        ----------",
            "        x : int",
            "            ノード番号",
            "        \"\"\"",
            "        if self.parents[x] == x: return x",
            "        self.parents[x] = p = self.find(self.parents[x])",
            "        return p",
            "",
            "    def unite(self, x, y):",
            "        \"\"\"ユニオン",
            "        \"\"\"",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y: return",
            "        if self.ranks[x] > self.ranks[y]:",
            "            x , y = y, x    #yを親にする",
            "        elif self.ranks[x] == self.ranks[y]:",
            "            self.ranks[y] += 1",
            "        self.parents[x] = y",
            "        self.sizes[y] += self.sizes[x]",
            "        self.group_count -= 1",
            "",
            "    def same(self, x, y) -> bool:",
            "        \"\"\"xとyが同じグループかどうか",
            "        \"\"\"",
            "        return self.find(x) == self.find(y)",
            "",
            "    def members(self, x):",
            "        \"\"\"xと同じグループの要素",
            "        \"\"\"",
            "        root = self.find(x)",
            "        return [i for i in range(self.n) if self.find(i) == root]",
            "",
            "    def size(self, x):",
            "        \"\"\"xのグループの要素数",
            "        \"\"\"",
            "        return self.sizes[self.find(x)]",
            "",
            "    def get_roots(self):",
            "        \"\"\"親のリスト取得",
            "           親ごとのグループのメンバー一覧取得",
            "        \"\"\"",
            "        _dum = [[] for _ in range(self.n)]",
            "        self.roots = []",
            "        self.group_members = dict()",
            "        for x in range(self.n):",
            "            r = self.find(x)",
            "            if r == x:",
            "                self.roots.append(r)",
            "            _dum[r].append(x)",
            "        for r in self.roots:",
            "            self.group_members[r] = _dum[r]",
            "",
            "",
            "    def __str__(self):",
            "        return '\\n'.join(f'{r}: {self.members(r)}' for r in self.roots)",
            "",
            "################",
            "",
            "n, q = map(int, input().split())",
            "uf = UnionFind(n)",
            "for _ in range(q):",
            "    p, a, b = map(int,input().split())",
            "    a -= 1; b -= 1",
            "    if p == 0:",
            "        uf.unite(a, b)",
            "    else:",
            "        if uf.same(a, b):",
            "            print('Yes')",
            "        else:",
            "            print('No')",
            "",
            "# https://atcoder.jp/contests/atc001/tasks/unionfind_a",
            ""
        ],
        "description": [
            "ユニオンファインド"
        ]
    },
    "ローリングハッシュ": {
        "prefix": [
            "Lib_Str_RollingHash"
        ],
        "body": [
            "# https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_bd",
            "",
            "class RollingHash:",
            "    def __init__(self, s:str, base=31, mod=10**9+7):",
            "        self.mod = mod",
            "        self.pw = pw = [1]*(len(s)+1)",
            "        self.length = l = len(s)",
            "        self.h = h = [0]*(l+1)",
            "        v, t = 0, 1",
            "        for i in range(l):",
            "            v, t = v * base, t * base",
            "            v += ord(s[i])",
            "            v, t = v % mod, t % mod",
            "            h[i+1], pw[i+1] = v, t",
            "",
            "    def get(self, l, r):",
            "        # returns hashvalue of [l, r)",
            "        return (self.h[r] - self.h[l] * self.pw[r-l]) % self.mod",
            "",
            "q = int(input())",
            "s = input()",
            "RHS = RollingHash(s)",
            "",
            "for _ in range(q):",
            "    a, b, c, d = map(int, input().split())",
            "    hash1 = RHS.get(a, b)",
            "    hash2 = RHS.get(c, d)",
            "",
            "    if hash1 == hash2:",
            "        print('Yes')",
            "    else:",
            "        print('No')",
            ""
        ],
        "description": []
    },
    "オイラーツアー eulartour 再帰版": {
        "prefix": [
            "Lib_GT_オイラーツアー_再帰版_eulartour"
        ],
        "body": [
            "# オイラーツアー eulartour 再帰版",
            "# 木をDFSしたときの順番で頂点を記録する手法",
            "# pre-order : 頂点に到着したら記録",
            "# post-order : 頂点から離れるときに記録",
            "# - 根付き木のある頂点からの部分木に対するクエリを処理",
            "# - ある頂点がある頂点の部分木に含まれるかを高速に判定する",
            "# - 上手くオイラーツアーを作るとパスのコストの総和が取れる",
            "# n = 5",
            "# 0",
            "# |",
            "# 1",
            "# |",
            "# 2",
            "# |  \\",
            "# 4  3",
            "#",
            "# etnodes = [0,1,2,4,2,3,2,1,0]",
            "# etdepth = [0,1,2,3,2,3,2,1,0]",
            "# etdetL = [0,1,2,5,3]",
            "# etdetR = [9,8,7,6,4]",
            "",
            "",
            "class EulerTour():",
            "    def __init__(self, n, G):",
            "        self.n = n",
            "        self.edges = G",
            "        self.root = None    # 根",
            "        self.etnodes = []    # i番目の頂点番号",
            "        self.etedges = []    # i番目の辺の番号",
            "        self.etL = [-1] * n  # in time",
            "        self.etR = [-1] * n  # out time",
            "        self.depthbynodes = [0] * n",
            "        self.etdepth = []       # i番目の頂点番号の深さ",
            "",
            "",
            "    def set_euler_tour(self, root):",
            "        self.root = root        # 根を設定して",
            "        self._dfs(root)",
            "        self._set_timestamp()",
            "",
            "    def _dfs(self, cur, last=-1):",
            "        ################## 行きがけ処理",
            "        depth = 0",
            "        if last != -1:",
            "            depth = self.depthbynodes[last] + 1",
            "        self.depthbynodes[cur] = depth",
            "        self.etnodes.append(cur)",
            "        self.etdepth.append(depth)",
            "",
            "        for nxt in self.edges[cur]:",
            "            if nxt == last: continue",
            "            self._dfs(nxt, cur)",
            "            ################## 帰りがけ処理",
            "            self.etnodes.append(cur)",
            "            self.etdepth.append(depth)",
            "",
            "",
            "    def _set_timestamp(self):",
            "        for ct, now in enumerate(self.etnodes):",
            "            if self.etL[now] == -1:",
            "                self.etL[now] = ct",
            "            self.etR[now] = ct + 1",
            "",
            "",
            "#########################################",
            "def int1(x): return int(x)-1",
            "n = int(input())",
            "G = [[] for _ in range(n)]",
            "for _ in range(n-1):",
            "    a, b = map(int, input().split())",
            "#    a, b = map(int1, input().split())",
            "    G[a].append(b)",
            "    G[b].append(a)",
            "",
            "T = EulerTour(n, G)",
            "",
            "T.set_euler_tour(0)",
            "print(T.etnodes)",
            "print(T.etedges)",
            "print(T.etdepth)",
            "",
            "print(T.etL)",
            "print(T.etR)",
            "print(T.depthbynodes)",
            "",
            "\"\"\"",
            "8",
            "0 6",
            "0 5",
            "6 4",
            "5 2",
            "5 1",
            "5 7",
            "2 3",
            "\"\"\"",
            ""
        ],
        "description": [
            "オイラーツアー eulartour 再帰版"
        ]
    },
    "Graph最短パス": {
        "prefix": [
            "Lib_G_最短パス"
        ],
        "body": [
            "",
            "# root から始めて一番遠いところにあるノードを見つける",
            "from collections import deque",
            "def bfs(n, G, root=0, cost=1):",
            "    _depth = [None] * n",
            "    q = deque()",
            "    q.append(root)",
            "    _depth[root] = 0",
            "    _parent = [-1] * n",
            "    while q:",
            "        cur = q.popleft()",
            "        dep = _depth[cur]",
            "        for nxt in G[cur]:",
            "            if type(nxt) != int: nxt, cost = nxt",
            "            if _depth[nxt] != None: continue",
            "            newdep = dep + cost",
            "            q.append(nxt)",
            "            _parent[nxt] = cur",
            "            _depth[nxt] = newdep",
            "            if newdep > farest_dist:",
            "                farest_dist = newdep",
            "                farest_node = nxt",
            "    return farest_node, farest_dist, _depth",
            "",
            "",
            "##############################",
            "",
            "",
            "n = int(input())",
            "G = [[] for _ in range(n)]",
            "for _ in range(n-1):",
            "    a, b, w = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    G[a].append((b, w))",
            "    G[b].append((a, w))",
            "",
            "",
            ""
        ],
        "description": [
            "Graph最遠パス"
        ]
    },
    "Graph最大フロー": {
        "prefix": [
            "Lib_GD_最大フロー_maximumflow_dinic"
        ],
        "body": [
            "",
            "# 最大流問題",
            "# 始点sと終点tが区別された有向グラフ",
            "# 各辺(u,v)には容量c(u,v)が設定されており、超えないフローが流れます。",
            "# 始点sから終点tへの最大流を求める。",
            "#",
            "# Dinic's algorithm",
            "# 幅優先探索で水を流す向きをざっと決める．",
            "# 深さ優先探索で決められた向きで流せる経路を探し，水を流す．",
            "# 流せなくなったら1に戻る.",
            "# O(∣V∣**2・∣E∣)",
            "# https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/all/GRL_6_A",
            "from collections import deque",
            "class Dinic:",
            "    def __init__(self, n:int) -> None:",
            "        self.n = n",
            "        self.inf = float('inf')",
            "        self.g = [[] for i in range(n)]",
            "        self.depth = None",
            "        self.progress = None",
            "",
            "",
            "    def add_edge(self, fm:int, to:int, cap:int):",
            "        # cap: 容量, to/fm:行き先, rev:相方の辺",
            "        forward = [cap, to, len(self.g[to])]",
            "        backward = [0, fm, len(self.g[fm])]",
            "        self.g[fm].append(forward)",
            "        self.g[to].append(backward)",
            "",
            "    # sからの最短距離を計算",
            "    def bfs(self, s:int):",
            "        depth = [-1] * self.n",
            "        depth[s] = 0",
            "        q = deque([s])",
            "        while q:",
            "            v = q.popleft()",
            "            for cap, to, rev in self.g[v]:",
            "                if cap == 0: continue",
            "                if depth[to] >= 0:continue",
            "                depth[to] = depth[v] + 1",
            "                q.append(to)",
            "        self.depth = depth",
            "",
            "    # 増加パスをdfsで探す",
            "    def dfs(self, v:int, t:int, flow:int):",
            "        if v == t: return flow",
            "        g_v = self.g[v]",
            "        for i in range(self.progress[v], len(g_v)):",
            "            self.progress[v] = i",
            "            cap, to, rev = g = g_v[i]",
            "            if cap == 0: continue",
            "            if self.depth[v] >= self.depth[to]: continue",
            "            d = self.dfs(to, t, min(flow, cap))",
            "            if d == 0: continue",
            "            g[0] -= d",
            "            self.g[to][rev][0] += d",
            "            return d",
            "        return 0",
            "",
            "    def max_flow(self, s, t):",
            "        flow = 0",
            "        while True:",
            "            self.bfs(s)",
            "            if self.depth[t] < 0: return flow",
            "            self.progress = [0] * self.n",
            "            current_flow = self.dfs(s, t, self.inf)",
            "            while current_flow > 0:",
            "                flow += current_flow",
            "                current_flow = self.dfs(s, t, self.inf)",
            "",
            "",
            "",
            "",
            "#############",
            "n, m = map(int, input().split())",
            "mf = Dinic(n)",
            "for _ in range(m):",
            "    a, b, e = map(int, input().split())",
            "    a -= 1; b -= 1",
            "    mf.add_edge(a, b, e)",
            "",
            "print(mf.max_flow(0, n-1))",
            ""
        ],
        "description": [
            "Graph最大フロー"
        ]
    },
    "セグメント木区間更新一点集約": {
        "prefix": [
            "Lib_Q_Seg_区間更新一点集約"
        ],
        "body": [
            "class SegmentTree:  # 初期化処理",
            "    \"\"\"RUQ Segment Tree",
            "    区間更新・1点抽出",
            "    Parameters",
            "    ----------",
            "    a : list",
            "        初期リスト",
            "    e : 単位元",
            "        by default float('inf')",
            "    Notes",
            "    -----",
            "    1-indexed",
            "    https://onlinejudge.u-aizu.ac.jp/problems/DSL_2_D",
            "    \"\"\"",
            "    def __init__(self, n :int, ie):",
            "        self._n = n                             # 元のデータサイズ",
            "        self._log = (self._n - 1).bit_length()  # seg木の深さ",
            "        self._size = 1 << self._log             # seg木のサイズ",
            "        self._counter = 0",
            "        self.INF = (-1, ie)",
            "        # seg木の初期化",
            "        self._dat = [self.INF] * (2 * self._size)",
            "",
            "",
            "    def update(self, l, r, x):",
            "        \"\"\"半開区間[l, r)の値をxに更新",
            "        \"\"\"",
            "        _x = (self._counter, x)",
            "        l += self._size  # 1番下の層におけるインデックス",
            "        r += self._size  # 1番下の層におけるインデックス",
            "        # 左側の答えと右側の答えを初期化",
            "        while l < r:    # lとrが重なるまで上記の判定を用いて演算を実行",
            "            # 右が子同士の右側(rが奇数)(rの末桁=1)ならば、dat[r-1]を演算",
            "            if r & 1:",
            "                r -= 1",
            "                self._dat[r] = _x",
            "            # 左が子同士の右側(lが奇数)(lの末桁=1)ならば、dat[l]を演算",
            "            if l & 1:",
            "                self._dat[l] = _x",
            "                l += 1",
            "            l >>= 1",
            "            r >>= 1",
            "        self._counter += 1",
            "",
            "",
            "    def __query(self, k):",
            "        k += self._size",
            "        t = self.INF",
            "        while k > 0:",
            "            if self._dat[k]:",
            "                t = max(t, self._dat[k])",
            "            k >>= 1",
            "        return t",
            "",
            "",
            "    def query(self, k: int) -> int:",
            "        \"\"\"a_kを取得",
            "        \"\"\"",
            "        return self.__query(k)[1]",
            "",
            "",
            "    def __getitem__(self, i:int) -> int:",
            "        return self.query(i)",
            "",
            "",
            "",
            "###################################################",
            "n, q = map(int, input().split())",
            "",
            "ruq = SegmentTree(n+2, 2**31-1)",
            "",
            "for _ in range(q):",
            "    t, *qry = map(int, input().split())",
            "    if t == 0:",
            "        l, r, x = qry",
            "#        l -= 1",
            "        r += 1",
            "        ruq.update(l, r, x)",
            "    else:",
            "        i = qry[0]",
            "#        i -= 1",
            "        print(ruq[i])",
            ""
        ],
        "description": [
            "セグメント木区間更新一点集約"
        ]
    }
}