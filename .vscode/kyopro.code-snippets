{
    "ワーシャルフロイド法": {
        "prefix": [],
        "body": [],
        "description": []
    },
    "iscription#": {
        "prefix": [],
        "body": [],
        "description": []
    },
    "全頂点間最短路": {
        "prefix": [],
        "body": [],
        "description": []
    },
    "d[i][j]は2頂点間i, j間の移動コストを格納, Mは頂点数": {
        "prefix": [],
        "body": [],
        "description": []
    },
    "O(N^3)": {
        "prefix": [
            "Lib_S_最短経路探索_warshall"
        ],
        "body": [
            "import copy",
            "",
            "class warshall_floyd:",
            "    def __init__(self, n:int) -> None:",
            "        self.INF = float(\"inf\")",
            "        self.n = n",
            "        self.d = [[self.INF] * n for _ in range(n)]",
            "        #d[u][v] : 辺uvのコスト(存在しないときはinf)",
            "        for i in range(n):",
            "            self.d[i][i] = 0 #自身のところに行くコストは０",
            "",
            "",
            "",
            "    def build(self):",
            "        n = self.n",
            "        wf = copy.deepcopy(self.d)",
            "        for k in range(n):",
            "            for i in range(n):",
            "                for j in range(n):",
            "                    wf[i][j] = min(wf[i][j], wf[i][k] + wf[k][j])",
            "",
            "        self.wf = wf #wf[i][j]に頂点i, j間の最短距離を格納",
            "",
            "",
            "    def add_edge(self, fm, to, cost):",
            "        self.d[fm][to] = cost",
            "",
            "",
            "    # 負値閉路検索",
            "    @property",
            "    def is_neg_cycle(self) -> bool:",
            "        for i in range(self.n):",
            "            if self.wf[i][i] < 0:",
            "                return True",
            "        return False",
            "",
            "",
            "    # 経路復元",
            "    def path(self, s, g):",
            "        ret = []",
            "        if s == g or self.wf[s][g] == self.INF:",
            "            return ret",
            "        cur = s",
            "        while cur!=g:",
            "            for nxt in range(self.n):",
            "                if nxt==cur or nxt==s: continue",
            "                if self.d[cur][nxt] + self.wf[nxt][g] == self.wf[cur][g]:",
            "                    ret.append((cur, nxt))",
            "    #                ret.append((nxt, cur))",
            "                    cur = nxt",
            "                    break",
            "        return ret",
            "",
            "##############################",
            "",
            "n, m = map(int,input().split()) #N:頂点数 m:辺の数",
            "",
            "WF = warshall_floyd(n)",
            "",
            "for _ in range(m):",
            "    _u, _v, _w = map(int,input().split())",
            "    _u -= 1; _v -= 1",
            "    WF.add_edge(_u, _v, _w)",
            "    WF.add_edge(_v, _u, _w)",
            "",
            "WF.build()",
            "",
            "print(WF.path(0, n-1))",
            ""
        ],
        "description": []
    },
    "三分探索": {
        "prefix": [
            "lib_A_三分探索"
        ],
        "body": [
            "#######################",
            "# ムーアの法則",
            "# 三分探索/黄金分割探索",
            "#######################",
            "",
            "def f(x):",
            "    return x**2",
            "",
            "d = 0.000000001",
            "low, high = 0, 1000",
            "",
            "# 分割割合",
            "alp = 1/3           #三分探索",
            "alp = (3-5**0.5)/2  #黄金分割探索",
            "",
            "while abs(f(low) - f(high)) > d:",
            "    l_ = high * alp + (1-alp) * low",
            "    h_ = high * (1-alp) + alp * low",
            "    if f(h_) < f(l_):",
            "        low = l_",
            "    else:",
            "        high = h_",
            "print(f(low))",
            "",
            "",
            "",
            "#######################",
            "# 内包円",
            "# 三分探索",
            "# https://atcoder.jp/contests/abc151/tasks/abc151_f",
            "# 平面上の N 個の点 (xi, yi) が与えられます。",
            "# これら全てを内部または周上に含む円の半径の最小値を求めてください。",
            "#######################",
            "",
            "n = int(input())",
            "pt = [tuple(map(int, input().split())) for i in range(n)]",
            "",
            "def f(x, y):",
            "    # (x, y)を与えたときに、各点との距離の最大値",
            "    return max([((x-u)**2 + (y-v)**2)**0.5 for u, v in pt])",
            "",
            "d = 0.0000001",
            "",
            "def g(x):",
            "    low, high = 0, 1000",
            "    for i in range(80):",
            "        l_ = (high+2*low)/3",
            "        h_ = (high*2+low)/3",
            "        if f(x, h_)<f(x, l_):",
            "            low = l_",
            "        else:",
            "            high = h_",
            "    return f(x, low)",
            "",
            "",
            "low, high = 0, 1000",
            "for i in range(80):",
            "    l_ = (high+2*low)/3",
            "    h_ = (high*2+low)/3",
            "    if g(h_)<g(l_):",
            "        low = l_",
            "    else:",
            "        high = h_",
            "",
            "print(g(low))",
            ""
        ],
        "description": [
            "三分探索"
        ]
    },
    "二分探索": {
        "prefix": [
            "lib_A_二分探索"
        ],
        "body": [
            "def is_ok(x):",
            "    ###",
            "    return True",
            "ok = x",
            "ng = y",
            "while abs(ok - ng) > 1:",
            "    mid = (ok + ng) // 2",
            "    if is_ok(mid): ok = mid",
            "    else: ng = mid",
            "print(ok)"
        ],
        "description": [
            "二分探索"
        ]
    },
    "約数列挙": {
        "prefix": [
            "Lib_N_約数列挙"
        ],
        "body": [
            "##############################",
            "# 約数列挙 O(n**0.5)",
            "# returns sorted list",
            "##############################",
            "def make_divisors(n:int) -> list:",
            "    lower_divisors, upper_divisors = [], []",
            "    for i in range(1, int(n**0.5)+1):",
            "        if n % i != 0: i += 1; continue",
            "        lower_divisors.append(i)",
            "        j = n // i",
            "        if i != j: upper_divisors.append(j)",
            "    return lower_divisors + upper_divisors[::-1]",
            "",
            "#####################",
            "print(make_divisors(10))",
            "#####################",
            ""
        ],
        "description": []
    },
    "escripiton#": {
        "prefix": [],
        "body": [],
        "description": []
    },
    "bfs迷路listタイプ": {
        "prefix": [
            "Lib_G_迷路listタイプ"
        ],
        "body": [
            "# https://atcoder.jp/contests/abc007/tasks/abc007_3",
            "",
            "h, w = map(int, input().split())",
            "s = list(map(int, input().split()))",
            "t = list(map(int, input().split()))",
            "s[0] -= 1; s[1] -= 1",
            "t[0] -= 1; t[1] -= 1",
            "",
            "s = (s[0]+1) * (w+2) + (s[1]+1)",
            "t = (t[0]+1) * (w+2) + (t[1]+1)",
            "",
            "wall = 1                                  # 適宜修正",
            "g = []",
            "g += [wall] * (w + 2)",
            "for i in range(h):",
            "    g.append(wall)",
            "    gi = input()",
            "    for j, gij in enumerate(gi):",
            "        g.append(wall if gij == \"#\" else 0)  # 適宜修正",
            "    g.append(wall)",
            "g += [wall] * (w + 2)",
            "h, w = h+2, w+2",
            "",
            "def bfs(h, w, s, t):",
            "    direc = (-w, w, 1, - 1)",
            "    seen = [-1] * (h*w)",
            "    que = deque([s])",
            "    seen[s] = 0",
            "    while que:",
            "        nw = que.popleft()",
            "        nd = seen[nw]",
            "        for di in direc:",
            "            nx = nw + di",
            "            if seen[nx] != -1 or g[nx] == wall: continue",
            "            que.append(nx)",
            "            seen[nx] = nd + 1",
            "    return seen",
            "",
            "print(bfs(h, w, s, t)[t])"
        ],
        "description": [
            "bfs迷路listタイプ"
        ]
    },
    "素数判定・出力": {
        "prefix": [
            "Lib_N_prime_素数"
        ],
        "body": [
            "",
            "##############################",
            "# 素数判定 O(n**0.5)",
            "##############################",
            "def is_prime(n:int) -> bool:",
            "    if n in {0, 1}: return False",
            "    if n == 2: return True",
            "    if n % 2 == 0: return False",
            "    for i in range(3, int(n**0.5)+1, 2):",
            "        if n % i == 0: return False",
            "    return True",
            "",
            "#####################",
            "print(10, is_prime(10))",
            "print(31, is_prime(31))",
            "#####################",
            "",
            "",
            "##############################",
            "# 素数出力 O(n**0.5)",
            "##############################",
            "def get_primes(n:int) -> list:",
            "# n以下の素数列挙",
            "    n += 1",
            "    IsPrime = [True] * n",
            "    IsPrime[0], IsPrime[1] = False, False",
            "    for p in range(n):",
            "        if not IsPrime[p]: continue",
            "        for j in range(p*2, n, p):",
            "            IsPrime[j] = False",
            "    ret = [p for p in range(n) if IsPrime[p]]",
            "    return ret",
            ""
        ],
        "description": []
    },
    "translate": {
        "prefix": [
            "translate",
            "replace"
        ],
        "body": [
            "s = '54IZSB'",
            "ts = s.translate(str.maketrans(\"BSI\",\"123\"))",
            "print(ts)",
            "# 543Z21"
        ],
        "description": [
            "複数の文字列を変換"
        ]
    },
    "d進数": {
        "prefix": [
            "n進数",
            "d進数"
        ],
        "body": [
            "##############################",
            "# nをd進数表記",
            "# d進数表記を10進数表記に",
            "##############################",
            "",
            "n = 32",
            "",
            "print(format(n, 'b'))  # ２進数",
            "print(format(n, 'o'))  # ８進数",
            "print(format(n, 'x'))  # 16進数",
            "",
            "print(bin(n))  # ２進数",
            "print(oct(n))  # ８進数",
            "print(hex(n))  # 16進数",
            "",
            "# 任意のd進数",
            "def base_repr(n:int, d:int) -> str:",
            "    ret = ''",
            "    while n != 0:",
            "        n, r = divmod(n, d)",
            "        ret += str(r)",
            "    return ret[::-1]",
            "",
            "print(base_repr(n, 2))",
            "print(base_repr(n, 30))",
            "",
            "",
            "##############################",
            "# d進数表記を10進数表記に",
            "##############################",
            "s = '12'",
            "d = 9",
            "print(int(s, base=d))",
            "",
            "# 関数版",
            "def myint(s:str, d:int) -> int:",
            "    ret = 0",
            "    dig = 1",
            "    for xi in s[::-1]:",
            "        ret += int(xi)*dig",
            "        dig *= d",
            "    return ret",
            "",
            "print(myint(s, 9))",
            ""
        ],
        "description": [
            "nをd進数表記"
        ]
    },
    "LCS最長共通部分列": {
        "prefix": [
            "Lib_LCS最長共通部分列#"
        ],
        "body": [
            "#####################################",
            "# LCS(longest common sequence)",
            "# 部分列で最長の共通のもの",
            "#####################################",
            "# https://atcoder.jp/contests/dp/tasks/dp_f",
            "",
            "# dp[i+1][j+1]:= s の i 文字目までと t の j 文字目まででの LCS の長さ",
            "class LCS:",
            "    def __init__(self, S, T) -> None:",
            "        self.Type = type(S)",
            "        if self.Type == str:",
            "            S = list(S)",
            "            T = list(T)",
            "        self.S = S",
            "        self.T = T",
            "        self.ls = len(S)",
            "        self.lt = len(T)",
            "        self.dp = [[0]*(self.lt+1) for _ in range(self.ls+1)]",
            "        dp = self.dp",
            "        for i in range(self.ls):",
            "            for j in range(self.lt):",
            "                if S[i] == T[j]:",
            "                    dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j] + 1)",
            "                else:",
            "                    dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1])",
            "",
            "",
            "    def length(self):",
            "        # LCSの長さ",
            "        return self.dp[self.ls][self.lt]",
            "",
            "",
            "    def restore(self):",
            "        # 復元",
            "        ret = []",
            "        i, j = self.ls, self.lt",
            "        dp = self.dp",
            "        while i and j:",
            "            # (i-1, j) -> (i, j) と更新されていた場合",
            "            if dp[i][j] == dp[i-1][j]:",
            "                i-=1   # DP の遷移を遡る",
            "            # (i, j-1) -> (i, j) と更新されていた場合",
            "            elif dp[i][j] == dp[i][j-1]:",
            "                j-=1   # DP の遷移を遡る",
            "            # (i-1, j-1) -> (i, j) と更新されていた場合",
            "            else:",
            "                ret.append(self.S[i-1])",
            "                # このとき s[i-1] == t[j-1] なので、t[j-1] + res でも OK",
            "                i-=1",
            "                j-=1   # DP の遷移を遡る",
            "        ret = ret[::-1]",
            "        if self.Type == str: ret = ''.join(ret)",
            "        return ret",
            "",
            "",
            "#####################",
            "s = list(input())",
            "t = list(input())",
            "lcs = LCS(s, t)",
            "print(''.join(lcs.restore()))",
            ""
        ],
        "description": [
            "lib_LCS最長共通部分列"
        ]
    },
    "行列演算": {
        "prefix": [],
        "body": [],
        "description": []
    },
    "転置行列": {
        "prefix": [
            "transpose_matrix"
        ],
        "body": [
            "def trans(A):",
            "    return [list(x) for x in zip(*A)]"
        ],
        "description": [
            "転置行列"
        ]
    },
    "行列90度回転": {
        "prefix": [
            "Lib_M_rotate_matrix"
        ],
        "body": [
            "def rotate(A, reverse = False):",
            "    if reverse:",
            "        return [list(x) for x in zip(*A)][::-1]",
            "    else:",
            "        return [list(x) for x in zip(*A[::-1])]"
        ],
        "description": [
            "行列90度回転"
        ]
    },
    "包除原理": {
        "prefix": [
            "Lib_M_包除原理_houjo"
        ],
        "body": [
            "",
            "# 包除原理",
            "# n(A or B or C) = n(A) + n(B) + n(C)",
            "#                  -n(A&B) -n(B&C) -n(C&A)",
            "#                  +n(A&B&C)",
            "",
            "n, d = map(int, input().split())",
            "a = list(map(int, input().split()))",
            "",
            "def cnt(b):",
            "    cntzero = d - bin(b).count('1')",
            "    return 1 << cntzero",
            "",
            "ret = 0",
            "# bit全探索",
            "for i in range(1, 1<<n):",
            "    num = 0",
            "    c = 0",
            "    for j in range(n):",
            "        if i>>j & 1:",
            "        # iで考える集合jが存在する場合",
            "            num |= a[j]",
            "            c += 1",
            "    #x = n(****)",
            "    x = cnt(num)",
            "    #次数によりプラスとマイナスを変える",
            "    if c%2 == 1:",
            "        ret += x",
            "    else:",
            "        ret -= x",
            "",
            "ret = (1 << d) - ret",
            "",
            "print(ret)",
            ""
        ],
        "description": [
            "包除原理"
        ]
    },
    "転倒数": {
        "prefix": [
            "Lib_A_転倒数"
        ],
        "body": [
            "# 転倒数",
            "# 配列中 i<j, ai>ajとなるものの個数",
            "# https://atcoder.jp/contests/chokudai_S001/tasks/chokudai_S001_j",
            "# ex: a = [3, 5, 2, 0, 4, 1]  -> 10",
            "# index: 0  1  2  3  4  5",
            "# a    : 3  5  2  0  4  1",
            "# bit_0:          1*        (a_0=3) 右側/反転数0",
            "# bit_1:          1     1*  (a_1=5) 右側/反転数0",
            "# bit_2:       1* 1     1   (a_2=2) 右側/反転数2",
            "# bit_3: 1*    1  1     1   (a_3=0) 右側/反転数3",
            "# bit_4: 1     1  1  1* 1   (a_4=4) 右側/反転数1",
            "# bit_5: 1  1* 1  1  1  1   (a_5=1) 右側/反転数4",
            "",
            "class BinaryIndexedTree:",
            "    # 初期化処理",
            "    def __init__(self, size):",
            "        self.size = size",
            "        self.dat = [0]*(size+1)",
            "        self.depth = size.bit_length()",
            "",
            "    def add(self, i, x):",
            "        i += 1",
            "        while i <= self.size:",
            "            self.dat[i] += x",
            "            i += i & -i # 更新すべき位置",
            "",
            "    def sum(self, r):",
            "        r += 1",
            "        ret = 0",
            "        while r>0:",
            "            ret += self.dat[r]",
            "            r -= r & -r # 加算すべき位置",
            "        return ret",
            "",
            "def compress(points:list) -> list:",
            "    pos = {}",
            "    sx = set(points)",
            "    for i, xi in enumerate(sorted(set(sx))):",
            "        pos[xi] = i",
            "    return [pos[xi] for xi in points]",
            "",
            "def inv_numbers(a: list) -> int:",
            "    _a = compress(a)",
            "    bit = BinaryIndexedTree(max(_a) + 2)",
            "    ret = 0",
            "    for i, ai in enumerate(_a):",
            "        ret += i - bit.sum(ai)  #aiの位置より右側の合計=見てきた総計i - 左側の合計 => 反転数",
            "        bit.add(ai, 1)          #aiの位置にメモ",
            "    return ret",
            "",
            "###################################",
            "",
            "n = int(input())",
            "a = list(map(int, input().split()))",
            "ret = inv_numbers(a)",
            "print(ret)"
        ],
        "description": [
            "lib_転倒数"
        ]
    },
    "ダイクストラ法": {
        "prefix": [
            "Lib_S_最短経路探索_dijkstra"
        ],
        "body": [
            "# ダイクストラ法",
            "# 重み付きグラフ関係により最短経路のリストを作る",
            "# 有向グラフで優先度付きキューで探索",
            "# https://atcoder.jp/contests/abc035/tasks/abc035_d",
            "# O((E+V)logV)",
            "class dijkstra:",
            "    def __init__(self, n, edges):",
            "        self.n = n              # ノード数",
            "        self.edges = edges      # 有向グラフ",
            "        self.start = None       # 始点",
            "        self.edges_used = [-1] * n  # 最短経路木の親",
            "",
            "    def build(self, start):",
            "        INF = float('inf')",
            "        self.dist = [INF] * self.n",
            "        next_q = []",
            "        if type(start) is int:",
            "            start = [start]",
            "        for st in start:",
            "            self.dist[st] = 0",
            "            next_q.append((0, st))",
            "        heapify(next_q)",
            "        while next_q:",
            "            cd, cn = heappop(next_q)",
            "            if self.dist[cn] < cd: continue",
            "            for nn, nd in self.edges[cn]:",
            "                # 変則的な距離の場合はここを調整 ##",
            "                nd_ = self.dist[cn] + nd",
            "                ############################",
            "                if self.dist[nn] <= nd_: continue",
            "                self.dist[nn] = nd_",
            "                self.edges_used[nn] = cn",
            "                heappush(next_q, (nd_, nn))",
            "",
            "",
            "    def get_dist(self, goal):",
            "        return self.dist[goal]",
            "",
            "",
            "    def get_path(self, goal):",
            "        path = []",
            "        node = goal",
            "        while node is not None:",
            "            path.append(node)",
            "            node = self.edges_used[node]",
            "        return path[::-1]",
            "",
            "##########################################",
            "",
            "n, m, t = map(int, input().split())",
            "edges = [[] for _ in range(n)]",
            "edges_R = [[] for _ in range(n)]    #行きと帰りを分けた（有向グラフ）場合",
            "#リストの作成",
            "for _ in range(m):",
            "    a, b, c = map(int, input().split())",
            "    a, b = a-1, b-1",
            "    edges[a].append((b,c))",
            "    edges[b].append((a,c))",
            "    edges_R[b].append((a,c))        #行きと帰りを分けた（有向グラフ）場合",
            "",
            "dij = dijkstra(n, edges)  #クラスのインスタンス化",
            "dijR = dijkstra(n, edges_R)",
            "dij.build(0)",
            "dijR.build(0)",
            "",
            "dij.get_dist(n-1)",
            ""
        ],
        "description": [
            "ダイクストラ法",
            "辺の重みが小さいものから、決めていく",
            ""
        ]
    },
    "intinput": {
        "prefix": [
            "intinput"
        ],
        "body": [
            "int(input())"
        ],
        "description": [
            "int型でのinput"
        ]
    },
    "inputsplit": {
        "prefix": [
            "inputsplit"
        ],
        "body": [
            "input().split()"
        ],
        "description": [
            "inputをsplit"
        ]
    },
    "mapint": {
        "prefix": [
            "mapintinput"
        ],
        "body": [
            "map(int, input().split())"
        ],
        "description": [
            "int型で複数数値のinput"
        ]
    },
    "listmapint": {
        "prefix": [
            "listmapintinput"
        ],
        "body": [
            "list(map(int, input().split()))"
        ],
        "description": [
            "int型でlistのinput"
        ]
    },
    "tuplemapint": {
        "prefix": [
            "tuplemapintinput"
        ],
        "body": [
            "tuple(map(int, input().split()))"
        ],
        "description": [
            "int型でtupleのinput"
        ]
    },
    "matrixintinput": {
        "prefix": [
            "[listmapint"
        ],
        "body": [
            "[list(map(int, input().split())) for _ in range($n)"
        ],
        "description": [
            "int型でmatrixのinput"
        ]
    },
    "matrixinput": {
        "prefix": [
            "[tupleinput()"
        ],
        "body": [
            "[tuple(map(int, input().split())) for _ in range($n)]"
        ],
        "description": [
            "文字列でmatrixのinput"
        ]
    },
    "座標圧縮": {
        "prefix": [
            "compress_zaatsu",
            "lib_A_座標圧縮"
        ],
        "body": [
            "def compress(points, reverse=False, spacing=False):",
            "    \"\"\"一次元座標圧縮",
            "",
            "    Parameters",
            "    ----------",
            "    points : list",
            "         値のリスト [100,300,50,900,200]",
            "",
            "    Returns",
            "    -------",
            "    pos : {50: 0, 100: 1, 200: 2, 300: 3, 900: 4}",
            "    vals : {0: 50, 1: 100, 2: 200, 3: 300, 4: 900}",
            "    \"\"\"",
            "    pos = {}",
            "    vals = {}",
            "    sx = set(points)",
            "    if spacing:",
            "        for p in points:",
            "            sx.add(p+1)",
            "",
            "    for i, xi in enumerate(sorted(set(sx), reverse=reverse)):",
            "        pos[xi] = i",
            "        vals[i] = xi",
            "    sx_cmp = [pos[xi] for xi in sx]",
            "    return pos, vals, sx_cmp",
            "",
            "",
            "def compress2d(points, spacing=False):",
            "    \"\"\"二次元座標圧縮",
            "    \"\"\"",
            "    sx = [point[0] for point in points]",
            "    sy = [point[1] for point in points]",
            "    xpos, xvals, sx_cmp = compress(sx, False, spacing)",
            "    ypos, yvals, sy_cmp = compress(sy, False, spacing)",
            "    points_cmp = list(zip(sx_cmp, sy_cmp))",
            "",
            "    return xpos, ypos, xvals, yvals, points_cmp",
            ""
        ],
        "description": [
            "座標圧縮"
        ]
    },
    "各桁の寄与度": {
        "prefix": [
            "Lib_O_各桁の寄与度"
        ],
        "body": [
            "def sum_digit(s, d=10, mod=-1):",
            "    n = len(s)",
            "    ret = 0",
            "",
            "    pow_2 = [1]",
            "    pow_d = [1]",
            "    div = pow(d-2, mod - 2, mod)",
            "    for _ in range(n):",
            "        if mod == -1:",
            "            pow_2.append(pow_2[-1] * 2)",
            "            pow_d.append(pow_d[-1] * d)",
            "        else:",
            "            pow_2.append(pow_2[-1] * 2 % mod)",
            "            pow_d.append(pow_d[-1] * d % mod)",
            "",
            "    def _contribute(k):",
            "        r = pow_2[n-1-k] * ((d-1)* pow_d[k] - pow_2[k])",
            "        if mod == -1:",
            "            r //= d-2",
            "        else:",
            "            r *= div",
            "        return r",
            "",
            "",
            "    for i, si in enumerate(s[::-1]):",
            "        ret += _contribute(i) * int(si) % mod",
            "    return ret % mod",
            "",
            "mod = 998244353",
            "s = input()",
            "print(sum_digit(s, 10, mod))",
            ""
        ],
        "description": [
            "各桁の寄与度",
            "356"
        ]
    },
    "BIT演算subset": {
        "prefix": [
            "lib_BIT演算全部分集合"
        ],
        "body": [
            "# 集合Mの部分集合を列挙",
            "def subset(n)->list:",
            "    v = (-1) & n",
            "    ret = []",
            "    while v:",
            "        ret.append(v)",
            "        v = (v - 1) & n",
            "    return ret",
            "n = int('101', 2)",
            "print(list(map(bin, subset(n))))",
            "# ['0b101', '0b100', '0b1']",
            "",
            "# サイズKの部分集合を列挙",
            "def ksubset(n, k)->list:",
            "    ret = []",
            "    v = (1 << k) - 1",
            "    while v < (1 << n):",
            "        ret.append(v)",
            "        x = v & -v; y = v + x",
            "        v = ((v & ~y) // x >> 1) | y",
            "    return ret",
            "n, k = 5, 2",
            "print(list(map(bin, ksubset(n, k))))",
            "# ['0b11', '0b101', '0b110', '0b1001', '0b1010', '0b1100', '0b10001', '0b10010', '0b10100', '0b11000']",
            ""
        ],
        "description": [
            "集合Mの部分集合"
        ]
    },
    "lib_図形": {
        "prefix": [
            "lib_図形(円,三角形)"
        ],
        "body": [
            "def dist2(pt1, pt2): return sum([(x1-x2) ** 2 for x1, x2 in zip(pt1, pt2)])",
            "def distPtoP(pt1, pt2): return dist2(pt1, pt2) ** 0.5",
            "def distCtoC(c1, c2):",
            "    pt1, r1 = c1; pt2, r2 = c2; R, r, d = max(r1, r2), min(r1, r2), distPtoP(pt1, pt2)",
            "    return d-R-r if d > R+r else R-r-d if d < R-r else 0",
            "    # d > R+r :O o",
            "    # d < R-r: ◎",
            "    # else 交差",
            "",
            "# 反時計回りかどうか/内角が180以上",
            "def ccw(p1, p2, p3):",
            "    x1, y1 = p1[0] - p2[0], p1[1] - p2[1]",
            "    x3, y3 = p3[0] - p2[0], p3[1] - p2[1]",
            "    return x1 * y3 - x3 * y1 > 0",
            "",
            "",
            ""
        ],
        "description": [
            "図形のライブラリ"
        ]
    },
    "output0": {
        "prefix": [
            "print(0ret)"
        ],
        "body": [
            "print(ret)"
        ],
        "description": [
            "print(ret)"
        ]
    },
    "output": {
        "prefix": [
            "print(1Yes/No)"
        ],
        "body": [
            "print('Yes' if ret else 'No')"
        ],
        "description": [
            "print(Yes/No)"
        ]
    },
    "output2": {
        "prefix": [
            "print(2INF)"
        ],
        "body": [
            "print(-1 if ret == INF else ret)"
        ],
        "description": [
            "print(INF)"
        ]
    },
    "output3": {
        "prefix": [
            "print(3joinret)"
        ],
        "body": [
            "print('\\n'.join(ret))"
        ],
        "description": [
            "print(joinret)"
        ]
    },
    "output4": {
        "prefix": [
            "print(4join(map(str(ret)"
        ],
        "body": [
            "print('\\n'.join(map(str, ret)))"
        ],
        "description": [
            "print(join(map(str(ret)"
        ]
    },
    "output5": {
        "prefix": [
            "print(5interactive)"
        ],
        "body": [
            "print(ret, flush=True)"
        ],
        "description": [
            "interactive"
        ]
    },
    "半分全列挙": {
        "prefix": [
            "lib_A_半分全列挙"
        ],
        "body": [
            "# https://atcoder.jp/contests/abc184/tasks/abc184_f",
            "# 半分全列挙",
            "# n <= 40 だと半分で全列挙したものをそれぞれ計算してマージ処理する",
            "",
            "n, t = map(int, input().split())",
            "v = list(map(int, input().split()))",
            "",
            "def get_list(vl):",
            "    ret = [0]",
            "    svl = sorted(vl)",
            "    for vi in svl:",
            "        for j in range(len(ret)):",
            "            x = vi + ret[j]",
            "            if x > t: continue",
            "            ret.append(x)",
            "    return sorted(ret)",
            "",
            "lower = get_list(v[:n//2])",
            "upper = get_list(v[n//2:])",
            "",
            "ret = 0",
            "up = len(upper) - 1",
            "for f in lower:",
            "    while up >= 0 and (upper[up]+f) > t:",
            "        up -= 1",
            "    ret = max(ret, upper[up]+f)",
            "",
            "print(ret)",
            ""
        ],
        "description": [
            "半分全列挙"
        ]
    },
    "最小全域木": {
        "prefix": [
            "Lib_A_最小全域木_MST"
        ],
        "body": [
            "class UnionFind:",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parents = [i for i in range(n)]",
            "        self.ranks = [0] * n",
            "",
            "    def find(self, x):",
            "        p = self.parents[x]",
            "        if p == x: return x",
            "        self.parents[x] = p = self.find(p)",
            "        return p",
            "",
            "    def unite(self, x, y):",
            "        x = self.find(x); y = self.find(y)",
            "        if x == y: return",
            "        if self.ranks[x] > self.ranks[y]: x , y = y, x",
            "        if self.ranks[x] == self.ranks[y]: self.ranks[y] += 1",
            "        self.parents[x] = y",
            "",
            "    def same(self, x, y):",
            "        return self.find(x) == self.find(y)",
            "",
            "",
            "class Kruskal:",
            "    def __init__(self, n:int, edges:list)->None:",
            "        self.n = n",
            "        self.all_edges = edges",
            "        self.weight = None",
            "        self.edges = None",
            "        self.edges_nouse = None",
            "        self.nodes = None",
            "",
            "    def build(self)->None:",
            "        self.weight = 0",
            "        self.edges = []",
            "        self.edges_nouse = []",
            "        self.nodes = set([])",
            "        self.all_edges.sort()",
            "        uf = UnionFind(self.n)",
            "        for w, u, v in self.all_edges:",
            "            if uf.same(u, v):",
            "                self.edges_nouse.append((w, u, v))",
            "            else:",
            "                uf.unite(u, v)",
            "                self.weight += w",
            "                self.edges.append((w, u, v))",
            "                self.nodes |= {u, v}",
            "",
            "################################",
            "",
            "n, m = map(int, input().split())",
            "",
            "#辺リストの作成",
            "edges = []",
            "for i in range(m):",
            "    a, b, w = map(int, input().split())",
            "    edges.append((w, a-1, b-1))",
            "",
            "mst = Kruskal(n, edges)",
            "mst.build()",
            "print(mst.weight)",
            ""
        ],
        "description": [
            "最小全域木 クラスカル法 minimum_spanning_tree",
            "重み付き無向グラフで、それらの全ての頂点を結び連結するような木の最小のコストを求める",
            "辺の重みの小さい順にみて、連結成分が閉路にならない辺を追加していく",
            "つなぐ頂点が同じ連結成分にないことをUnion Find Tree でみる"
        ]
    },
    "reverse=True": {
        "prefix": [
            "reverse=True"
        ],
        "body": [
            "reverse=True"
        ],
        "description": [
            "ソートでのリバース"
        ]
    },
    "sort(key=itemgetter": {
        "prefix": [
            "sort(key=itemgetter"
        ],
        "body": [
            "sort(key=itemgetter($index))"
        ],
        "description": [
            "itemgetterソート"
        ]
    },
    "defaultdict": {
        "prefix": [
            "defaultdict",
            "d=defaultdict"
        ],
        "body": [
            "d = defaultdict($int)"
        ],
        "description": [
            "デフォルトディクショナリ"
        ]
    },
    "sort_by_function": {
        "prefix": [
            "sort_by_function"
        ],
        "body": [
            "from functools import cmp_to_key",
            "def sort_by_function(x):",
            "    \"\"\"比較関数を設定してソート",
            "    \"\"\"",
            "    def compare(item1, item2):",
            "        \"\"\" \"小さい\" -> -1",
            "            \"等しい\" -> 0",
            "            \"大きい\" -> 1",
            "        \"\"\"",
            "        # 以下はx, yが与えられてy/xで比較する例",
            "        # y1/x1 < y2/x2",
            "        # -> y1*x2 < y2*x1",
            "        x1, y1 = item1",
            "        x2, y2 = item2",
            "",
            "        if y1*x2 < y2*x1:",
            "            return -1",
            "        elif y1*x2 > y2*x1:",
            "            return 1",
            "        else:",
            "            return 0",
            "    x.sort(key=cmp_to_key(compare))",
            "    return x",
            "########################################",
            "a = [[1, 2], [2, 6] , [3, 6], [4, 5], [5, 7]]",
            "print(a)",
            "a = sort_by_function(a)",
            "print(a)",
            "# [[4, 5], [5, 7], [1, 2], [3, 6], [2, 6]]",
            "#   1.25    0.714    0.5     0.5    0.333"
        ],
        "description": [
            "比較関数使って並べ替え"
        ]
    },
    "順列・組み合わせ": {
        "prefix": [
            "itertools",
            "lib_順列・組み合わせ"
        ],
        "body": [
            "P = list(permutations(range(n), r))   # 順列(nPr)",
            "C = list(combinations(range(n), r))   # 組み合わせ(nCr)",
            "CR = list(combinations_with_replacement(range(n), r))  # 重複も許容した組み合わせ(nHr=n+r-1Cr)",
            "PN = list(product(range(n), repeat=r)) # 重複順列(n**r)",
            "T = [[1, 2],[3, 4, 5, 6],[7, 8, 9]]",
            "PT = list(product(*T))"
        ],
        "description": [
            "順列・組み合わせ"
        ]
    },
    "区間カウント": {
        "prefix": [
            "lib_区間カウント"
        ],
        "body": [
            "def count_intervals(a:list, x)->int:",
            "    dm = a + [float('inf')]",
            "    ret = 0",
            "    is_yes = False",
            "    for ai in dm:",
            "        if ai == x:",
            "            if is_yes: continue",
            "            is_yes = True",
            "        else:",
            "            if not is_yes: continue",
            "            is_yes = False",
            "            ret += 1",
            "",
            "    return ret",
            "# A=[0, 0, 1, 1, 1, 1, 0, 1, 1, 1]",
            "# x=1 の区間がいくつあるか ans = 2"
        ],
        "description": [
            "区間カウント",
            "A=[0, 0, 1, 1, 1, 1, 0, 1, 1, 1]",
            "x=1 の区間がいくつあるか ans = 2"
        ]
    },
    "direc": {
        "prefix": [
            "direc"
        ],
        "body": [
            "direc = {(1, 0), (-1, 0), (0, 1), (0, -1)}",
            "direc = {(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1) (-1, 1), (-1, -1)}",
            "",
            "for dh, dw in direc:",
            "    nh, nw = ch + dh, cw + dw",
            "    if not (0 <= nh < h and 0 <= nw < w): continue"
        ],
        "description": [
            "direc"
        ]
    },
    "lib_math": {
        "prefix": [
            "lib_最大公約数_三角関数",
            "import math"
        ],
        "body": [
            "import math",
            "print(math.sin(math.pi/4))",
            "print(math.cos(math.pi/4))",
            "print(math.tan(math.pi/4))",
            "# 度→radian",
            "math.radians(180)",
            "# radian→度",
            "math.degrees(3.1415)",
            "",
            "print(math.gcd(x, y))",
            ""
        ],
        "description": [
            "mathのライブラリ"
        ]
    },
    "lib_decimal": {
        "prefix": [
            "lib_四捨五入_Decimal"
        ],
        "body": [
            "from decimal import Decimal",
            "x, y, r = map(Decimal, input().split())",
            "f = 123.456",
            "fd = Decimal(str(f))",
            "fr = fd.quantize(Decimal('0'), rounding=ROUND_HALF_UP)  #123",
            "fr = fd.quantize(Decimal('0.1'), rounding=ROUND_HALF_UP)#123.5"
        ],
        "description": [
            "四捨五入が正しくできるツール",
            "Decimal で扱う"
        ]
    },
    "lib_再帰関数": {
        "prefix": [
            "lib_再帰関数"
        ],
        "body": [
            "@lru_cache(maxsize=None)"
        ],
        "description": [
            "再帰関数"
        ]
    },
    "lib_複素数": {
        "prefix": [
            "lib_再帰関数"
        ],
        "body": [
            "import cmath",
            "",
            "z1 = 5 + 13j",
            "a, b = 5, 13",
            "z2 = complex(a, b)",
            "",
            "print(z1.real)",
            "print(z1.img)",
            "",
            "",
            "# 極座標表示",
            "r, theta = cmath.polar(z1)",
            "",
            "print(cmath.rect(1, cmath.pi/2))",
            "# (6.123233995736766e-17+1j)",
            "print(z2.conjugate())",
            "# (5-13j)",
            ""
        ],
        "description": [
            "lib_複素数"
        ]
    },
    "Binary Indexed Tree": {
        "prefix": [
            "Lib_Q_BIT_Fenwick"
        ],
        "body": [
            "# 部分和の計算と要素の更新の両方を効率的に行える",
            "# 1-indexed",
            "# sum(r)        :閉区間 [0,r] の合計を取得する",
            "# [8] a0 + a1  + a2 + a3 + a4 + a5 + a6 + a7",
            "# [4] a0 + a1  + a2 + a3",
            "# [2] a0 + a1               [6] a4 + a5",
            "# [1] a0       [3] a2       [5] a4        [7] a6",
            "",
            "#                   [1000]",
            "#           [0100]",
            "#   [0010]                [0110]",
            "# [0001]    [0011]      [0111]      [1111]",
            "class BinaryIndexedTree:",
            "    # 初期化処理",
            "    def __init__(self, size):",
            "        self.size = size",
            "        self.dat = [0]*(size+1)",
            "        self.depth = size.bit_length()",
            "",
            "    def init(self, a):",
            "        for i, x in enumerate(a):",
            "            self.add(i, x)",
            "",
            "    def add(self, i, x):",
            "        i += 1",
            "        while i <= self.size:",
            "            self.dat[i] += x",
            "            i += i & -i # 更新すべき位置",
            "",
            "    def sum(self, r):",
            "        \"\"\"",
            "        Returns",
            "        -------",
            "        sum of [0, r]",
            "        \"\"\"",
            "        r += 1",
            "        ret = 0",
            "        while r>0:",
            "            ret += self.dat[r]",
            "            r -= r & -r # 加算すべき位置",
            "        return ret",
            "",
            "    def rangesum(self, l, r):",
            "        \"\"\"閉区間 [l,r] の合計を取得する",
            "",
            "        Returns",
            "        -------",
            "        sum of [l, r]",
            "        \"\"\"",
            "        if l == 0:",
            "            return self.sum(r)",
            "        else:",
            "            return self.sum(r) - self.sum(l-1)",
            "",
            "",
            "    def get(self, i):",
            "        return self.rangesum(i, i)",
            "",
            "",
            "    def lower_bound(self, x):",
            "        sum_ = 0",
            "        pos = 0",
            "        for i in range(self.depth, -1, -1):",
            "            k = pos + (1 << i)",
            "            if k <= self.size and sum_ + self.dat[k] <= x:",
            "                sum_ += self.dat[k]",
            "                pos += 1 << i",
            "        # a0+..+a_pos <= x < a0+a_pos+a_pos+1",
            "        # pos : sum(i) < xとなる最大のindex",
            "        # pos + 1 : sum(i) >= xとなる最小のindex",
            "        return pos  #0-indexed",
            "",
            "",
            "#### for debug",
            "    def _get_original_sequence(self):",
            "        ret = [self.get(i) for i in range(self.size)]",
            "        return ret",
            "",
            "    def _get_aggrigate_sequence(self):",
            "        return [self.sum(i) for i in range(self.size)]",
            "",
            "    def __str__(self):",
            "        seq = self.get_original_sequence()",
            "        ret = 'original :' + ' '.join(map(str, seq))",
            "        ret += '\\n'",
            "        seq = self.get_aggrigate_sequence()",
            "        ret += 'aggrigate:' + ' '.join(map(str, seq))",
            "        return ret",
            "",
            "########################################",
            "",
            "a = [5,3,7,9,6,4]",
            "n = len(a)",
            "",
            "bit = BinaryIndexedTree(n)",
            "bit.init(a)",
            "",
            "for i in range(12):",
            "    print(i, bit.lower_bound(i))",
            ""
        ],
        "description": []
    },
    "Sorted Multi Set": {
        "prefix": [
            "Lib_D_sorted_multi_set"
        ],
        "body": [
            "# https://github.com/tatyam-prime/SortedSet/blob/main/SortedMultiset.py",
            "import math",
            "from bisect import bisect_left, bisect_right, insort",
            "from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
            "T = TypeVar('T')",
            "",
            "class SortedMultiset(Generic[T]):",
            "    BUCKET_RATIO = 50",
            "    REBUILD_RATIO = 170",
            "",
            "    def _build(self, a=None) -> None:",
            "        \"Evenly divide `a` into buckets.\"",
            "        if a is None: a = list(self)",
            "        size = self.size = len(a)",
            "        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
            "        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
            "",
            "    def __init__(self, a: Iterable[T] = []) -> None:",
            "        \"Make a new SortedMultiset from iterable. / O(N) if sorted / O(N log N)\"",
            "        a = list(a)",
            "        if not all(a[i] <= a[i + 1] for i in range(len(a) - 1)):",
            "            a = sorted(a)",
            "        self._build(a)",
            "",
            "    def __iter__(self) -> Iterator[T]:",
            "        for i in self.a:",
            "            for j in i: yield j",
            "",
            "    def __reversed__(self) -> Iterator[T]:",
            "        for i in reversed(self.a):",
            "            for j in reversed(i): yield j",
            "",
            "    def __len__(self) -> int:",
            "        return self.size",
            "",
            "    def __repr__(self) -> str:",
            "        return \"SortedMultiset\" + str(self.a)",
            "",
            "    def __str__(self) -> str:",
            "        s = str(list(self))",
            "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
            "",
            "    def _find_bucket(self, x: T) -> List[T]:",
            "        \"Find the bucket which should contain x. self must not be empty.\"",
            "        for a in self.a:",
            "            if x <= a[-1]: return a",
            "        return a",
            "",
            "    def __contains__(self, x: T) -> bool:",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        return i != len(a) and a[i] == x",
            "",
            "    def count(self, x: T) -> int:",
            "        \"Count the number of x.\"",
            "        return self.index_right(x) - self.index(x)",
            "",
            "    def add(self, x: T) -> None:",
            "        \"Add an element. / O(√N)\"",
            "        if self.size == 0:",
            "            self.a = [[x]]",
            "            self.size = 1",
            "            return",
            "        a = self._find_bucket(x)",
            "        insort(a, x)",
            "        self.size += 1",
            "        if len(a) > len(self.a) * self.REBUILD_RATIO:",
            "            self._build()",
            "",
            "    def discard(self, x: T) -> bool:",
            "        \"Remove an element and return True if removed. / O(√N)\"",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i == len(a) or a[i] != x: return False",
            "        a.pop(i)",
            "        self.size -= 1",
            "        if len(a) == 0: self._build()",
            "        return True",
            "",
            "    def lt(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element < x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] < x:",
            "                return a[bisect_left(a, x) - 1]",
            "",
            "    def le(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element <= x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] <= x:",
            "                return a[bisect_right(a, x) - 1]",
            "",
            "    def gt(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element > x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return a[bisect_right(a, x)]",
            "",
            "    def ge(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element >= x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return a[bisect_left(a, x)]",
            "",
            "    def __getitem__(self, x: int) -> T:",
            "        \"Return the x-th element, or IndexError if it doesn't exist.\"",
            "        if x < 0: x += self.size",
            "        if x < 0: raise IndexError",
            "        for a in self.a:",
            "            if x < len(a): return a[x]",
            "            x -= len(a)",
            "        raise IndexError",
            "",
            "    def index(self, x: T) -> int:",
            "        \"Count the number of elements < x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return ans + bisect_left(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "    def index_right(self, x: T) -> int:",
            "        \"Count the number of elements <= x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return ans + bisect_right(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "###############################################",
            "",
            "sm = SortedMultiset()",
            "",
            "q = int(input())",
            "",
            "for _ in range(q):",
            "    query = tuple(map(int, input().split()))",
            "",
            "    if query[0] == 2:",
            "        x, k = query[1:]",
            "        id = sm.index_right(x) - k",
            "        if id < 0:",
            "            print(-1)",
            "        else:",
            "            print(sm[id])",
            "    elif query[0] == 3:",
            "        x, k = query[1:]",
            "        id = sm.index(x) + k - 1",
            "        if id >= len(sm):",
            "            print(-1)",
            "        else:",
            "            print(sm[id])",
            "    else:",
            "        sm.add(query[1])",
            "",
            ""
        ],
        "description": []
    },
    "強連結成分分解": {
        "prefix": [
            "ZZZZZZZZZZ"
        ],
        "body": [
            "class SCCGraph:",
            "    def __init__(self, n:int) -> None:",
            "        self.n = n                          # 頂点サイズ",
            "        self.size = None                    # 分解後連結成分数",
            "        self.label = [None] * n             # それぞれの頂点がどの連結成分に属しているか",
            "        self.gf = [[] for _ in range(n)]    # 順方向の有向グラフ",
            "        self.gr = [[] for _ in range(n)]    # 逆方向の有向グラフ",
            "        self.edges = None                   # 縮約後の辺(隣接リスト)",
            "        self.groups = None                  # 分解後の成分のトポロジカルソート",
            "",
            "",
            "    def add_edge(self, fm, to):",
            "        self.gf[fm].append(to)",
            "        self.gr[to].append(fm)",
            "",
            "",
            "    def build(self):",
            "        order = []",
            "        used = [False] * self.n",
            "",
            "        def dfs(s):",
            "            used[s] = True",
            "            for t in self.gf[s]:",
            "                if not used[t]: dfs(t)",
            "            order.append(s)",
            "        def rdfs(s, col):",
            "            self.label[s] = col",
            "            used[s] = True",
            "            for t in self.gr[s]:",
            "                if not used[t]: rdfs(t, col)",
            "",
            "        for s in range(n):",
            "            if not used[s]: dfs(s)",
            "        used = [False] * self.n",
            "        self.size = 0",
            "        for s in reversed(order):",
            "            if not used[s]:",
            "                rdfs(s, self.size)",
            "                self.size += 1",
            "",
            "        # 縮約後のグラフを構築",
            "        self.edges = [set() for _ in range(self.size)]",
            "        self.groups = [[] for _ in range(self.size)]",
            "        for s in range(n):",
            "            lbs = self.label[s]",
            "            for t in self.gf[s]:",
            "                lbt = self.label[t]",
            "                if lbs == lbt: continue",
            "                self.edges[lbs].add(lbt)",
            "            self.groups[lbs].append(s)",
            "",
            "",
            "####################################",
            "",
            "n, m = map(int, input().split())",
            "scc = SCCGraph(n)",
            "",
            "for i in range(m):",
            "    _a, _b = map(int, input().split())",
            "    _a -= 1; _b -= 1",
            "    scc.add_edge(_a, _b)",
            "",
            "scc.build()",
            "",
            "print(scc.size)",
            "for gi in scc.groups:",
            "    print(len(gi), *gi)",
            "",
            "# 強連結成分分解(SCC): グラフgに対するSCCを行う",
            "# https://hkawabata.github.io/technical-note/note/Algorithm/graph/scc.html",
            "# 有向グラフで、互いに行き来できる連結成分を分類する",
            "# 元の有向グラフが DAG でなくとも、そのグラフの SCC は DAG を形成する",
            "# 作り方",
            "# 適当に選んだ頂点から深さ優先（帰りがけ探索）し、1から番号を増やしながらラベリング：",
            "# エッジをすべて逆向きにしたグラフを用意：",
            "# 頂点のうち、ラベル番号が最大のものを選んでグラフ探索 → 通った頂点はすべて1つの SCC に属する：",
            "# 未探索の頂点のうち、ラベル番号が最大のものを選んでグラフ探索 → 通った頂点はすべて1つの SCC に属する：",
            "",
            "# https://atcoder.jp/contests/practice2/tasks/practice2_g",
            ""
        ],
        "description": [
            "強連結成分分解(SCC): グラフgに対するSCCを行う"
        ]
    },
    "累積和": {
        "prefix": [
            "Lib_D_累積和_accum"
        ],
        "body": [
            "class imos:",
            "    def __init__(self, grid):",
            "        h = len(grid)",
            "        w = len(grid[0])",
            "        h += 1; w += 1",
            "        self.h = h",
            "        self.w = w",
            "        # 拡張grid生成",
            "        _grid = [[0] * w]",
            "        for gdi in grid:",
            "            _grid.append([0] + gdi)",
            "        # 累積和",
            "        for i in range(1, h):",
            "            for j in range(1, w):",
            "                _grid[i][j] += _grid[i][j-1]",
            "        for j in range(1, w):",
            "            for i in range(1, h):",
            "                _grid[i][j] += _grid[i-1][j]",
            "        self.grid = _grid",
            "",
            "",
            "    def cnt(self, x, y, u, v):",
            "        if not 0<= x < self.h: return 0",
            "        if not 0<= y < self.w: return 0",
            "        if not 0<= u < self.h: return 0",
            "        if not 0<= v < self.w: return 0",
            "        gd = self.grid",
            "        return gd[u][v] - gd[u][y] - gd[x][v] + gd[x][y]",
            ""
        ],
        "description": [
            "累積和"
        ]
    },
    "トポロジカルソート": {
        "prefix": [
            "Lib_G_トポロジカルソート",
            "Lib_G_topologicalsort"
        ],
        "body": [
            "# トポロジカルソート",
            "# 有向非巡回グラフ（DAG）の各ノードを順序付けして、どのノードもその出力辺の先のノードより前にくるように並べることである。",
            "# 有向非巡回グラフは必ずトポロジカルソートすることができる。",
            "class topological_sort:",
            "    def __init__(self, n:int) -> None:",
            "        self.n = n",
            "        self.in_cnt = [0] * n   # 入力",
            "        self.ts = []            # トポロジカルソート",
            "        self.parents = [-1] * n # 親 -1は根",
            "        self.edges = [[] for _ in range(n)] # 辺",
            "        self.node_zero = []     # ゼロ次のノード",
            "",
            "    def add_edge(self, fm:int, to:int, w=1) -> None:",
            "        self.edges[fm].append((to, w))",
            "        self.in_cnt[to] += 1",
            "",
            "    def _build_sort_by_appear(self) -> None:",
            "        q = self.node_zero[:]",
            "        q = deque(q)",
            "        while q:",
            "            p = q.popleft()",
            "            self.ts.append(p)",
            "            for nxt, nxtw in self.edges[p]:",
            "                self.in_cnt[nxt] -= 1",
            "                if self.in_cnt[nxt] == 0:",
            "                    q.append(nxt)",
            "                    self.parents[nxt] = p",
            "",
            "    def _build_sort_by_nodeid(self) -> None:",
            "        q = self.node_zero[:]",
            "        heapify(q)",
            "        while q:",
            "            p = heappop(q)",
            "            self.ts.append(p)",
            "            for nxt, nxtw in self.edges[p]:",
            "                self.in_cnt[nxt] -= 1",
            "                if self.in_cnt[nxt] == 0:",
            "                    heappush(q, nxt)",
            "                    self.parents[nxt] = p",
            "",
            "    def build(self, sorttype='appear'):",
            "        self.ts = []            # トポロジカルソート",
            "        self.node_zero = [i for i in range(self.n) if self.in_cnt[i] == 0]",
            "        if sorttype == 'appear':        # 出たとこ順番",
            "            self._build_sort_by_appear()",
            "        elif sorttype == 'nodeid':      # ノードの順番",
            "            self._build_sort_by_nodeid()",
            "",
            "    @property",
            "    def is_dag(self) -> bool:",
            "        return len(self.ts)==self.n",
            "        # True 閉路なしDAG",
            "        # False 閉路あり",
            "",
            "",
            "#########################################",
            "",
            "n, m = map(int, input().split())",
            "ts = topological_sort(n)",
            "# 隣接リストの作成",
            "for i in range(m):",
            "    # a->b 有向辺",
            "    a, b = map(int, input().split())",
            "    a -= 1",
            "    b -= 1",
            "    ts.add_edge(a, b)",
            "",
            "ts.build()",
            "",
            "print(ts.ts)",
            "print(ts.parents)",
            "print(ts.is_dag)",
            ""
        ],
        "description": [
            "トポロジカルソート topologicalsort"
        ]
    },
    "行列回転": {
        "prefix": [
            "Lib_M_matrix-回転と反転"
        ],
        "body": [
            "class Matrix():",
            "    def __init__(self, n, v=None):",
            "        self.n = n",
            "        self.state = [0, 0]",
            "        self.matrix_origin = [[v] * n for _ in range(n)]",
            "",
            "    def rotate(self, t):",
            "        self.state[0] = (self.state[0] + t) % 4",
            "",
            "",
            "    def reverse_lr(self):",
            "        self.state[1] = 1 - self.state[1]",
            "        if self.state[0] % 2 == 1:",
            "            self.state[0] = (self.state[0] + 2) % 4",
            "",
            "    def reverse_ud(self):",
            "        self.state[1] = 1 - self.state[1]",
            "        if self.state[0] % 2 == 0:",
            "            self.state[0] = (self.state[0] + 2) % 4",
            "",
            "    def get_original_positon(self, x, y):",
            "        n = self.n",
            "        if self.state == [0, 0]: return x, y",
            "        if self.state == [1, 0]: return n-1-y, x",
            "        if self.state == [2, 0]: return n-1-x, n-1-y",
            "        if self.state == [3, 0]: return y, n-1-x",
            "",
            "        if self.state == [0, 1]: return x, n-1-y",
            "        if self.state == [1, 1]: return n-1-y, n-1-x",
            "        if self.state == [2, 1]: return n-1-x, y",
            "        if self.state == [3, 1]: return y, x",
            "        else:",
            "            print(self.state)",
            "",
            "    def set_value(self, x, y, v):",
            "        ox, oy = self.get_original_positon(x, y)",
            "        self.matrix_origin[ox][oy] = v",
            "",
            "    def get_value(self, x, y):",
            "        ox, oy = self.get_original_positon(x, y)",
            "        return self.matrix_origin[ox][oy]",
            "",
            "n, q = map(int, input().split())",
            "mx = Matrix(n, 0)",
            "",
            "for _ in range(q):",
            "    que = list(input().split())",
            "    if que[0] == '1':",
            "        x = int1(que[1])",
            "        y = int1(que[2])",
            "        mx.set_value(x, y, 1 - mx.get_value(x, y))",
            "    if que[0] == '2':",
            "        if que[1] == 'A':",
            "            mx.rotate(1)",
            "        else:",
            "            mx.rotate(3)",
            "    if que[0] == '3':",
            "        if que[1] == 'A':",
            "            mx.reverse_ud()",
            "        else:",
            "            mx.reverse_lr()",
            "",
            "for i in range(n):",
            "    ret = []",
            "    for j in range(n):",
            "        ret.append(mx.get_value(i, j))",
            "    print(''.join(map(str, ret)))",
            ""
        ],
        "description": []
    },
    "ループ#": {
        "prefix": [
            "Lib_Loop_ループ"
        ],
        "body": [
            "class Loop():",
            "    \"\"\"ループを検索して計算量圧縮",
            "",
            "        Parameters",
            "        ----------",
            "        n : int",
            "            鳩の巣の数",
            "        x : int",
            "            初期値",
            "        f : function",
            "            次の値を決める関数",
            "",
            "        Notes",
            "        ----------",
            "        0->1->...->s_t-1 -> st->...-> s_t+x─┐",
            "                             └─────────┘",
            "        https://atcoder.jp/contests/typical90/tasks/typical90_bf",
            "",
            "    \"\"\"",
            "    def __init__(self, n, x, f, g):",
            "        self.hole = n",
            "        self.ini_p = x",
            "        self.nextp = f",
            "        self.value = g",
            "        self.__build()",
            "",
            "",
            "    def __build(self):",
            "        x = self.ini_p",
            "        seen = defaultdict(int)",
            "        seqs = []",
            "        for i in range(self.hole + 10):",
            "            seen[x] = i",
            "            seqs.append(x)",
            "            x = self.nextp(x)",
            "            if x in seen: break",
            "        p = seen[x]",
            "        self.ini_seq = self.sequence([self.value(pos) for pos in seqs[:p]])",
            "        self.lp_seq = self.sequence([self.value(pos) for pos in seqs[p:]])",
            "",
            "",
            "    def get_kth(self, k:int)->int:",
            "        \"\"\"k番目の値を取得",
            "        0-index",
            "        \"\"\"",
            "        if k < self.ini_seq.len:",
            "            return self.ini_seq.seq[k]",
            "        else:",
            "            k -= self.ini_seq.len",
            "            _, k = divmod(k, self.lp_seq.len)",
            "            return self.lp_seq.seq[k]",
            "",
            "",
            "    def sum_kth(self, k:int)->int:",
            "        \"\"\"k番目までの値の累積和を取得",
            "        0-index",
            "        \"\"\"",
            "        if k < self.ini_seq.len:",
            "            return self.ini_seq.acc[k]",
            "        else:",
            "            k -= self.ini_seq.len",
            "            t, k = divmod(k, self.lp_seq.len)",
            "            ret = self.ini_seq.acclast",
            "            ret += self.lp_seq.acclast * t",
            "            ret += self.lp_seq.acc[k]",
            "            return ret",
            "",
            "",
            "    class sequence:",
            "        def __init__(self, seq):",
            "            self.seq = seq          # 配列",
            "            self.len = len(seq)     # 配列の個数",
            "            self.acc = list(accumulate(seq))    # 配列の累積和",
            "            if self.len == 0:",
            "                self.acclast = 0    # 配列の累積和",
            "            else:",
            "                self.acclast = self.acc[-1]    # 配列の累積和",
            "",
            "",
            "n, k = map(int, input().split())",
            "",
            "if n == 0:",
            "    print(0)",
            "    exit()",
            "",
            "def f(x):",
            "    ...",
            "",
            "def g(x):",
            "    ...",
            "",
            "",
            "lp = Loop(n, 0, f, g)",
            "print(lp.get_kth(k))",
            ""
        ],
        "description": [
            "ループ#"
        ]
    },
    "nCr": {
        "prefix": [
            "Lib_N_nCr剰余"
        ],
        "body": [
            "class Combination:",
            "    \"\"\"nPr,nCr等の前計算",
            "",
            "    Parameters",
            "    ----------",
            "    max_n : int, optional",
            "        nの最大値, by default 1",
            "    mod : int, optional",
            "        modの値, by default 10**9+7",
            "",
            "    Note:",
            "    ----------",
            "    n = 10**6 くらい",
            "    \"\"\"",
            "    def __init__(self, max_n: int=1, mod : int=10**9+7) -> None:",
            "        self.mod = mod",
            "        self.max_n = 1",
            "        self.factorial = [1, 1]",
            "        self.inverse = [None, 1]",
            "        self.f_inverse = [1, 1]",
            "        self.__preprocessing(max_n)",
            "",
            "",
            "    def __preprocessing(self, max_n:int) -> None:",
            "        fac = self.factorial",
            "        inv = self.inverse",
            "        finv = self.f_inverse",
            "        mod = self.mod",
            "        fac += [-1] * (max_n - self.max_n)",
            "        inv += [-1] * (max_n - self.max_n)",
            "        finv += [-1] * (max_n - self.max_n)",
            "        for i in range(self.max_n + 1, max_n + 1):",
            "            fac[i] = fac[i - 1] * i % mod",
            "            inv[i] = mod - inv[mod % i] * (mod // i) % mod",
            "            finv[i] = finv[i - 1] * inv[i] % mod",
            "        self.max_n = max_n",
            "",
            "",
            "    def fac(self, n:int) -> int:",
            "        \"\"\"n!",
            "        \"\"\"",
            "        if n < 0:",
            "            return 0",
            "        if n > self.max_n: self.__preprocessing(n)",
            "        return self.factorial[n]",
            "",
            "",
            "    def nCr(self, n:int, r:int) -> int:",
            "        \"\"\"nCr",
            "        n個のものからr個選ぶ",
            "        \"\"\"",
            "        if n < r or n < 0 or r < 0:",
            "            return 0",
            "        if n > self.max_n: self.__preprocessing(n)",
            "        return self.factorial[n] * (self.f_inverse[r] * self.f_inverse[n - r] % self.mod) % self.mod",
            "",
            "",
            "    def nPr(self, n:int, r:int) -> int:",
            "        \"\"\"nPr",
            "        n個のものからr個選んで並べる",
            "        \"\"\"",
            "        if n < r or n < 0 or r < 0:",
            "            return 0",
            "        if n > self.max_n: self.__preprocessing(n)",
            "        return self.factorial[n] * self.f_inverse[n - r] % self.mod",
            "",
            "",
            "    def nHr(self, n:int, r:int) -> int:",
            "        \"\"\"nHr = n-1+rCr",
            "        n種類のものからr個重複を許して選ぶ(一個も選ばれないものがあっても可)",
            "        (一個も選ばれないものがダメな場合はnをn-rとする・あらかじめ１個づつ選んでおく)",
            "        \"\"\"",
            "        return self.nCr(n-1+r, n-1)",
            "",
            "",
            "mod = 998244353",
            "cmb = Combination(mod)",
            "# cmb.nCr(n, j)",
            "",
            "",
            "#####################################",
            "# nCr % 10**9+7",
            "#####################################",
            "mod = 10**9+7               # mod素数",
            "N = 10**6                   # 出力の制限",
            "g1 = [1]*(N+1)              # 元テーブル",
            "g2 = [1]*(N+1)              # 逆元テーブル",
            "for i in range(2, N + 1 ): # 準備",
            "    g1[i] = ( g1[i-1] * i ) % mod",
            "g2[N] = pow(g1[-1], mod-2, mod)",
            "for i in range(N, 0, -1):",
            "    g2[i-1] = ( g2[i] * i ) % mod",
            "",
            "def nCr(n, r):",
            "    if ( r<0 or r>n ):",
            "        return 0",
            "    r = min(r, n-r)",
            "    return g1[n] * g2[r] * g2[n-r] % mod",
            "",
            "def nPr(n, r):",
            "    if ( r<0 or r>n ):",
            "        return 0",
            "    return g1[n] * g2[n-r] % mod",
            "",
            "def nHr(n, r):",
            "    return nCr(n-1+r, n-1)",
            "",
            "",
            "ret = nCr(4, 2)",
            "",
            "class Combination:",
            "    \"\"\"nCrの前計算",
            "",
            "    Parameters",
            "    ----------",
            "    n : int, optional",
            "        n固定 by default 1",
            "    mod : int, optional",
            "        modの値, by default 10**9+7",
            "",
            "    Note:",
            "    ----------",
            "    nCr % 10**9+7  n～10^9 r～10^5",
            "    nは大きいが固定で,rは小さい場合",
            "    \"\"\"",
            "    def __init__(self, n : int=10**9, mod : int=10**9+7) -> None:",
            "        self.n = n",
            "        self.max_r = 1",
            "        self.mod = mod",
            "        self.nCrseq = [1, n%mod]",
            "",
            "",
            "    def __preprocessing(self, max_r:int) -> None:",
            "        seq = self.nCrseq",
            "        mod = self.mod",
            "        seq += [0] * (max_r - self.max_r)",
            "        for i in range(self.max_r + 1, max_r + 1):",
            "            seq[i] = (seq[i-1] * (self.n-i+1) * pow(i,mod-2,mod)) % mod",
            "        self.max_r = max_r",
            "",
            "",
            "    def nCr(self, r:int) -> int:",
            "        if r > self.max_r: self.__preprocessing(r)",
            "        return self.nCrseq[r]",
            "",
            "cmb = Combination(10)",
            "print(cmb.nCr(4))",
            "",
            "",
            "",
            "#####################################",
            "# nCr % 3",
            "#####################################",
            "class combination_mod_3:",
            "    def __init__(self):",
            "        n = 10**6",
            "        self.bf = [0] * n",
            "        self.bg = [0] * n",
            "        self.bg[0] = 1",
            "",
            "        for i in range(1, n):",
            "            pos = i",
            "            while pos % 3 == 0:",
            "                pos //= 3",
            "                self.bf[i] += 1",
            "            self.bg[i] = pos % 3",
            "",
            "        for i in range(1, n):",
            "            self.bf[i] += self.bf[i-1]",
            "            self.bg[i] = self.bg[i] * self.bg[i-1] % 3",
            "        self.MaxN = n",
            "",
            "    def nCr(self, n, r):",
            "        bf = self.bf",
            "        if bf[n] != bf[r] + bf[n-r]: return 0",
            "        bgn = self.bg[n]",
            "        bgrnr = self.bg[r] * self.bg[n-r]",
            "        if bgn == 1 and bgrnr == 1: return 1",
            "        if bgn == 1 and bgrnr == 2: return 2",
            "        if bgn == 1 and bgrnr == 4: return 1",
            "        if bgn == 2 and bgrnr == 1: return 2",
            "        if bgn == 2 and bgrnr == 2: return 1",
            "        if bgn == 2 and bgrnr == 4: return 2",
            "        return -1",
            "",
            "c = combination_mod_3()",
            "print(c.nCr(5,1))   #5mod3->2",
            "print(c.nCr(5,2))   #10mod3->1",
            "print(c.nCr(6,2))   #15mod3->0",
            "print(c.nCr(6,3))   #20mod3->2",
            ""
        ],
        "description": [
            "nCr剰余"
        ]
    },
    "ベルマンフォード法": {
        "prefix": [
            "Lib_S_最短経路探索_bellmanford"
        ],
        "body": [
            "# ベルマンフォード法",
            "# 重み付きグラフ関係により最短経路のリストを作る",
            "# 辺を繰り返しみて、最小化していく",
            "# |V|回更新するとで収束する/しなければ、負の閉路がある",
            "",
            "# https://atcoder.jp/contests/abc061/tasks/abc061_d",
            "",
            "def bellman_ford(st=0):",
            "    \"\"\"",
            "    n: グラフの頂点数",
            "    st: 始点",
            "    G[v] = [(w, cost), ...]: 頂点vからコストcostで到達できる頂点w",
            "    returns",
            "    dist or -1 if 閉路あり",
            "    \"\"\"",
            "",
            "    INF = float('INF')",
            "    dist = [INF] * n",
            "    dist[st] = 0",
            "    for _ in range(n):",
            "        update = False",
            "        for v, e in enumerate(G):",
            "            for t, cost in e:",
            "                if dist[v] == INF: continue",
            "                if dist[v] + cost >= dist[t]: continue",
            "                dist[t] = dist[v] + cost",
            "                update = True",
            "                upi = t",
            "        if not update: return dist",
            "    # 負閉路検出処理",
            "    dist[upi] = -INF",
            "    for _ in range(n):",
            "        update = False",
            "        for v, e in enumerate(G):",
            "            for t, cost in e:",
            "                if dist[v] == INF: continue",
            "                if dist[v] + cost >= dist[t]: continue",
            "                dist[t] = dist[v] + cost",
            "                update = True",
            "                upi = t",
            "        if not update: return dist",
            "    return -1",
            "",
            "######################################",
            "",
            "n, m = map(int, input().split())",
            "G = [[] for _ in range(n)]",
            "# 隣接リストの作成",
            "for _ in range(m):",
            "    _a, _b, _c = map(int, input().split())",
            "    _a -= 1; _b -= 1",
            "    G[_a].append((_b, -_c))",
            "",
            "st = 0",
            "ret = bellman_ford(st)",
            "if ret == -1:",
            "    print('inf')",
            "else:",
            "    print(-ret[-1])",
            ""
        ],
        "description": [
            "ベルマンフォード法・負閉路OK",
            "O(NM)"
        ]
    },
    "LCA": {
        "prefix": [
            "lib_G_最小共通祖先_LCA"
        ],
        "body": [
            "from collections import deque",
            "",
            "",
            "class lca():",
            "    \"\"\"Lowest Common Ancestor",
            "",
            "    u, vの共通の親",
            "    ダブリング p[i][v] = vの2^i個 親",
            "",
            "    Parameters",
            "    ----------",
            "    n : int",
            "        nodeの数",
            "",
            "    Methods",
            "    ----------",
            "    set_root :",
            "",
            "",
            "",
            "    \"\"\"",
            "    def __init__(self, n: int) -> None:",
            "        self.n = n",
            "        self.root = None",
            "        self.edges = [[] for _ in range(n)]",
            "        self.lv = n.bit_length()",
            "        self.p = [[None] * n for _ in range(self.lv)]",
            "        self.depth = [None] * n",
            "        self.distance = [None] * n",
            "        self.is_constructed = False",
            "",
            "",
            "    def set_root(self, root: int = 0) -> None:",
            "        \"\"\"木の根を設定する",
            "",
            "        Parameters",
            "        ----------",
            "        root : int",
            "            省略時は 0",
            "        \"\"\"",
            "        self.root = root",
            "        self.is_constructed = False",
            "",
            "",
            "    def add_edge(self, fm: int, to: int, dist: int=1) -> None:",
            "        \"\"\"辺の設定",
            "",
            "        Parameters",
            "        ----------",
            "        fm : int",
            "            辺の始点",
            "        to : [type]",
            "            辺の終点",
            "        \"\"\"",
            "        self.edges[fm].append((to, dist))",
            "        self.is_constructed = False",
            "",
            "",
            "    def __construct(self):",
            "        \"\"\"深さと親の設定とダブリング",
            "        \"\"\"",
            "        # 深さと親の設定",
            "        q = deque()",
            "        q.append((self.root, 0, 0))",
            "        self.depth[self.root] = 0",
            "        self.distance[self.root] = 0",
            "        self.p[0][self.root] = 0",
            "        while q:",
            "            cur, dep, dist = q.popleft()",
            "            for nxt, nd in self.edges[cur]:",
            "                if self.p[0][nxt]!=None: continue",
            "                q.append((nxt, dep+1, dist+nd))",
            "                self.depth[nxt] = dep+1",
            "                self.distance[nxt] = dist+nd",
            "                self.p[0][nxt] = cur",
            "        # ダブリング",
            "        for i in range(1, self.lv):",
            "            for v in range(self.n):",
            "                self.p[i][v] = self.p[i-1][self.p[i-1][v]]",
            "        self.is_constructed = True",
            "",
            "",
            "    def la(self, x, h):",
            "        if not self.is_constructed:",
            "            self.__construct()",
            "        for i in range(self.lv)[::-1]:",
            "            if h >= 1 << i:",
            "                x = self.p[i][x]",
            "                h -= 1 << i",
            "        return x",
            "",
            "",
            "    def lca(self, u, v):",
            "        \"\"\"共通祖先",
            "",
            "        Parameters",
            "        ----------",
            "        u, v : node",
            "            ノード",
            "",
            "        Returns",
            "        -------",
            "        int",
            "            共通祖先のノード",
            "        \"\"\"",
            "        # u,vの高さを合わせる",
            "        if not self.is_constructed:",
            "            self.__construct()",
            "        if self.depth[u] < self.depth[v]: u, v = v, u",
            "        u = self.la(u, self.depth[u] - self.depth[v])",
            "        if u == v: return u",
            "        # u, vのギリギリ合わない高さまで昇る",
            "        for i in range(self.lv)[::-1]:",
            "            if self.p[i][u] != self.p[i][v]:",
            "                u = self.p[i][u]",
            "                v = self.p[i][v]",
            "        return self.p[0][u]",
            "",
            "",
            "    def nodesdist(self, u, v):",
            "        \"\"\"ノード間の距離",
            "",
            "        Parameters",
            "        ----------",
            "        u, v : node",
            "            ノード",
            "",
            "        Returns",
            "        -------",
            "        int",
            "            ノード間の距離",
            "        \"\"\"",
            "        if not self.is_constructed:",
            "            self.__construct()",
            "        lca = self.lca(u, v)",
            "        return self.depth[u] + self.depth[v] - 2 * self.depth[lca]",
            "",
            "",
            "    def distance(self, u, v):",
            "        \"\"\"ノード間の経路の長さ",
            "",
            "        Parameters",
            "        ----------",
            "        u, v : node",
            "            ノード",
            "",
            "        Returns",
            "        -------",
            "        int",
            "            ノード間の距離",
            "        \"\"\"",
            "        if not self.is_constructed:",
            "            self.__construct()",
            "        lca = self.lca(u, v)",
            "        return self.distance[u] + self.distance[v] - 2 * self.distance[lca]",
            "",
            "",
            "########################################",
            "",
            "n, q = map(int, input().split())",
            "l = lca(n)",
            "l.set_root(0)",
            "for i, ai in enumerate(list(map(int, input().split()))):",
            "    l.add_edge(ai, i+1)",
            "",
            "",
            "for i in range(q):",
            "    u, v = map(int1, input().split())",
            "    print(l.lca(u, v))",
            ""
        ],
        "description": [
            "最小共通祖先"
        ]
    },
    "区間和の最大値": {
        "prefix": [
            "lib_区間和の最大値"
        ],
        "body": [
            "",
            "class Imos:",
            "    def __init__(self, a:list):",
            "        self.origin = a",
            "        self.accum = [0]",
            "        for ai in a:",
            "            self.accum.append(self.accum[-1] + ai)",
            "        self.n = self.accum",
            "        self.INF = float('inf')",
            "",
            "    def _get_max(self, accum:list):",
            "        \"\"\"",
            "        区間和(ar-al)の最大値",
            "        max(ar-min(al))",
            "        \"\"\"",
            "        ret_min = - self.INF",
            "        min_al = self.INF",
            "        for ar in accum:",
            "            min_al = min(ar, min_al)",
            "            ret_min= max(ar - min_al, ret_min)",
            "        return ret_min",
            "",
            "    @property",
            "    def get_max(self):",
            "        return self._get_max(self.accum)",
            "",
            "    @property",
            "    def get_min(self):",
            "        return - self._get_max([-ai for ai in self.accum])",
            "",
            "",
            "n = int(input())",
            "a = list(map(int, input().split()))",
            "for i, ai in enumerate(a):",
            "    if ai==0:",
            "        a[i] = -1",
            "",
            "im = Imos(a)",
            "print(im.get_max - im.get_min + 1)",
            "",
            ""
        ],
        "description": [
            "区間和を累積和の差分としてその最大値を求めるar-al"
        ]
    },
    "Lib_G_枝刈り取る": {
        "prefix": [
            "Lib_G_cycle"
        ],
        "body": [
            "n = int(input())",
            "edges = [[] for _ in range(n)]",
            "degree = [0] * n",
            "for _ in range(n):",
            "    _a, _b = map(int1, input().split())",
            "    edges[_a].append(_b)",
            "    edges[_b].append(_a)",
            "    degree[_a] += 1",
            "    degree[_b] += 1",
            "",
            "leaves = [i for i in range(n) if degree[i] == 1]",
            "oncycle = set(range(n))",
            "while leaves:",
            "    x = leaves.pop()",
            "    oncycle.remove(x)",
            "    for y in edges[x]:",
            "        degree[y] -= 1",
            "        if degree[y] == 1:",
            "            leaves.append(y)"
        ],
        "description": [
            "グラフの葉から枝を刈り取って、ループ部分のみ抽出する"
        ]
    },
    "Sorted Set": {
        "prefix": [
            "Lib_D_sorted_set"
        ],
        "body": [
            "# https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py",
            "import math",
            "from bisect import bisect_left, bisect_right",
            "from typing import Generic, Iterable, Iterator, TypeVar, Union, List",
            "T = TypeVar('T')",
            "",
            "class SortedSet(Generic[T]):",
            "    BUCKET_RATIO = 50",
            "    REBUILD_RATIO = 170",
            "",
            "    def _build(self, a=None) -> None:",
            "        \"Evenly divide `a` into buckets.\"",
            "        if a is None: a = list(self)",
            "        size = self.size = len(a)",
            "        bucket_size = int(math.ceil(math.sqrt(size / self.BUCKET_RATIO)))",
            "        self.a = [a[size * i // bucket_size : size * (i + 1) // bucket_size] for i in range(bucket_size)]",
            "",
            "    def __init__(self, a: Iterable[T] = []) -> None:",
            "        \"Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)\"",
            "        a = list(a)",
            "        if not all(a[i] < a[i + 1] for i in range(len(a) - 1)):",
            "            a = sorted(set(a))",
            "        self._build(a)",
            "",
            "    def __iter__(self) -> Iterator[T]:",
            "        for i in self.a:",
            "            for j in i: yield j",
            "",
            "    def __reversed__(self) -> Iterator[T]:",
            "        for i in reversed(self.a):",
            "            for j in reversed(i): yield j",
            "",
            "    def __len__(self) -> int:",
            "        return self.size",
            "",
            "    def __repr__(self) -> str:",
            "        return \"SortedSet\" + str(self.a)",
            "",
            "    def __str__(self) -> str:",
            "        s = str(list(self))",
            "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
            "",
            "    def _find_bucket(self, x: T) -> List[T]:",
            "        \"Find the bucket which should contain x. self must not be empty.\"",
            "        for a in self.a:",
            "            if x <= a[-1]: return a",
            "        return a",
            "",
            "    def __contains__(self, x: T) -> bool:",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        return i != len(a) and a[i] == x",
            "",
            "    def add(self, x: T) -> bool:",
            "        \"Add an element and return True if added. / O(√N)\"",
            "        if self.size == 0:",
            "            self.a = [[x]]",
            "            self.size = 1",
            "            return True",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i != len(a) and a[i] == x: return False",
            "        a.insert(i, x)",
            "        self.size += 1",
            "        if len(a) > len(self.a) * self.REBUILD_RATIO:",
            "            self._build()",
            "        return True",
            "",
            "    def discard(self, x: T) -> bool:",
            "        \"Remove an element and return True if removed. / O(√N)\"",
            "        if self.size == 0: return False",
            "        a = self._find_bucket(x)",
            "        i = bisect_left(a, x)",
            "        if i == len(a) or a[i] != x: return False",
            "        a.pop(i)",
            "        self.size -= 1",
            "        if len(a) == 0: self._build()",
            "        return True",
            "",
            "    def lt(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element < x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] < x:",
            "                return a[bisect_left(a, x) - 1]",
            "",
            "    def le(self, x: T) -> Union[T, None]:",
            "        \"Find the largest element <= x, or None if it doesn't exist.\"",
            "        for a in reversed(self.a):",
            "            if a[0] <= x:",
            "                return a[bisect_right(a, x) - 1]",
            "",
            "    def gt(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element > x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return a[bisect_right(a, x)]",
            "",
            "    def ge(self, x: T) -> Union[T, None]:",
            "        \"Find the smallest element >= x, or None if it doesn't exist.\"",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return a[bisect_left(a, x)]",
            "",
            "    def __getitem__(self, x: int) -> T:",
            "        \"Return the x-th element, or IndexError if it doesn't exist.\"",
            "        if x < 0: x += self.size",
            "        if x < 0: raise IndexError",
            "        for a in self.a:",
            "            if x < len(a): return a[x]",
            "            x -= len(a)",
            "        raise IndexError",
            "",
            "    def index(self, x: T) -> int:",
            "        \"Count the number of elements < x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return ans + bisect_left(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "    def index_right(self, x: T) -> int:",
            "        \"Count the number of elements <= x.\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return ans + bisect_right(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "########################################",
            "n, k = map(int, input().split())",
            "p = list(map(int, input().split()))",
            "ss = SortedSet()",
            "",
            "for i in range(n):",
            "    ss.add(p[i])",
            "    if len(ss) < k: continue",
            "    print(ss[-k])",
            "",
            ""
        ],
        "description": []
    },
    "ユニオンファインド重み付き": {
        "prefix": [
            "lib_unionfind_weighted"
        ],
        "body": [],
        "description": [
            "ユニオンファインド重み付き",
            "ass UnionFindWeighted:",
            "  def __init__(self, n):                      # 初期化",
            "      self.n = n                              # 要素数",
            "      self.parents = [i for i in range(n)]    # 親",
            "      self.ranks = [0] * n                    # 木の深さ",
            "      self.sizes = [1] * n                    # グループの要素数",
            "      self.weights = [0] * n                  # 親との重み",
            "",
            "  #親を出力",
            "  def find(self, x):",
            "      if self.parents[x] == x:",
            "          return x",
            "      else:",
            "          p = self.find(self.parents[x])",
            "          self.weights[x] += self.weights[self.parents[x]]",
            "          self.parents[x] = p",
            "          return p",
            "",
            "  # ユニオン",
            "  def unite(self, x, y, w):",
            "      # a[x]->a[y]  の差はw  # a[y]=a[x]+w",
            "      rx = self.find(x)",
            "      ry = self.find(y)",
            "      wx = self.weight(x)",
            "      wy = self.weight(y)",
            "      if rx == ry: return",
            "      if self.ranks[rx] > self.ranks[ry]:",
            "          rx , ry = ry, rx    #ryを親にする",
            "          wx , wy = wy, wx",
            "          w *= -1",
            "      self.parents[rx] = ry",
            "      self.sizes[ry] += self.sizes[rx]",
            "      self.weights[rx] = wy - wx - w",
            "      if self.ranks[rx]==self.ranks[ry]:",
            "          self.ranks[rx] += 1",
            "",
            "  #xとyが同じグループかどうか",
            "  def same(self, x, y):",
            "      return self.find(x) == self.find(y)",
            "",
            "  #xと同じグループの要素",
            "  def members(self, x):",
            "      root = self.find(x)",
            "      return {i for i in range(self.n) if self.find(i) == root}",
            "",
            "  #グループの要素数",
            "  def size(self, x):",
            "      root = self.find(x)",
            "      return self.sizes[root]",
            "",
            "  #親の要素一覧",
            "  def roots(self):",
            "      return {i for i, x in enumerate(self.parents) if i == x}",
            "",
            "  #グループの個数",
            "  def group_count(self):",
            "      return len(self.roots())",
            "",
            "  #グループのメンバー一覧",
            "  def all_group_members(self):",
            "      return {r: self.members(r) for r in self.roots()}",
            "",
            "  #重みの差",
            "  def weight(self, x):",
            "      _ = self.find(x)",
            "      return self.weights[x]",
            "",
            "  #重み",
            "  def diff(self, x, y):",
            "      rx = self.find(x)",
            "      ry = self.find(y)",
            "      if rx != ry: return float('inf')",
            "      return self.weight(y) - self.weight(x)",
            "",
            "  def __str__(self):",
            "      return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())",
            "",
            "##############",
            "",
            " m = map(int, input().split())",
            " = UnionFindWeighted(n)",
            "r _ in range(m):",
            "  a, b, w = map(int,input().split())",
            "  a -= 1; b -= 1",
            "  uf.unite(a, b, w)",
            ""
        ]
    },
    "差分最小値探索": {
        "prefix": [
            "Lib_差分最小値探索"
        ],
        "body": [
            "def near(a:list, b:list) -> tuple:",
            "    \"\"\"二つのソートされたリストの要素の差の最小値を探索",
            "",
            "    Returns",
            "    -------",
            "    tuple",
            "        最小となる位置の組み合わせと値",
            "        (i, j, a[i]-b[j])",
            "    \"\"\"",
            "    INF = float('inf')",
            "    if len(a) == 0 or len(b) == 0:",
            "        return (None, None, INF)",
            "    i, j = 0, 0",
            "    retd = INF",
            "    reta = -1",
            "    retb = -1",
            "    while i < len(a) and j < len(b):",
            "        dist = abs(a[i] - b[j])",
            "        if retd > dist:",
            "            retd = dist",
            "            reta= i",
            "            retb = j",
            "        if a[i] > b[j]:",
            "            j += 1",
            "        elif a[i] < b[j]:",
            "            i += 1",
            "        else:",
            "            break",
            "    return (reta, retb, retd)"
        ],
        "description": [
            "差分最小値探索"
        ]
    },
    "ユニオンファインド": {
        "prefix": [
            "lib_D_unionfind"
        ],
        "body": [
            "class UnionFind:",
            "    def __init__(self, n):                      # 初期化",
            "        self.n = n                              # 要素数",
            "        self.parents = [i for i in range(n)]    # 親",
            "        self.ranks = [0] * n                    # 木の深さ",
            "        self.sizes = [1] * n                    # グループの要素数",
            "        self.group_count = n                    # グループの数",
            "",
            "    def find(self, x):",
            "        \"\"\"親を出力",
            "        Parameters",
            "        ----------",
            "        x : int",
            "            ノード番号",
            "        \"\"\"",
            "        if self.parents[x] == x:",
            "            return x",
            "        else:",
            "            p = self.find(self.parents[x])",
            "            self.parents[x] = p",
            "            return p",
            "",
            "    def unite(self, x, y):",
            "        \"\"\"ユニオン",
            "        \"\"\"",
            "        x = self.find(x)",
            "        y = self.find(y)",
            "        if x == y: return",
            "        if self.ranks[x] > self.ranks[y]:",
            "            x , y = y, x    #yを親にする",
            "        if self.ranks[x] == self.ranks[y]:",
            "                self.ranks[y] += 1",
            "        self.parents[x] = y",
            "        self.sizes[y] += self.sizes[x]",
            "        self.group_count -= 1",
            "",
            "    def same(self, x, y) -> bool:",
            "        \"\"\"xとyが同じグループかどうか",
            "        \"\"\"",
            "        return self.find(x) == self.find(y)",
            "",
            "    def members(self, x):",
            "        \"\"\"xと同じグループの要素",
            "        \"\"\"",
            "        root = self.find(x)",
            "        return {i for i in range(self.n) if self.find(i) == root}",
            "",
            "    def size(self, x):",
            "        \"\"\"xのグループの要素数",
            "        \"\"\"",
            "        return self.sizes[self.find(x)]",
            "",
            "    @property",
            "    def roots(self):",
            "        \"\"\"親の要素一覧",
            "        \"\"\"",
            "        return {i for i, x in enumerate(self.parents) if i == x}",
            "",
            "    @property",
            "    def all_group_members(self):",
            "        \"\"\"グループのメンバー一覧",
            "        \"\"\"",
            "        group_members = defaultdict(list)",
            "        for x in range(self.n):",
            "            group_members[self.find(x)].append(x)",
            "        return group_members",
            "",
            "    def __str__(self):",
            "        return '\\n'.join(f'{r}: {self.members(r)}' for r in self.roots)",
            "",
            "################",
            "",
            "n, q = map(int, input().split())",
            "uf = UnionFind(n)",
            "for _ in range(q):",
            "    p, _a, _b = map(int,input().split())",
            "    _a -= 1; _b -= 1",
            "    if p == 0:",
            "        uf.unite(_a, _b)",
            "    else:",
            "        if uf.same(_a, _b):",
            "            print('Yes')",
            "        else:",
            "            print('No')",
            "",
            "# https://atcoder.jp/contests/atc001/tasks/unionfind_a",
            ""
        ],
        "description": [
            "ユニオンファインド"
        ]
    },
    "セグメント木": {
        "prefix": [
            "lib_Q_seg木（一点更新・区間集約)"
        ],
        "body": [
            "class SegmentTree:  # 初期化処理",
            "    \"\"\"Segment Tree",
            "    一点更新・区間集約",
            "    Parameters",
            "    ----------",
            "    init : list",
            "        初期リスト",
            "    f : SegmentTreeにのせるモノイド",
            "        作用素",
            "    ie : fに対する単位元",
            "    Notes",
            "    -----",
            "    1-indexed",
            "    https://atcoder.jp/contests/practice2/tasks/practice2_j",
            "    モノイドとは、集合と二項演算の組で、結合法則と単位元の存在するもの",
            "    ex. +, max, min",
            "    [ 1] a0 ・ a1  ・ a2 ・ a3 ・ a4 ・ a5 ・ a6 ・ a7  ->[0]",
            "    [ 2] a0 ・ a1  ・ a2 ・ a3       [ 3] a4 ・ a5 ・ a6・ a7",
            "    [ 4] a0 ・ a1    [ 5] a2 ・ a3   [ 6] a4 ・ a5   [ 7] a6 ・ a7",
            "    [ 8] a0 [ 9] a1  [10] a2 [11] a3 [12] a4 [13] a5 [14] a6 [15] a7",
            "                          [0001]",
            "              [0010]                  [0011]",
            "        [0100]      [0101]      [0110]      [0111]",
            "     [1000][1001][1010][1011][1100][1101][1110][1111]",
            "    size = 8  元の配列数の２べき乗値",
            "    親のインデックス         i//2 or i>>=1 bitで一個右シフト",
            "    左側の子のインデックス    2*i",
            "    右側の子のインデックス    2*i+1",
            "    aiの値が代入されているインデックス    i+size",
            "    \"\"\"",
            "    def __init__(self, init, f, ie):",
            "        self._f = f",
            "        self._ie = ie",
            "        if type(init) == int:",
            "            init = [ie] * init",
            "        self._n = len(init)",
            "        self._log = (self._n - 1).bit_length()  # seg木の深さ",
            "        self._size = 1 << self._log     # seg木のサイズ",
            "        # seg木の初期化",
            "        self._dat = [ie] * self._size + init + [ie] * (self._size - len(init))",
            "        for i in range(self._size-1, 0, -1):",
            "            self._update(i)",
            "",
            "",
            "    def update(self, i, x):",
            "        \"\"\"one point update",
            "        a[i] を xに更新",
            "        \"\"\"",
            "        #",
            "        i += self._size",
            "        self._dat[i] = x",
            "        while i > 0:    # 層をのぼりながら値を更新 indexが0になれば終了",
            "            i >>= 1     # 1つ上の層のインデックス(完全二分木における親)",
            "            # 下の層2つの演算結果の代入(完全二分木における子同士の演算)",
            "            self._update(i)",
            "",
            "",
            "    def get_value(self, i):",
            "        \"\"\"index = i の値を求める",
            "        \"\"\"",
            "        return self._dat[i + self._size]",
            "",
            "",
            "    def query(self, l, r):",
            "        \"\"\"半開区間[l, r)にf(a[l], a[l+1])演算",
            "        \"\"\"",
            "        # モノイドでは可換律は保証されていないので演算の方向に注意",
            "        l += self._size  # 1番下の層におけるインデックス",
            "        r += self._size  # 1番下の層におけるインデックス",
            "        # 左側の答えと右側の答えを初期化",
            "        lret, rret = self._ie, self._ie",
            "        while l < r:    # lとrが重なるまで上記の判定を用いて演算を実行",
            "            # 左が子同士の右側(lが奇数)(lの末桁=1)ならば、dat[l]を演算",
            "            if l & 1:",
            "                lret = self._f(lret, self._dat[l])",
            "                l += 1",
            "            # 右が子同士の右側(rが奇数)(rの末桁=1)ならば、dat[r-1]を演算",
            "            if r & 1:",
            "                r -= 1",
            "                rret = self._f(self._dat[r], rret)",
            "            l >>= 1",
            "            r >>= 1",
            "        return self._f(lret, rret)",
            "",
            "",
            "    def max_right(self, l, isOk):",
            "        \"\"\"",
            "        ex:",
            "        maxの場合 a[l]  a[r-1] が isOKとなる最大の値",
            "        (1): 関数 bool isOk(x) を定義し、segtreeの上で二分探索をする。",
            "        (2): 木の値を引数にとりboolを返す関数オブジェクトを渡して使用します。",
            "        r = l もしくは f(op(a[l], a[l + 1], ..., a[r - 1])) = true",
            "        r = n もしくは f(op(a[l], a[l + 1], ..., a[r])) = false",
            "        fが単調だとすれば、f(op(a[l], a[l + 1], ..., a[r - 1])) = true となる最大のr",
            "        \"\"\"",
            "        if l >= self._n: return self._n",
            "        l += self._size",
            "        sm = self._ie",
            "        while True:",
            "            while l % 2 == 0: l >>= 1",
            "            if not isOk(self._f(sm, self._dat[l])):",
            "                while l < self._size:",
            "                    l <<= 1",
            "                    if isOk(self._f(sm, self._dat[l])):",
            "                        sm = self._f(sm, self._dat[l])",
            "                        l += 1",
            "                return l - self._size",
            "            sm = self._f(sm, self._dat[l])",
            "            l += 1",
            "            if l & -l == l: break",
            "        return self._n",
            "",
            "",
            "    def min_left(self, r, isOk):",
            "        \"\"\"",
            "        l = r もしくは f(op(a[l], a[l + 1], ..., a[r - 1])) = true",
            "        l = 0 もしくは f(op(a[l-1], a[l], ..., a[r-1])) = false",
            "        fが単調だとすれば、f(op(a[l], a[l + 1], ..., a[r - 1])) = true となる最小のl",
            "        \"\"\"",
            "        if r <= 0: return 0",
            "        r += self._size",
            "        sm = self._ie",
            "        while True:",
            "            while r > 1 and r % 2 == 1: r >>= 1",
            "            if not isOk(self._f(self._dat[r], sm)):",
            "                while r < self._size:",
            "                    r = r << 1 | 1",
            "                    if isOk(self._f(self._dat[r], sm)):",
            "                        sm = self._f(self._dat[r], sm)",
            "                        r -= 1",
            "                return r + 1 - self._size",
            "            sm = self._f(self._dat[r], sm)",
            "            if r & -r == r: break",
            "        return 0",
            "",
            "",
            "    def _update(self, i):",
            "        # 下の層2つの演算結果の代入(完全二分木における子同士の演算)",
            "        self._dat[i] = self._f(self._dat[i*2], self._dat[i*2+1])",
            "",
            "####################################",
            "",
            "# Range Maximum Query",
            "def op(x, y):",
            "    return max(x, y)",
            "ie = -float('inf')",
            "",
            "",
            "# Range Minimum Query",
            "def op(x, y):",
            "    return min(x, y)",
            "ie = float('inf')",
            "",
            "",
            "# Range Add Query",
            "def op(x, y):",
            "    return x + y",
            "ie = 0",
            "",
            "",
            "# Range Product Query",
            "def op(x, y):",
            "    return x * y",
            "ie = 1",
            "",
            "",
            "# Range Xor Query",
            "def op(x, y):",
            "    return x ^ y",
            "ie = 0",
            "",
            "",
            "# Range GCD Query",
            "from math import gcd",
            "def op(x, y):",
            "    if x == ie: return y",
            "    if y == ie: return x",
            "    return gcd(x, y)",
            "ie = float('inf')",
            "",
            "####################################",
            "",
            "# Range Maximum Query",
            "def op(x, y):",
            "    return max(x, y)",
            "ie = -float('inf')",
            "",
            "",
            "# n, q = map(int, input().split())",
            "# a = list(map(int, input().split()))",
            "",
            "a = [1,2,3,2,1,3,3,5,2,1]",
            "sgt = SegmentTree(a, op, ie)",
            "# x, v = 3, 55123",
            "# l, r = 20, 25",
            "# sgt.update(x, v)",
            "# sgt.query(l, r)",
            "",
            "",
            "u = sgt.min_left(5, lambda y: y <= 2)",
            "print(u)",
            "u = sgt.min_left(4, lambda y: y <= 2)",
            "print(u)",
            ""
        ],
        "description": [
            "セグメント木"
        ]
    },
    "bfs迷路２次元タイプ": {
        "prefix": [
            "Lib_G_迷路2次元タイプ"
        ],
        "body": [
            "",
            "h, w = map(int, input().split())",
            "s = list(map(int, input().split()))",
            "t = list(map(int, input().split()))",
            "s[0] -= 1; s[1] -= 1",
            "t[0] -= 1; t[1] -= 1",
            "",
            "g = [list(input()) for _ in range(h)]",
            "",
            "def bfs(h, w, s, t):",
            "    direc = ((1, 0), (-1, 0), (0, 1), (0, -1))",
            "    seen = [[-1] * w for _ in range(h)]",
            "    que = deque([s])",
            "    seen[s[0]][s[1]] = 0",
            "    while que:",
            "        u, v = que.popleft()",
            "        for du, dv in direc:",
            "            nu = u + du",
            "            nv = v + dv",
            "            if (not isinhw(nu, nv, h, w)) or g[nu][nv] == '#' or seen[nu][nv] != -1:",
            "                continue",
            "            que.append((nu, nv))",
            "            seen[nu][nv] = seen[u][v] + 1",
            "    return seen",
            "",
            "print(bfs(h, w, s, t)[t[0]][t[1]])"
        ],
        "description": [
            "bfs迷路２次元タイプ"
        ]
    },
    "素因数分解": {
        "prefix": [
            "Lib_N_素因数分解"
        ],
        "body": [
            "##############################",
            "# 素因数分解",
            "# nは10**15くらいまでOK",
            "# returns dict s.t. key = {prime}   value = {degree}",
            "##############################",
            "def prime_factorize(n:int) -> dict:",
            "    if n == 1: return dict({1: 1})",
            "    pd = dict()",
            "    for p in range(2, int(n**0.5)+1):",
            "        if n % p != 0: p += 1; continue",
            "        d = 0",
            "        while n % p == 0:",
            "            d += 1",
            "            n //= p",
            "        pd[p] = d",
            "    if n != 1: pd[n] = 1",
            "    return pd",
            "",
            "print(prime_factorize(360))  # 72 = 2**3 * 3**2 * 5**1",
            "                             # {2: 3, 3: 2, 5: 1}",
            "",
            "##############################",
            "# 素因数分解（複数個版）",
            "# max(A)が大きい場合はNG  10**6くらいまで",
            "# 最初に素数一覧を作っておく",
            "##############################",
            "def prime_factorize(A : list):",
            "    Max = max(A) + 1",
            "    IsPrime = [True] * Max",
            "    MinFactor = [-1] * Max",
            "    dica = {}",
            "    IsPrime[0], IsPrime[1] = False, False",
            "    MinFactor[0], MinFactor[1] = 0, 1",
            "    for p in range(2, Max):",
            "        if IsPrime[p]:",
            "            MinFactor[p] = p",
            "            for k in range(p*2, Max, p):",
            "                IsPrime[k] = False",
            "                if MinFactor[k] == -1:",
            "                    MinFactor[k] = p",
            "",
            "    ret = []",
            "    for a in A:",
            "        res = dict()",
            "        while a != 1:",
            "            prime = MinFactor[a]",
            "            exp = 0",
            "            while MinFactor[a] == prime:",
            "                exp += 1",
            "                a //= prime",
            "            res[prime] = exp",
            "            if not prime in dica:",
            "                dica[prime] = 1",
            "            else:",
            "                dica[prime] += 1",
            "        ret.append(res)",
            "    return ret"
        ],
        "description": []
    },
    "n=intinput": {
        "prefix": [
            "n =int(input())"
        ],
        "body": [
            "n = int(input())"
        ],
        "description": [
            "整数nの読み込み"
        ]
    },
    "s=input": {
        "prefix": [
            "s =list(input())"
        ],
        "body": [
            "s = list(input())"
        ],
        "description": [
            "文字列sの読み込み"
        ]
    },
    "ab=mapintinput": {
        "prefix": [
            "a, b=map"
        ],
        "body": [
            "a, b = map(int, input().split())"
        ],
        "description": [
            "整数a, bの読み込み"
        ]
    },
    "n,m=map(int, input().split())": {
        "prefix": [
            "n, m=map"
        ],
        "body": [
            "n, m = map(int, input().split())"
        ],
        "description": [
            "整数n, mの読み込み"
        ]
    },
    "n,k=map(int, input().split())": {
        "prefix": [
            "n, k=map"
        ],
        "body": [
            "n, k = map(int, input().split())"
        ],
        "description": [
            "整数n, kの読み込み"
        ]
    },
    "a=list(map(int, input().split()))": {
        "prefix": [
            "a =list"
        ],
        "body": [
            "a = list(map(int, input().split()))"
        ],
        "description": [
            "リストの読み込み"
        ]
    },
    "b=list(map(int, input().split()))": {
        "prefix": [
            "b =list"
        ],
        "body": [
            "b = list(map(int, input().split()))"
        ],
        "description": [
            "リストの読み込み"
        ]
    },
    "edges": {
        "prefix": [
            "edges ="
        ],
        "body": [
            "edges = [[] for _ in range($n)]",
            "for _ in range($m):",
            "    _a, _b = map(int1, input().split())",
            "    edges[_a].append(_b)",
            "    edges[_b].append(_a)",
            ""
        ],
        "description": [
            "edges"
        ]
    },
    "edgesweighted": {
        "prefix": [
            "edges = w"
        ],
        "body": [
            "edges = [[] for _ in range($n)]",
            "for _ in range($m):",
            "    _a, _b, _w = map(int, input().split())",
            "    _a -= 1; _b -= 1",
            "    edges[_a].append((_b, _w))",
            "    edges[_b].append((_a, _w))",
            ""
        ],
        "description": [
            "edges(重み付き)"
        ]
    },
    "0インデックス": {
        "prefix": [
            "a -= 1; b -= 1"
        ],
        "body": [
            "a -= 1; b -= 1"
        ],
        "description": [
            "0-indexed"
        ]
    }
}